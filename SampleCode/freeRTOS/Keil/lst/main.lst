L 1 "..\main.c"
N/**************************************************************************//**
N * @file     main.c
N * @version  V3.0
N * $Revision: 2 $
N * $Date: 2016/02/29 LoRa Node v1.2
N *		Add server.
N *		for experiment, CMD SF change, add BW change
N * @brief
N *           LoRA Channel activity detection(CAD) test.
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060034
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 15 "..\main.c" 2
N#include "NUC100Series.h"
L 1 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 1
N/**************************************************************************//**
N * @file     NUC100Series.h
N * @version  V3.0
N * $Revision: 20 $
N * $Date: 15/05/12 5:48p $
N * @brief    NUC100 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC100 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fix SC_SET_STOP_BIT_LEN define error in SC Driver.
N  * \li Fix all IAR samples to set entry point from __iar_program_start to Reset_Handler.
N  * \li Fix all samples that run faster than 50MHz. (NUC100 series only support up to 50MHz).
N  * \li Fix UART1->IRCR setting bug in IrDA_FunctionTxTest().
N  * \li Fix Flush FIFO end test message print bug in the end of RS485_9bitModeSlave().
N  * \li Fix the wrong shift position for HCLK divider in main() of SYS sample code.
N  * \li Fix PLLCON_SETTING constant define from SYSCLK_PLLCON_50MHz_XTAL to CLK_PLLCON_50MHz_HXT.
N  * \li Fix bug on CLKO multi-function pin configuration in SYS_Init() of same samples.
N  * \li Fix UA_LIN_CTL[4] bit field name is "MUTE_EN" not "WAKE_EN" in UART LIN_CTL Bit Field Definitions. 
N  * \li Fix CLK_SetCoreClock() core lock range from "25~50MHz" to "25~72MHz".
N  * \li Fix CLK_SysTickDelay() bug, that COUNTFLAG(SysTick_CTRL[16]) may not be cleared after write SysTick_VAL.
N  * \li Fix typo in UA_LIN_CTL constants definitions of UART driver, it is "UART_LIN_CTL_LIN_BKDET_EN" not "UART_LIN_CTL_LIN_BKDET_ENN".
N  * \li Fix UA_LIN_CTL[4] bit field name of UART driver. It is "MUTE_EN" not "WAKE_EN" in UA_LIN_CTL constants definitions.
N  * \li Fix API declare name from I2C_SetClockBusFreq() to I2C_SetBusClockFreq() in I2C driver.
N  * \li Fix SYS_IS_SYSTEM_RST() bug in SYS driver, it is "SYS_RSTSRC_RSTS_SYS_Msk" not "SYS_RSTSRC_RSTS_MCU_Msk".
N  * \li Fix typo of PD14 Multi-Function constant definitions.
N  * \li Fix clear Time-out flag method bug in I2C_ClearTimeoutFlag() of I2C driver.
N  * \li Fix PDMA_IS_CH_BUSY() definition bug in PDMA driver.
N  * \li Remove unused PWRCON, FREQ_72MHZ constant definitions from clock driver.
N  * \li Remove unused constant define "RXBUFSIZE".
N  * \li Add SPI_SET_SS_LEVEL() macro definition. This macro allows user to set both SPI_SS pins.
N  * \li Add a lack macro, SYS_IS_LVR_RST() to SYS driver.
N  * \li Add UART FIFO size constants definitions to UART driver.
N  * \li Add CLK_PLLCON_25MHz_HXT, CLK_PLLCON_25MHz_HIRC, CLK_PLLCON_24MHz_HXT, and CLK_PLLCON_24MHz_HIRC constant definitions to CLK driver.
N  * \li Add FMC_MultiBoot_SwReset sample code to show how to boot to different AP.
N  * \li Modify time-out counter to a fix value and not to use SystemCoreClockUpdate() in CLK_WaitClockReady() to improve compatibility.
N  * \li Revise the following four macro definitions to avoid affecting another SPI_SS pin, SPI_SET_SS0_HIGH(), SPI_SET_SS1_HIGH(), SPI_SET_SS0_LOW() and SPI_SET_SS1_LOW().
N  *
N  * <b>Revision 3.00.001</b>
N  * \li First Release to support Nuvoton BSP v3.0
N*/
N
N#ifndef __NUC100Series_H__
N#define __NUC100Series_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N*/
N
N/** @addtogroup CMSIS Device Definitions for CMSIS
N  Interrupt Number Definition and Configurations for CMSIS
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
N
Ntypedef enum IRQn
N{
N    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N    NonMaskableInt_IRQn         = -14,    /*!< Non Maskable Interrupt                                 */
N    HardFault_IRQn              = -13,    /*!< Cortex-M0 Hard Fault Interrupt                         */
N    SVCall_IRQn                 = -5,     /*!< Cortex-M0 SV Call Interrupt                            */
N    PendSV_IRQn                 = -2,     /*!< Cortex-M0 Pend SV Interrupt                            */
N    SysTick_IRQn                = -1,     /*!< Cortex-M0 System Tick Interrupt                        */
N
N    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt               */
N    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                              */
N    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                        */
N    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                        */
N    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                   */
N    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                             */
N    PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                         */
N    PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                         */
N    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                       */
N    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                       */
N    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                       */
N    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                       */
N    UART02_IRQn               = 12,       /*!< UART0/UART2 Interrupt                                  */
N    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                        */
N    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                         */
N    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                         */
N    SPI2_IRQn                 = 16,       /*!< SPI2 Interrupt                                         */
N    SPI3_IRQn                 = 17,       /*!< SPI3 Interrupt                                         */
N    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                         */
N    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                         */
N    CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                         */
N    CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                         */
N    SC012_IRQn                = 22,       /*!< SC0/SC1/SC2 Interrupt                                  */
N    USBD_IRQn                 = 23,       /*!< USB device Interrupt                                   */
N    PS2_IRQn                  = 24,       /*!< PS/2 device Interrupt                                  */
N    ACMP_IRQn                 = 25,       /*!< ACMP0 Interrupt                                        */
N    PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                         */
N    I2S_IRQn                  = 27,       /*!< I2S Interrupt                                          */
N    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                           */
N    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                          */
N    IRC_IRQn                  = 30,       /*!< IRC TRIM Interrupt                                     */
N    RTC_IRQn                  = 31        /*!< RTC Interrupt                                          */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N/*@}*/ /* end of group CMSIS */
N
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 "..\..\..\Library\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     13. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 116 "..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060528 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMINSTR_H */
L 117 "..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060528 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMFUNC_H */
L 118 "..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
L 149 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "system_NUC100Series.h"        /* NUC100 System                                          */
L 1 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\system_NUC100Series.h" 1
N/**************************************************************************//**
N * @file     system_NUC100Series.h
N * @version  V3.0
N * $Revision: 1 $
N * $Date: 14/12/08 11:47a $
N * @brief    NUC100 Series CMSIS System Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYSTEM_NUC2xx_H
N#define __SYSTEM_NUC2xx_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* Using UART0 or UART1 */
N#define DEBUG_PORT   UART0
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __HXT       (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __LXT       (32768UL)       /*!< External Crystal Clock Frequency 32.768KHz */
N#define __HIRC      (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __LIRC      (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HSI       (50000000UL)    /*!< PLL default output is 50MHz */
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;        /*!< Cycles per micro second              */
Nextern uint32_t PllClock;           /*!< PLL Output Clock Frequency           */
N
N/**
N * Initialize the system
N *
N * @param  None
N * @return None
N *
N * @brief  Setup the microcontroller system
N *         Initialize GPIO directions and values
N */
Nextern void SystemInit(void);
N
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  None
N * @return None
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from CPU registers.
N */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 150 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/*-------------------------------- Device Specific Peripheral registers structures ---------------------*/
N/** @addtogroup REGISTER Control Register
N  Peripheral Control Registers
N  @{
N */
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller (ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var ACMP_T::CMPCR
N * Offset: 0x00~0x04  Analog Comparator Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPEN     |Comparator Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |CMPIE     |Comparator Interrupt Enable
N * |        |          |0 = Interrupt function
N * |        |          |Disabled.
N * |        |          |1 = Interrupt function
N * |        |          |Enabled.
N * |[2]     |CMP_HYSEN |Comparator Hysteresis Enable
N * |        |          |0 = Hysteresis function Disabled (Default).
N * |        |          |1 = Hysteresis function
N * |        |          |Enabled.
N * |[4]     |CMPCN     |Comparator Negative Input Selection
N * |        |          |0 = The source of the negative comparator input is from ACMPn_N pin (n = 0, 1).
N * |        |          |1 = Internal band-gap reference voltage is selected as the source
N * |        |          |    of negative comparator input.
N * |[6]     |CMPINV    |Comparator Output Inverse Enable
N * |        |          |0 = Comparator analog output inverse is Disabled.
N * |        |          |1 = Comparator analog output inverse is Enabled.
N * @var ACMP_T::CMPSR
N * Offset: 0x08  Analog Comparator Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPF0     |Comparator 0 Interrupt Flag
N * |        |          |This bit is set by hardware whenever the comparator 0 output changes state.
N * |        |          |This will cause an interrupt if CMPCR0[1] is set to 1.
N * |        |          |Write 1 to clear this bit to 0.
N * |[1]     |CMPF1     |Comparator 1 Interrupt Flag
N * |        |          |This bit is set by hardware whenever the comparator 1 output changes state.
N * |        |          |This will cause an interrupt if CMPCR1[1] is set to 1.
N * |        |          |Write 1 to clear this bit to 0.
N * |[2]     |CO0       |Comparator 0 Output
N * |        |          |Synchronized to the APB clock to allow reading by software.
N * |        |          |Cleared when the comparator 0 is disabled (CMPCR0[0] = 0).
N * |[3]     |CO1       |Comparator 1 Output
N * |        |          |Synchronized to the APB clock to allow reading by software.
N * |        |          |Cleared when the comparator 1 is disabled (CMPCR1[0] = 0).
N */
N
N    __IO uint32_t CMPCR[2];      /* Offset: 0x00  Analog Comparator 0 Control Register                               */
X    volatile uint32_t CMPCR[2];       
N    __IO uint32_t CMPSR;         /* Offset: 0x04  Analog Comparator 1 Control Register                               */
X    volatile uint32_t CMPSR;          
N
N} ACMP_T;
N
N
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N
N/* CMPCR Bit Field Definitions */
N#define ACMP_CMPCR_CMPINV_Pos      6                                   /*!< ACMP_T::CMPCR: CMPINV Position */
N#define ACMP_CMPCR_CMPINV_Msk      (1ul << ACMP_CMPCR_CMPINV_Pos)      /*!< ACMP_T::CMPCR: CMPINV Mask */
N
N#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP_T::CMPCR: CMPCN Position */
N#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP_T::CMPCR: CMPCN Mask */
N
N#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP_T::CMPCR: CMP_HYSEN Position */
N#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP_T::CMPCR: CMP_HYSEN Mask */
N
N#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP_T::CMPCR: CMPIE Position */
N#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP_T::CMPCR: CMPIE Mask */
N
N#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP_T::CMPCR: CMPEN Position */
N#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP_T::CMPCR: CMPEN Mask */
N
N/* CMPSR Bit Field Definitions */
N#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP_T::CMPSR: CO1 Position */
N#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP_T::CMPSR: CO1 Mask */
N
N#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP_T::CMPSR: CO0 Position */
N#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP_T::CMPSR: CO0 Mask */
N
N#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP_T::CMPSR: CMPF1 Position */
N#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP_T::CMPSR: CMPF1 Mask */
N
N#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP_T::CMPSR: CMPF0 Position */
N#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP_T::CMPSR: CMPF0 Mask */
N
N/*@}*/ /* end of group ACMP_CONST */
N/*@}*/ /* end of group ACMP */
N
N
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N/** @addtogroup ADC Analog to Digital Converter (ADC)
N  Memory Mapped Structure for ADC Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var ADC_T::ADDR
N * Offset: 0x00-0x1C  ADC Data Register x
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RSLT      |A/D Conversion Result
N * |        |          |This field contains conversion result of ADC.
N * |        |          |When DMOF bit (ADCR[31]) set to 0, 12-bit ADC conversion result with unsigned format will be
N * |        |          |filled in RSLT (ADDRx[11:0], x=0~7) and zero will be filled in RSLT (ADDRx[15:12], x=0~7).
N * |        |          |When DMOF bit (ADCR[31]) set to 1, 12-bit ADC conversion result with 2'complement format
N * |        |          |will be filled in RSLT(ADDRx[11:0], x=0~7) and signed bits to will be filled in RSLT
N * |        |          |(ADDRx[15:12], x=0~7).
N * |[16]    |OVERRUN   |Overrun Flag
N * |        |          |0 = Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result.
N * |        |          |1 = Data in RSLT (ADDRx[15:0], x=0~7) is overwritten.
N * |        |          |If converted data in RSLT has not been read before new conversion result is loaded to this
N * |        |          |register, OVERRUN is set to 1 and previous conversion result is gone.
N * |        |          |It is cleared by hardware after ADDR register is read.
N * |        |          |This is a read only bit.
N * |[17]    |VALID     |Valid Flag
N * |        |          |0 = Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid.
N * |        |          |1 = Data in RSLT bits (ADDRx[15:0], x=0~7) is valid.
N * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed and
N * |        |          |cleared by hardware after ADDR register is read.
N * |        |          |This is a read only bit
N * @var ADC_T::ADCR
N * Offset: 0x20  ADC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADEN      |A/D Converter Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Before starting A/D conversion function, this bit should be set to 1.
N * |        |          |Clear it to 0 to disable A/D converter analog circuit for saving power consumption.
N * |[1]     |ADIE      |A/D Interrupt Enable
N * |        |          |0 = A/D interrupt function Disabled.
N * |        |          |1 = A/D interrupt function Enabled.
N * |        |          |A/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.
N * |[3:2]   |ADMD      |A/D Converter Operation Mode
N * |        |          |00 = Single conversion.
N * |        |          |01 = Reserved.
N * |        |          |10 = Single-cycle scan.
N * |        |          |11 = Continuous scan.
N * |        |          |When changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.
N * |[5:4]   |TRGS      |Hardware Trigger Source
N * |        |          |00 = A/D conversion is started by external STADC pin.
N * |        |          |11 = A/D conversion is started by PWM Center-aligned trigger.
N * |        |          |Others = Reserved.
N * |        |          |Software should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.
N * |[7:6]   |TRGCOND   |External Trigger Condition
N * |        |          |These two bits decide external pin STADC trigger event is level or edge.
N * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at
N * |        |          |high and low state for edge trigger.
N * |        |          |00 = Low level.
N * |        |          |01 = High level.
N * |        |          |10 = Falling edge.
N * |        |          |11 = Rising edge.
N * |[8]     |TRGEN     |Hardware Trigger Enable
N * |        |          |Enable or disable triggering of A/D conversion by hardware (external STADC pin or PWM
N * |        |          |Center-aligned trigger).
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |ADC hardware trigger function is only supported in single-cycle scan mode.
N * |        |          |If hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware
N * |        |          |trigger source.
N * |[9]     |PTEN      |PDMA Transfer Enable
N * |        |          |0 = PDMA data transfer Disabled.
N * |        |          |1 = PDMA data transfer in ADDR 0~7 Enabled.
N * |        |          |When A/D conversion is completed, the converted data is loaded into ADDR 0~7, software can
N * |        |          |enable this bit to generate a PDMA data transfer request.
N * |        |          |When PTEN=1, software must set ADIE=0 (ADCR[1]) to disable interrupt.
N * |[10]    |DIFFEN    |Differential Input Mode Enable
N * |        |          |0 = Single-end analog input mode.
N * |        |          |1 = Differential analog input mode.
N * |        |          |Differential   input Paired Channel
N * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus
N * |        |          |is the analog input; Vminus is the inverted analog input.
N * |        |          |In differential input mode, only the even number of the two corresponding channels needs to
N * |        |          |be enabled in ADCHER.
N * |        |          |The conversion result will be placed to the corresponding data register of the enabled
N * |        |          |channel.
N * |[11]    |ADST      |A/D Conversion Start
N * |        |          |0 = Conversion stops and A/D converter enter idle state.
N * |        |          |1 = Conversion starts.
N * |        |          |ADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and
N * |        |          |external pin STADC.
N * |        |          |ADST will be cleared to 0 by hardware automatically at the ends of single mode and
N * |        |          |single-cycle scan mode.
N * |        |          |In continuous scan mode, A/D conversion is continuously performed until software writes 0 to
N * |        |          |this bit or chip reset.
N * |[31]    |DMOF      |A/D Differential Input Mode Output Format
N * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format.
N * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement
N * |        |          |format.
N * @var ADC_T::ADCHER
N * Offset: 0x24  ADC Channel Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CHEN      |Analog Input Channel Enable
N * |        |          |Set CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0.
N * |        |          |If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.
N * |        |          |0 = ADC input channel Disabled.
N * |        |          |1 = ADC input channel Enabled.
N * |[9:8]   |PRESEL    |Analog Input Channel 7 Select
N * |        |          |00 = External analog input.
N * |        |          |01 = Internal band-gap voltage.
N * |        |          |10 = Internal temperature sensor.
N * |        |          |11 = Reserved.
N * |        |          |Note:
N * |        |          |When software select the band-gap voltage as the analog input source of ADC channel 7, ADC
N * |        |          |clock rate needs to be limited to slower than 300 kHz.
N * @var ADC_T::ADCMPR
N * Offset: 0x28  ADC Compare Register x
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPEN     |Compare Enable
N * |        |          |0 = Compare function Disabled.
N * |        |          |1 = Compare function Enabled.
N * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified
N * |        |          |channel conversion result when converted data is loaded into ADDR register.
N * |[1]     |CMPIE     |Compare Interrupt Enable
N * |        |          |0 = Compare function interrupt Disabled.
N * |        |          |1 = Compare function interrupt Enabled.
N * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND
N * |        |          |(ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted,
N * |        |          |in the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is
N * |        |          |generated.
N * |[2]     |CMPCOND   |Compare Condition
N * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the
N * |        |          |12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
N * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or
N * |        |          |equal to the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
N * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the
N * |        |          |CMPF0/1 bit (ADSR[1]/[2]) will be set.
N * |[5:3]   |CMPCH     |Compare Channel Selection
N * |        |          |000 = Channel 0 conversion result is selected to be compared.
N * |        |          |001 = Channel 1 conversion result is selected to be compared.
N * |        |          |010 = Channel 2 conversion result is selected to be compared.
N * |        |          |011 = Channel 3 conversion result is selected to be compared.
N * |        |          |100 = Channel 4 conversion result is selected to be compared.
N * |        |          |101 = Channel 5 conversion result is selected to be compared.
N * |        |          |110 = Channel 6 conversion result is selected to be compared.
N * |        |          |111 = Channel 7 conversion result is selected to be compared.
N * |[11:8]  |CMPMATCNT |Compare Match Count
N * |        |          |When the specified A/D channel analog conversion result matches the compare condition
N * |        |          |defined by CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1.
N * |        |          |When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1
N * |        |          |bit (ADSR[1]/[2]) will be set.
N * |[27:16] |CMPD      |Comparison Data
N * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
N * |        |          |When DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result
N * |        |          |with unsigned format.
N * |        |          |CMPD should be filled in unsigned format.
N * |        |          |When DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result
N * |        |          |with 2'complement format.
N * |        |          |CMPD should be filled in 2'complement format.
N * @var ADC_T::ADSR
N * Offset: 0x30  ADC Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADF       |A/D Conversion End Flag
N * |        |          |A status flag that indicates the end of A/D conversion.
N * |        |          |ADF is set to 1 at these two conditions:
N * |        |          |1. When A/D conversion ends in Single mode.
N * |        |          |2. When A/D conversion ends on all specified channels in Scan mode.
N * |        |          |This flag can be cleared by writing 1 to itself.
N * |[1]     |CMPF0     |Compare Flag
N * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this
N * |        |          |bit is set to 1.
N * |        |          |And it is cleared by writing 1 to self.
N * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
N * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
N * |[2]     |CMPF1     |Compare Flag
N * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this
N * |        |          |bit is set to 1.
N * |        |          |And it is cleared by writing 1 to self.
N * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
N * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
N * |[3]     |BUSY      |BUSY/IDLE
N * |        |          |0 = A/D converter is in idle state.
N * |        |          |1 = A/D converter is busy at conversion.
N * |        |          |This bit is mirror of as ADST bit (ADCR[11]).
N * |        |          |It is read only.
N * |[6:4]   |CHANNEL   |Current Conversion Channel
N * |        |          |This field reflects the current conversion channel when BUSY = 1 (ADSR[3]).
N * |        |          |When BUSY = 0, it shows the number of the next converted channel.
N * |        |          |It is read only.
N * |[15:8]  |VALID     |Data Valid Flag
N * |        |          |It is a mirror of VALID bit (ADDR0~7[17]).
N * |        |          |It is read only.
N * |[23:16] |OVERRUN   |Overrun Flag
N * |        |          |It is a mirror to OVERRUN bit (ADDR0~7[16]).
N * |        |          |It is read only.
N * @var ADC_T::ADPDMA
N * Offset: 0x40  ADC PDMA Current Transfer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[17:0]  |AD_PDMA   |ADC PDMA Current Transfer Data Register
N * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
N * |        |          |Current PDMA transfer data is the content of ADDR0 ~ ADDR7.
N * |        |          |This is a read only register.
N */
N
N    __I  uint32_t ADDR[8];       /* Offset: 0x00-0x1C  ADC Data Register x                                           */
X    volatile const  uint32_t ADDR[8];        
N    __IO uint32_t ADCR;          /* Offset: 0x20  ADC Control Register                                               */
X    volatile uint32_t ADCR;           
N    __IO uint32_t ADCHER;        /* Offset: 0x24  ADC Channel Enable Register                                        */
X    volatile uint32_t ADCHER;         
N    __IO uint32_t ADCMPR[2];     /* Offset: 0x28  ADC Compare Register x                                             */
X    volatile uint32_t ADCMPR[2];      
N    __IO uint32_t ADSR;          /* Offset: 0x30  ADC Status Register                                                */
X    volatile uint32_t ADSR;           
N    __I  uint32_t RESERVE0[3];  
X    volatile const  uint32_t RESERVE0[3];  
N    __I  uint32_t ADPDMA;        /* Offset: 0x40  ADC PDMA Current Transfer Data Register                            */
X    volatile const  uint32_t ADPDMA;         
N
N} ADC_T;
N
N
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
N
N#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
N
N#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
N
N#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
N
N#define ADC_ADCR_PTEN_Pos       9                                 /*!< ADC_T::ADCR: PTEN Position */
N#define ADC_ADCR_PTEN_Msk       (1ul << ADC_ADCR_PTEN_Pos)        /*!< ADC_T::ADCR: PTEN Mask */
N
N#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
N
N#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
N
N#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
N
N#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
N
N#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
N
N#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
N
N/* ADPDMA Bit Field Definitions */
N#define ADC_ADPDMA_AD_PDMA_Pos     0                                     /*!< ADC_T::ADPDMA: AD_PDMA Position */
N#define ADC_ADPDMA_AD_PDMA_Msk     (0x3FFFFul << ADC_ADPDMA_AD_PDMA_Pos) /*!< ADC_T::ADPDMA: AD_PDMA Mask */
N
N/*@}*/ /* end of group ADC_CONST */
N/*@}*/ /* end of group ADC */
N
N
N
N/*---------------------------- Clock Controller ------------------------------*/
N/** @addtogroup CLK System Clock Controller (CLK)
N  Memory Mapped Structure for System Clock Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var CLK_T::PWRCON
N * Offset: 0x00  System Power-down Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |XTL12M_EN |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
N * |        |          |The bit default value is set by flash controller user configuration register CONFIG0
N * |        |          |[26:24].
N * |        |          |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set
N * |        |          |to 1 automatically.
N * |        |          |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
N * |        |          |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[1]     |XTL32K_EN |External 32.768 KHz Low Speed Crystal Enable (LXT) Control (Write Protect)
N * |        |          |0 = External 32.768 kHz low speed crystal oscillator (LXT) Disabled.
N * |        |          |1 = External 32.768 kHz low speed crystal oscillator (LXT) Enabled (Normal operation).
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[2]     |OSC22M_EN |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
N * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
N * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[3]     |OSC10K_EN |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
N * |        |          |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
N * |        |          |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[4]     |PD_WU_DLY |Wake-up Delay Counter Enable Control (Write Protect)
N * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock
N * |        |          |cycles to wait system clock stable.
N * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed
N * |        |          |crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
N * |        |          |0 = Clock cycles delay Disabled.
N * |        |          |1 = Clock cycles delay Enabled.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
N * |        |          |Note2: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[6]     |PD_WU_STS |Power-Down Mode Wake-Up Interrupt Status
N * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode
N * |        |          |The flag is set if the GPIO, USB, UART, WDT, I2C, TIMER, ACMP, BOD or RTC wake-up occurred
N * |        |          |Write 1 to clear the bit to 0.
N * |        |          |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.
N * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
N * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will
N * |        |          |depends on the PD_WAIT_CPU bit
N * |        |          |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the
N * |        |          |PWR_DOWN_EN bit set.
N * |        |          |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also
N * |        |          |active and then the chip enters Power-down mode (recommend)
N * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
N * |        |          |User needs to set this bit again for next Power-down.
N * |        |          |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184
N * |        |          |MHz high speed oscillator will be disabled in this mode, but the external 32.768 kHz low
N * |        |          |speed crystal and internal 10 kHz low speed oscillator are not controlled by Power-down
N * |        |          |mode.
N * |        |          |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source
N * |        |          |selection.
N * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock
N * |        |          |source is from external 32.768 kHz low speed crystal oscillator or the internal 10 kHz low
N * |        |          |speed oscillator.
N * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
N * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[8]     |PD_WAIT_CPU|This Bit Control The Power-Down Entry Condition (Write Protect)
N * |        |          |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
N * |        |          |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1
N * |        |          |and CPU run WFI instruction.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * @var CLK_T::AHBCLK
N * Offset: 0x04  AHB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |PDMA_EN   |PDMA Controller Clock Enable Control
N * |        |          |0 = PDMA peripheral clock Disabled.
N * |        |          |1 = PDMA peripheral clock Enabled.
N * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
N * |        |          |0 = Flash ISP peripheral clock Disabled.
N * |        |          |1 = Flash ISP peripheral clock Enabled.
N * |[3]     |EBI_EN    |EBI Controller Clock Enable Control
N * |        |          |0 = EBI peripheral clock Disabled.
N * |        |          |1 = EBI peripheral clock Enabled.
N * @var CLK_T::APBCLK
N * Offset: 0x08  APB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
N * |        |          |0 = Watchdog Timer clock Disabled.
N * |        |          |1 = Watchdog Timer clock Enabled.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[1]     |RTC_EN    |Real-Time-Clock APB Interface Clock Enable Control
N * |        |          |This bit is used to control the RTC APB clock only, The RTC peripheral clock source is
N * |        |          |selected from RTC_SEL_10K(CLKSEL2[18]).
N * |        |          |It can be selected to the external 32.768 kHz low speed crystal or Internal 10 kHz low speed
N * |        |          |oscillator.
N * |        |          |0 = RTC clock Disabled.
N * |        |          |1 = RTC clock Enabled.
N * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N * |        |          |0 = Timer0 clock Disabled.
N * |        |          |1 = Timer0 clock Enabled.
N * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N * |        |          |0 = Timer1 clock Disabled.
N * |        |          |1 = Timer1 clock Enabled.
N * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
N * |        |          |0 = Timer2 clock Disabled.
N * |        |          |1 = Timer2 clock Enabled.
N * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
N * |        |          |0 = Timer3 clock Disabled.
N * |        |          |1 = Timer3 clock Enabled.
N * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
N * |        |          |0 = FDIV clock Disabled.
N * |        |          |1 = FDIV clock Enabled.
N * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
N * |        |          |0 = I2C0 clock Disabled.
N * |        |          |1 = I2C0 clock Enabled.
N * |[9]     |I2C1_EN   |I2C1 Clock Enable Control
N * |        |          |0 = I2C1 clock Disabled.
N * |        |          |1 = I2C1 clock Enabled.
N * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
N * |        |          |0 = SPI0 clock Disabled.
N * |        |          |1 = SPI0 clock Enabled.
N * |[13]    |SPI1_EN   |SPI1 Clock Enable Control
N * |        |          |0 = SPI1 clock Disabled.
N * |        |          |1 = SPI1 clock Enabled.
N * |[14]    |SPI2_EN   |SPI2 Clock Enable Control
N * |        |          |0 = SPI2 clock Disabled.
N * |        |          |1 = SPI2 clock Enabled.
N * |[15]    |SPI3_EN   |SPI3 Clock Enable Control
N * |        |          |0 = SPI3 clock Disabled.
N * |        |          |1 = SPI3 clock Enabled.
N * |[16]    |UART0_EN  |UART0 Clock Enable Control
N * |        |          |0 = UART0 clock Disabled.
N * |        |          |1 = UART0 clock Enabled.
N * |[17]    |UART1_EN  |UART1 Clock Enable Control
N * |        |          |0 = UART1 clock Disabled.
N * |        |          |1 = UART1 clock Enabled.
N * |[18]    |UART2_EN  |UART2 Clock Enable Control
N * |        |          |0 = UART2 clock Disabled.
N * |        |          |1 = UART2 clock Enabled.
N * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control
N * |        |          |0 = PWM01 clock Disabled.
N * |        |          |1 = PWM01 clock Enabled.
N * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control
N * |        |          |0 = PWM23 clock Disabled.
N * |        |          |1 = PWM23 clock Enabled.
N * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control
N * |        |          |0 = PWM45 clock Disabled.
N * |        |          |1 = PWM45 clock Enabled.
N * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control
N * |        |          |0 = PWM67 clock Disabled.
N * |        |          |1 = PWM67 clock Enabled.
N * |[27]    |USBD_EN   |USB 2.0 FS Device Controller Clock Enable Control
N * |        |          |0 = USB clock Disabled.
N * |        |          |1 = USB clock Enabled.
N * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
N * |        |          |0 = ADC clock Disabled.
N * |        |          |1 = ADC clock Enabled.
N * |[29]    |I2S_EN    |I2S Clock Enable Control
N * |        |          |0 = I2S clock Disabled.
N * |        |          |1 = I2S clock Enabled.
N * |[30]    |ACMP_EN   |Analog Comparator Clock Enable Control
N * |        |          |0 = Analog Comparator clock Disabled.
N * |        |          |1 = Analog Comparator clock Enabled.
N * |[31]    |PS2_EN    |PS/2 Clock Enable Control
N * |        |          |0 = PS/2 clock Disabled.
N * |        |          |1 = PS/2 clock Enabled.
N * @var CLK_T::CLKSTATUS
N * Offset: 0x0C  Clock status monitor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
N * |        |          |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
N * |        |          |1 = External 4~24 MHz high speed crystal clock (HXT) is stable.
N * |[1]     |XTL32K_STB|External 32.768 KHz Low Speed Crystal (LXT) Clock Source Stable Flag(Read Only)
N * |        |          |0 = External 32.768 kHz low speed crystal (LXT) clock is not stable or disabled.
N * |        |          |1 = External 32.768 kHz low speed crystal (LXT) clock is stable.
N * |[2]     |PLL_STB   |Internal PLL Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal PLL clock is not stable or disabled.
N * |        |          |1 = Internal PLL clock is stable.
N * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
N * |        |          |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable.
N * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
N * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable.
N * |[7]     |CLK_SW_FAIL|Clock Switching Fail Flag (Read Only)
N * |        |          |0 = Clock switching success.
N * |        |          |1 = Clock switching failure.
N * |        |          |This bit is an index that if current system clock source is match as user defined at HCLK_S
N * |        |          |(CLKSEL[2:0]).
N * |        |          |When user switch system clock, the system clock source will keep old clock until the new
N * |        |          |clock is stable.
N * |        |          |During the period that waiting new clock stable, this bit will be an index shows system
N * |        |          |clock source is not match as user wanted.
N * @var CLK_T::CLKSEL0
N * Offset: 0x10  Clock Source Select Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |HCLK_S    |HCLK Clock Source Select (Write Protect)
N * |        |          |1. Before clock switching, the related clock sources (both pre-select and new-select) must
N * |        |          |be turn on
N * |        |          |2.
N * |        |          |The 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user
N * |        |          |configuration register of Flash controller by any reset.
N * |        |          |Therefore the default value is either 000b or 111b.
N * |        |          |3.
N * |        |          |These bits are protected bit, It means programming this bit needs to write "59h", "16h",
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |010 = Clock source from PLL clock.
N * |        |          |011 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Select (Write Protect)
N * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
N * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by STCLK_S(CLKSEL0[5:3]).
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from external 4~24 MHz high speed crystal clock/2.
N * |        |          |011 = Clock source from HCLK/2.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock/2.
N * |        |          |Note1: These bits are protected bit.
N * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |        |          |Note2: if SysTick clock source is not from HCLK (i.e.
N * |        |          |SYST_CSR[2] = 0), SysTick clock source must less than or equal to HCLK/2.
N * @var CLK_T::CLKSEL1
N * Offset: 0x14  Clock Source Select Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Select (Write Protect)
N * |        |          |00 = Reserved.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK/2048 clock.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[3:2]   |ADC_S     |ADC Clock Source Select
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[4]     |SPI0_S    |SPI0 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[5]     |SPI1_S    |SPI1 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[6]     |SPI2_S    |SPI2 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[7]     |SPI3_S    |SPI3 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = reserved.
N * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = reserved.
N * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = reserved.
N * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = reserved.
N * |[25:24] |UART_S    |UART Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[29:28] |PWM01_S   |PWM0 And PWM1 Clock Source Selection
N * |        |          |PWM0 and PWM1 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The Engine clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and
N * |        |          |PWM01_S_E (CLKSEL2[8]).
N * |        |          |If PWM01_S_E = 0, the peripheral clock source of PWM0 and PWM1 defined by PWM01_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM01_S_E = 1, the engine clock source of PWM0 and PWM1 defined by PWM01_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[31:30] |PWM23_S   |PWM2 And PWM3 Clock Source Selection
N * |        |          |PWM2 and PWM3 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The Engine clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and
N * |        |          |PWM23_S_E (CLKSEL2[9]).
N * |        |          |If PWM23_S_E = 0, the peripheral clock source of PWM2 and PWM3 defined by PWM23_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM23_S_E = 1, the engine clock source of PWM2 and PWM3 defined by PWM23_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * @var CLK_T::CLKDIV
N * Offset: 0x18  Clock Divider Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
N * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
N * |[7:4]   |USB_N     |USB Clock Divide Number From PLL Clock
N * |        |          |USB clock frequency = (PLL frequency) / (USB_N + 1).
N * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
N * |        |          |UART clock frequency = (UART clock source frequency) / (UART_N + 1).
N * |[23:16] |ADC_N     |ADC Clock Divide Number From ADC Clock Source
N * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADC_N + 1).
N * @var CLK_T::CLKSEL2
N * Offset: 0x1C  Clock Source Select Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |I2S_S     |I2S Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[5:4]   |PWM45_S   |PWM4 And PWM5 Clock Source Selection
N * |        |          |PWM4 and PWM5 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The peripheral clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and
N * |        |          |PWM45_S_E (CLKSEL2[10]).
N * |        |          |If PWM45_S_E = 0, the peripheral clock source of PWM4 and PWM5 defined by PWM45_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM45_S_E = 1, the engine clock source of PWM4 and PWM5 defined by PWM45_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[7:6]   |PWM67_S   |PWM6 And PWM7 Clock Source Selection
N * |        |          |PWM6 and PWM7 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The peripheral clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and
N * |        |          |PWM67_S_E (CLKSEL2[11]).
N * |        |          |If PWM67_S_E = 0, the peripheral clock source of PWM6 and PWM7 defined by PWM67_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM67_S_E = 1, the engine clock source of PWM6 and PWM7 defined by PWM67_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[8]     |PWM01_S_E |PWM0 And PWM1 Clock Source Selection Extend
N * |        |          |PWM0 and PWM1 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The peripheral clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and
N * |        |          |PWM01_S_E (CLKSEL2[8]).
N * |        |          |If PWM01_S_E = 0, the peripheral clock source of PWM0 and PWM1 defined by PWM01_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM01_S_E = 1, the peripheral clock source of PWM0 and PWM1 defined by PWM01_S list
N * |        |          |below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[9]     |PWM23_S_E |PWM2 And PWM3 Clock Source Selection Extend
N * |        |          |PWM2 and PWM3 used the same Engine clock source; both of them used the same prescaler.
N * |        |          |The Engine clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and
N * |        |          |PWM23_S_E (CLKSEL2[9]).
N * |        |          |If PWM23_S_E = 0, the peripheral clock source of PWM2 and PWM3 defined by PWM23_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM23_S_E = 1, the peripheral clock source of PWM2 and PWM3 defined by PWM23_S list
N * |        |          |below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[10]    |PWM45_S_E |PWM4 And PWM5 Clock Source Selection Extend
N * |        |          |PWM4 and PWM5 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The peripheral clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and
N * |        |          |PWM45_S_E (CLKSEL2[10]).
N * |        |          |If PWM45_S_E = 0, the peripheral clock source of PWM4 and PWM5 defined by PWM45_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM45_S_E = 1, the peripheral clock source of PWM4 and PWM5 defined by PWM45_S list
N * |        |          |below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[11]    |PWM67_S_E |PWM6 And PWM7 Clock Source Selection Extend
N * |        |          |PWM6 and PWM7 used the same peripheral clock source; both of them used the same prescaler.
N * |        |          |The peripheral clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and
N * |        |          |PWM67_S_E (CLKSEL2[11]).
N * |        |          |If PWM67_S_E = 0, the peripheral clock source of PWM6 and PWM7 defined by PWM67_S list
N * |        |          |below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM67_S_E = 1, the engine clock source of PWM6 and PWM7 defined by PWM67_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
N * |        |          |10 = Clock source from HCLK/2048 clock.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[18]    |RTC_SEL_10K|RTC Clock Source Selection
N * |        |          |0 = External XTL32K.
N * |        |          |1 = Internal IRC 10K.
N * @var CLK_T::PLLCON
N * Offset: 0x20  PLL Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
N * |        |          |Refer to the formulas below the table.
N * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
N * |        |          |Refer to the formulas below the table.
N * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
N * |        |          |Refer to the formulas below the table.
N * |[16]    |PD        |Power-Down Mode
N * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode
N * |        |          |too.
N * |        |          |0 = PLL is in Normal mode.
N * |        |          |1 = PLL is in Power-down mode (default).
N * |[17]    |BP        |PLL Bypass Control
N * |        |          |0 = PLL is in Normal mode (default).
N * |        |          |1 = PLL clock output is same as PLL source clock input.
N * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control
N * |        |          |0 = PLL FOUT Enabled.
N * |        |          |1 = PLL FOUT is fixed low.
N * |[19]    |PLL_SRC   |PLL Source Clock Selection
N * |        |          |0 = PLL source clock from external 4~24 MHz high speed crystal.
N * |        |          |1 = PLL source clock from internal 22.1184 MHz high speed oscillator.
N * |[20]    |FCO_SEL   |PLL FCO Selection
N * |        |          |0 = When the FCO frequency range between 100MHz and 200MHz, this bit should be set as 0.
N * |        |          |1 = When the FCO frequency range between 200MHz to 500MHz, this bit should be set as 1.
N * @var CLK_T::FRQDIV
N * Offset: 0x24  Frequency Divider Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N * |        |          |The formula of output frequency is
N * |        |          |Fout
N * |        |          |= Fin/2(N+1).
N * |        |          |Fin is the input clock frequency.
N * |        |          |Fout is the frequency of divider output clock.
N * |        |          |N is the 4-bit value of FSEL[3:0].
N * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
N * |        |          |0 = Frequency Divider function Disabled.
N * |        |          |1 = Frequency Divider function Enabled.
N * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
N * |        |          |0 = Frequency divider will output clock with source frequency divided by FSEL.
N * |        |          |1 = Frequency divider will output clock with source frequency.
N * |[6]     |CLKO_1HZ_EN|Clock Output 1Hz Enable Bit
N * |        |          |0 = 1 Hz clock output for 32K frequency compensation Disabled.
N * |        |          |1 = 1 Hz clock output for 32K frequency compensation Enabled.
N * @var CLK_T::APBCLK1
N * Offset: 0x30  APB Devices Clock Enable Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC0_EN    |SC0 Clock Enable Control
N * |        |          |0 = SC0 Clock Disabled.
N * |        |          |1 = SC0 Clock Enabled.
N * |[1]     |SC1_EN    |SC1 Clock Enable Control
N * |        |          |0 = SC1 clock Disabled.
N * |        |          |1 = SC1 clock Enabled.
N * |[2]     |SC2_EN    |SC2 Clock Enable Control
N * |        |          |0 = SC2 clock Disabled.
N * |        |          |1 = SC2 clock Enabled.
N * @var CLK_T::CLKSEL3
N * Offset: 0x34  Clock Source Select Control Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |SC0_S     |SC0 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[3:2]   |SC1_S     |SC1 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[5:4]   |SC2_S     |SC2 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * @var CLK_T::CLKDIV1
N * Offset: 0x38  Clock Divider Number Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |SC0_N     |SC0 Clock Divide Number From SC0 Clock Source
N * |        |          |The SC0 clock frequency = (SC0 clock source frequency) / (SC0_N + 1).
N * |[15:8]  |SC1_N     |SC1 Clock Divide Number From SC1 Clock Source
N * |        |          |The SC1 clock frequency = (SC1 clock source frequency) / (SC1_N + 1).
N * |[23:16] |SC2_N     |SC2 Clock Divide Number From SC2 Clock Source
N * |        |          |The SC2 clock frequency = (SC2 clock source frequency) / (SC2_N + 1).
N */
N
N    __IO uint32_t PWRCON;        /* Offset: 0x00  System Power-down Control Register                                 */
X    volatile uint32_t PWRCON;         
N    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
X    volatile uint32_t AHBCLK;         
N    __IO uint32_t APBCLK;        /* Offset: 0x08  APB Devices Clock Enable Control Register                          */
X    volatile uint32_t APBCLK;         
N    __IO uint32_t CLKSTATUS;     /* Offset: 0x0C  Clock status monitor Register                                      */
X    volatile uint32_t CLKSTATUS;      
N    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
X    volatile uint32_t CLKSEL0;        
N    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
X    volatile uint32_t CLKSEL1;        
N    __IO uint32_t CLKDIV;        /* Offset: 0x18  Clock Divider Number Register                                      */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t CLKSEL2;       /* Offset: 0x1C  Clock Source Select Control Register 2                             */
X    volatile uint32_t CLKSEL2;        
N    __IO uint32_t PLLCON;        /* Offset: 0x20  PLL Control Register                                               */
X    volatile uint32_t PLLCON;         
N    __IO uint32_t FRQDIV;        /* Offset: 0x24  Frequency Divider Control Register                                 */
X    volatile uint32_t FRQDIV;         
N    __IO uint32_t RESERVE[2];   
X    volatile uint32_t RESERVE[2];   
N    __IO uint32_t APBCLK1;       /* Offset: 0x30  APB Devices Clock Enable Control Register 1                        */
X    volatile uint32_t APBCLK1;        
N    __IO uint32_t CLKSEL3;       /* Offset: 0x34  Clock Source Select Control Register 3                             */
X    volatile uint32_t CLKSEL3;        
N    __IO uint32_t CLKDIV1;       /* Offset: 0x38  Clock Divider Number Register 1                                    */
X    volatile uint32_t CLKDIV1;        
N
N} CLK_T;
N
N
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N/* CLK PWRCON Bit Field Definitions */
N#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
N#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
N
N#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
N#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
N
N#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
N#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
N
N#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
N#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
N
N#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
N#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
N
N#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
N#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
N#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: IRC10K_EN Position */
N#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_IRC10K_EN_Pos)    /*!< CLK_T::PWRCON: IRC10K_EN Mask */
N
N#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
N#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
N#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: IRC22M_EN Position */
N#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_IRC22M_EN_Pos)    /*!< CLK_T::PWRCON: IRC22M_EN Mask */
N
N#define CLK_PWRCON_XTL32K_EN_Pos             1                                    /*!< CLK_T::PWRCON: XTL32K_EN Position */
N#define CLK_PWRCON_XTL32K_EN_Msk             (1ul << CLK_PWRCON_XTL32K_EN_Pos)    /*!< CLK_T::PWRCON: XTL32K_EN Mask */
N
N#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
N#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
N
N/* CLK AHBCLK Bit Field Definitions */
N#define CLK_AHBCLK_EBI_EN_Pos                3                                    /*!< CLK_T::AHBCLK: EBI_EN Position */
N#define CLK_AHBCLK_EBI_EN_Msk                (1ul << CLK_AHBCLK_EBI_EN_Pos)       /*!< CLK_T::AHBCLK: EBI_EN Mask */
N
N#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
N#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
N
N#define CLK_AHBCLK_PDMA_EN_Pos               1                                    /*!< CLK_T::AHBCLK: PDMA_EN Position */
N#define CLK_AHBCLK_PDMA_EN_Msk               (1ul << CLK_AHBCLK_PDMA_EN_Pos)      /*!< CLK_T::AHBCLK: PDMA_EN Mask */
N
N
N/* CLK APBCLK Bit Field Definitions */
N#define CLK_APBCLK_PS2_EN_Pos                31                                   /*!< CLK_T::APBCLK: PS2_EN Position */
N#define CLK_APBCLK_PS2_EN_Msk                (1ul << CLK_APBCLK_PS2_EN_Pos)       /*!< CLK_T::APBCLK: PS2_EN Mask */
N
N#define CLK_APBCLK_ACMP_EN_Pos               30                                   /*!< CLK_T::APBCLK: ACMP_EN Position */
N#define CLK_APBCLK_ACMP_EN_Msk               (1ul << CLK_APBCLK_ACMP_EN_Pos)      /*!< CLK_T::APBCLK: ACMP_EN Mask */
N
N#define CLK_APBCLK_I2S_EN_Pos                29                                   /*!< CLK_T::APBCLK: I2S_EN Position */
N#define CLK_APBCLK_I2S_EN_Msk                (1ul << CLK_APBCLK_I2S_EN_Pos)       /*!< CLK_T::APBCLK: I2S_EN Mask */
N
N#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
N#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
N
N#define CLK_APBCLK_USBD_EN_Pos               27                                   /*!< CLK_T::APBCLK: USBD_EN Position */
N#define CLK_APBCLK_USBD_EN_Msk               (1ul << CLK_APBCLK_USBD_EN_Pos)      /*!< CLK_T::APBCLK: USBD_EN Mask */
N
N#define CLK_APBCLK_PWM67_EN_Pos              23                                   /*!< CLK_T::APBCLK: PWM67_EN Position */
N#define CLK_APBCLK_PWM67_EN_Msk              (1ul << CLK_APBCLK_PWM67_EN_Pos)     /*!< CLK_T::APBCLK: PWM67_EN Mask */
N
N#define CLK_APBCLK_PWM45_EN_Pos              22                                   /*!< CLK_T::APBCLK: PWM45_EN Position */
N#define CLK_APBCLK_PWM45_EN_Msk              (1ul << CLK_APBCLK_PWM45_EN_Pos)     /*!< CLK_T::APBCLK: PWM45_EN Mask */
N
N#define CLK_APBCLK_PWM23_EN_Pos              21                                   /*!< CLK_T::APBCLK: PWM23_EN Position */
N#define CLK_APBCLK_PWM23_EN_Msk              (1ul << CLK_APBCLK_PWM23_EN_Pos)     /*!< CLK_T::APBCLK: PWM23_EN Mask */
N
N#define CLK_APBCLK_PWM01_EN_Pos              20                                   /*!< CLK_T::APBCLK: PWM01_EN Position */
N#define CLK_APBCLK_PWM01_EN_Msk              (1ul << CLK_APBCLK_PWM01_EN_Pos)     /*!< CLK_T::APBCLK: PWM01_EN Mask */
N
N#define CLK_APBCLK_UART2_EN_Pos              18                                   /*!< CLK_T::APBCLK: UART2_EN Position */
N#define CLK_APBCLK_UART2_EN_Msk              (1ul << CLK_APBCLK_UART2_EN_Pos)     /*!< CLK_T::APBCLK: UART2_EN Mask */
N
N#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
N#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
N
N#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
N#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
N
N#define CLK_APBCLK_SPI3_EN_Pos               15                                   /*!< CLK_T::APBCLK: SPI3_EN Position */
N#define CLK_APBCLK_SPI3_EN_Msk               (1ul << CLK_APBCLK_SPI3_EN_Pos)      /*!< CLK_T::APBCLK: SPI3_EN Mask */
N
N#define CLK_APBCLK_SPI2_EN_Pos               14                                   /*!< CLK_T::APBCLK: SPI2_EN Position */
N#define CLK_APBCLK_SPI2_EN_Msk               (1ul << CLK_APBCLK_SPI2_EN_Pos)      /*!< CLK_T::APBCLK: SPI2_EN Mask */
N
N#define CLK_APBCLK_SPI1_EN_Pos               13                                   /*!< CLK_T::APBCLK: SPI1_EN Position */
N#define CLK_APBCLK_SPI1_EN_Msk               (1ul << CLK_APBCLK_SPI1_EN_Pos)      /*!< CLK_T::APBCLK: SPI1_EN Mask */
N
N#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
N#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
N
N#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
N#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
N
N#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN_ Position */
N#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN_ Mask */
N
N#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
N#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
N
N#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
N#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
N
N#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
N#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
N
N#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
N#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
N
N#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
N#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
N
N#define CLK_APBCLK_RTC_EN_Pos                1                                    /*!< CLK_T::APBCLK: RTC_EN Position */
N#define CLK_APBCLK_RTC_EN_Msk                (1ul << CLK_APBCLK_RTC_EN_Pos)       /*!< CLK_T::APBCLK: RTC_EN Mask */
N
N#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
N#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
N
N/* CLK APBCLK1 Bit Field Definitions */
N#define CLK_APBCLK1_SC2_EN_Pos                2                                   /*!< CLK_T::APBCLK1: SC2_EN Position */
N#define CLK_APBCLK1_SC2_EN_Msk                (1ul << CLK_APBCLK1_SC2_EN_Pos)     /*!< CLK_T::APBCLK1: SC2_EN Mask */
N
N#define CLK_APBCLK1_SC1_EN_Pos                1                                   /*!< CLK_T::APBCLK1: SC1_EN Position */
N#define CLK_APBCLK1_SC1_EN_Msk                (1ul << CLK_APBCLK1_SC1_EN_Pos)     /*!< CLK_T::APBCLK1: SC1_EN Mask */
N
N#define CLK_APBCLK1_SC0_EN_Pos                0                                   /*!< CLK_T::APBCLK1: SC0_EN Position */
N#define CLK_APBCLK1_SC0_EN_Msk                (1ul << CLK_APBCLK1_SC0_EN_Pos)     /*!< CLK_T::APBCLK1: SC0_EN Mask */
N
N/* CLK CLKSTATUS Bit Field Definitions */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                        /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
N
N#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
N#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
N#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
N#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
N
N#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
N#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
N#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
N#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
N
N#define CLK_CLKSTATUS_PLL_STB_Pos            2                                        /*!< CLK_T::CLKSTATUS: PLL_STB Position */
N#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)       /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
N
N#define CLK_CLKSTATUS_XTL32K_STB_Pos         1                                        /*!< CLK_T::CLKSTATUS: XTL32K_STB Position */
N#define CLK_CLKSTATUS_XTL32K_STB_Msk         (1ul << CLK_CLKSTATUS_XTL32K_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL32K_STB Mask */
N
N#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                        /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
N#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
N
N/* CLK CLKSEL0 Bit Field Definitions */
N#define CLK_CLKSEL0_STCLK_S_Pos              3                                        /*!< CLK_T::CLKSEL0: STCLK_S Position */
N#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)         /*!< CLK_T::CLKSEL0: STCLK_S Mask */
N
N#define CLK_CLKSEL0_HCLK_S_Pos               0                                        /*!< CLK_T::CLKSEL0: HCLK_S Position */
N#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)          /*!< CLK_T::CLKSEL0: HCLK_S Mask */
N
N/* CLK CLKSEL1 Bit Field Definitions */
N#define CLK_CLKSEL1_PWM23_S_Pos              30                                       /*!< CLK_T::CLKSEL1: PWM23_S Position */
N#define CLK_CLKSEL1_PWM23_S_Msk              (3ul << CLK_CLKSEL1_PWM23_S_Pos)         /*!< CLK_T::CLKSEL1: PWM23_S Mask */
N
N#define CLK_CLKSEL1_PWM01_S_Pos              28                                       /*!< CLK_T::CLKSEL1: PWM01_S Position */
N#define CLK_CLKSEL1_PWM01_S_Msk              (3ul << CLK_CLKSEL1_PWM01_S_Pos)         /*!< CLK_T::CLKSEL1: PWM01_S Mask */
N
N#define CLK_CLKSEL1_UART_S_Pos               24                                       /*!< CLK_T::CLKSEL1: UART_S Position */
N#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)          /*!< CLK_T::CLKSEL1: UART_S Mask */
N
N#define CLK_CLKSEL1_TMR3_S_Pos               20                                       /*!< CLK_T::CLKSEL1: TMR3_S Position */
N#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)          /*!< CLK_T::CLKSEL1: TMR3_S Mask */
N
N#define CLK_CLKSEL1_TMR2_S_Pos               16                                       /*!< CLK_T::CLKSEL1: TMR2_S Position */
N#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)          /*!< CLK_T::CLKSEL1: TMR2_S Mask */
N
N#define CLK_CLKSEL1_TMR1_S_Pos               12                                       /*!< CLK_T::CLKSEL1: TMR1_S Position */
N#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)          /*!< CLK_T::CLKSEL1: TMR1_S Mask */
N
N#define CLK_CLKSEL1_TMR0_S_Pos               8                                        /*!< CLK_T::CLKSEL1: TMR0_S Position */
N#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)          /*!< CLK_T::CLKSEL1: TMR0_S Mask */
N
N#define CLK_CLKSEL1_SPI3_S_Pos               7                                        /*!< CLK_T::CLKSEL1: SPI3_S Position */
N#define CLK_CLKSEL1_SPI3_S_Msk               (1ul << CLK_CLKSEL1_SPI3_S_Pos)          /*!< CLK_T::CLKSEL1: SPI3_S Mask */
N
N#define CLK_CLKSEL1_SPI2_S_Pos               6                                        /*!< CLK_T::CLKSEL1: SPI2_S Position */
N#define CLK_CLKSEL1_SPI2_S_Msk               (1ul << CLK_CLKSEL1_SPI2_S_Pos)          /*!< CLK_T::CLKSEL1: SPI2_S Mask */
N
N#define CLK_CLKSEL1_SPI1_S_Pos               5                                        /*!< CLK_T::CLKSEL1: SPI1_S Position */
N#define CLK_CLKSEL1_SPI1_S_Msk               (1ul << CLK_CLKSEL1_SPI1_S_Pos)          /*!< CLK_T::CLKSEL1: SPI1_S Mask */
N
N#define CLK_CLKSEL1_SPI0_S_Pos               4                                        /*!< CLK_T::CLKSEL1: SPI0_S Position */
N#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)          /*!< CLK_T::CLKSEL1: SPI0_S Mask */
N
N#define CLK_CLKSEL1_ADC_S_Pos                2                                        /*!< CLK_T::CLKSEL1: ADC_S Position */
N#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)           /*!< CLK_T::CLKSEL1: ADC_S Mask */
N
N#define CLK_CLKSEL1_WDT_S_Pos                0                                        /*!< CLK_T::CLKSEL1: WDT_S Position */
N#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)           /*!< CLK_T::CLKSEL1: WDT_S Mask */
N
N/* CLK CLKSEL2 Bit Field Definitions */
N#define CLK_CLKSEL2_RTC_SEL_10K_Pos          18                                       /*!< CLK_T::CLKSEL2: RTC_SEL_10K Position */
N#define CLK_CLKSEL2_RTC_SEL_10K_Msk          (1ul << CLK_CLKSEL2_RTC_SEL_10K_Pos)     /*!< CLK_T::CLKSEL2: RTC_SEL_10K Mask */
N
N#define CLK_CLKSEL2_WWDT_S_Pos               16                                       /*!< CLK_T::CLKSEL2: WWDT_S Position */
N#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)          /*!< CLK_T::CLKSEL2: WWDT_S Mask */
N
N#define CLK_CLKSEL2_PWM67_S_E_Pos            11                                       /*!< CLK_T::CLKSEL2: PWM67_S_E Position */
N#define CLK_CLKSEL2_PWM67_S_E_Msk            (1ul << CLK_CLKSEL2_PWM67_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM67_S_E Mask */
N#define CLK_CLKSEL2_PWM67_S_EXT_Pos          11                                       /*!< CLK_T::CLKSEL2: PWM67_S_E Position */
N#define CLK_CLKSEL2_PWM67_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM67_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM67_S_E Mask */
N
N#define CLK_CLKSEL2_PWM45_S_E_Pos            10                                       /*!< CLK_T::CLKSEL2: PWM45_S_E Position */
N#define CLK_CLKSEL2_PWM45_S_E_Msk            (1ul << CLK_CLKSEL2_PWM45_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM45_S_E Mask */
N#define CLK_CLKSEL2_PWM45_S_EXT_Pos          10                                       /*!< CLK_T::CLKSEL2: PWM45_S_EXT Position */
N#define CLK_CLKSEL2_PWM45_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM45_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM45_S_EXT Mask */
N
N#define CLK_CLKSEL2_PWM23_S_E_Pos            9                                        /*!< CLK_T::CLKSEL2: PWM23_S_E Position */
N#define CLK_CLKSEL2_PWM23_S_E_Msk            (1ul << CLK_CLKSEL2_PWM23_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM23_S_E Mask */
N#define CLK_CLKSEL2_PWM23_S_EXT_Pos          9                                        /*!< CLK_T::CLKSEL2: PWM23_S_EXT Position */
N#define CLK_CLKSEL2_PWM23_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM23_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM23_S_EXT Mask */
N
N#define CLK_CLKSEL2_PWM01_S_E_Pos            8                                        /*!< CLK_T::CLKSEL2: PWM01_S_E Position */
N#define CLK_CLKSEL2_PWM01_S_E_Msk            (1ul << CLK_CLKSEL2_PWM01_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM01_S_E Mask */
N#define CLK_CLKSEL2_PWM01_S_EXT_Pos          8                                        /*!< CLK_T::CLKSEL2: PWM01_S_EXT Position */
N#define CLK_CLKSEL2_PWM01_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM01_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM01_S_EXT Mask */
N
N#define CLK_CLKSEL2_PWM67_S_Pos              6                                        /*!< CLK_T::CLKSEL2: PWM67_S_ Position */
N#define CLK_CLKSEL2_PWM67_S_Msk              (3ul << CLK_CLKSEL2_PWM67_S_Pos)         /*!< CLK_T::CLKSEL2: PWM67_S_ Mask */
N
N#define CLK_CLKSEL2_PWM45_S_Pos              4                                        /*!< CLK_T::CLKSEL2: PWM45_S Position */
N#define CLK_CLKSEL2_PWM45_S_Msk              (3ul << CLK_CLKSEL2_PWM45_S_Pos)         /*!< CLK_T::CLKSEL2: PWM45_S Mask */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                        /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
N#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)        /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
N
N#define CLK_CLKSEL2_I2S_S_Pos                0                                        /*!< CLK_T::CLKSEL2: I2S_S Position */
N#define CLK_CLKSEL2_I2S_S_Msk                (3ul << CLK_CLKSEL2_I2S_S_Pos)           /*!< CLK_T::CLKSEL2: I2S_S Mask */
N
N/* CLK CLKSEL3 Bit Field Definitions */
N#define CLK_CLKSEL3_SC2_S_Pos                4                                        /*!< CLK_T::CLKSEL3: SC2_S Position */
N#define CLK_CLKSEL3_SC2_S_Msk                (3ul << CLK_CLKSEL3_SC2_S_Pos)           /*!< CLK_T::CLKSEL3: SC2_S Mask */
N
N#define CLK_CLKSEL3_SC1_S_Pos                2                                        /*!< CLK_T::CLKSEL3: SC1_S Position */
N#define CLK_CLKSEL3_SC1_S_Msk                (3ul << CLK_CLKSEL3_SC1_S_Pos)           /*!< CLK_T::CLKSEL3: SC1_S Mask */
N
N#define CLK_CLKSEL3_SC0_S_Pos                0                                        /*!< CLK_T::CLKSEL3: SC0_S Position */
N#define CLK_CLKSEL3_SC0_S_Msk                (3ul << CLK_CLKSEL3_SC0_S_Pos)           /*!< CLK_T::CLKSEL3: SC0_S Mask */
N
N/* CLK CLKDIV Bit Field Definitions */
N#define CLK_CLKDIV_ADC_N_Pos                 16                                       /*!< CLK_T::CLKDIV: ADC_N Position */
N#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)         /*!< CLK_T::CLKDIV: ADC_N Mask */
N
N#define CLK_CLKDIV_UART_N_Pos                8                                        /*!< CLK_T::CLKDIV: UART_N Position */
N#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)         /*!< CLK_T::CLKDIV: UART_N Mask */
N
N#define CLK_CLKDIV_USB_N_Pos                 4                                        /*!< CLK_T::CLKDIV: USB_N Position */
N#define CLK_CLKDIV_USB_N_Msk                 (0xFul << CLK_CLKDIV_USB_N_Pos)          /*!< CLK_T::CLKDIV: USB_N Mask */
N
N#define CLK_CLKDIV_HCLK_N_Pos                0                                        /*!< CLK_T::CLKDIV: HCLK_N Position */
N#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)         /*!< CLK_T::CLKDIV: HCLK_N Mask */
N
N/* CLK CLKDIV1 Bit Field Definitions */
N#define CLK_CLKDIV1_SC2_N_Pos                16                                       /*!< CLK_T::CLKDIV: SC2_N Position */
N#define CLK_CLKDIV1_SC2_N_Msk                (0xFFul << CLK_CLKDIV1_SC2_N_Pos)        /*!< CLK_T::CLKDIV: SC2_N Mask */
N
N#define CLK_CLKDIV1_SC1_N_Pos                8                                        /*!< CLK_T::CLKDIV: SC1_N Position */
N#define CLK_CLKDIV1_SC1_N_Msk                (0xFFul << CLK_CLKDIV1_SC1_N_Pos)        /*!< CLK_T::CLKDIV: SC1_N Mask */
N
N#define CLK_CLKDIV1_SC0_N_Pos                0                                        /*!< CLK_T::CLKDIV: SC0_N Position */
N#define CLK_CLKDIV1_SC0_N_Msk                (0xFFul << CLK_CLKDIV1_SC0_N_Pos)        /*!< CLK_T::CLKDIV: SC0_N Mask */
N
N/* CLK PLLCON Bit Field Definitions */
N#define CLK_PLLCON_PLL_SRC_Pos               19                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)          /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_OE_Pos                    18                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)               /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_BP_Pos                    17                                       /*!< CLK_T::PLLCON: OE Position */
N#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)               /*!< CLK_T::PLLCON: OE Mask */
N
N#define CLK_PLLCON_PD_Pos                    16                                       /*!< CLK_T::PLLCON: PD Position */
N#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)               /*!< CLK_T::PLLCON: PD Mask */
N
N#define CLK_PLLCON_OUT_DV_Pos                14                                       /*!< CLK_T::PLLCON: OUT_DV Position */
N#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)           /*!< CLK_T::PLLCON: OUT_DV Mask */
N
N#define CLK_PLLCON_IN_DV_Pos                 9                                        /*!< CLK_T::PLLCON: IN_DV Position */
N#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)         /*!< CLK_T::PLLCON: IN_DV Mask */
N
N#define CLK_PLLCON_FB_DV_Pos                 0                                        /*!< CLK_T::PLLCON: FB_DV Position */
N#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)        /*!< CLK_T::PLLCON: FB_DV Mask */
N
N/* CLK FRQDIV Bit Field Definitions */
N#define CLK_FRQDIV_CLKO_1HZ_EN_Pos           6                                        /*!< CLK_T::FRQDIV: CLKO_1HZ_EN Position */
N#define CLK_FRQDIV_CLKO_1HZ_EN_Msk           (1ul << CLK_FRQDIV_CLKO_1HZ_EN_Pos)      /*!< CLK_T::FRQDIV: CLKO_1HZ_EN Mask */
N
N#define CLK_FRQDIV_DIVIDER1_Pos              5                                        /*!< CLK_T::FRQDIV: DIVIDER1 Position */
N#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)         /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
N
N#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                        /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
N#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)       /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
N
N#define CLK_FRQDIV_FSEL_Pos                  0                                        /*!< CLK_T::FRQDIV: FRQDIV_FSEL Position */
N#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)           /*!< CLK_T::FRQDIV: FRQDIV_FSEL Mask */
N
N/*@}*/ /* end of group CLK_CONST */
N/*@}*/ /* end of group CLK */
N
N
N
N/*----------------------------- Cyclic Redundancy Check (CRC) Controller -----------------------------*/
N/** @addtogroup CRC Cyclic Redundancy Check Controller (CRC)
N  Memory Mapped Structure for Cyclic Redundancy Check
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var CRC_T::CTL
N * Offset: 0x00  CRC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRCCEN    |CRC Channel Enable
N * |        |          |0 = No effect.
N * |        |          |1 = CRC operation Enabled.
N * |        |          |Note1: When operating in CRC DMA mode (TRIG_EN (CRC_CTL[23]) = 1), if user clears this bit,
N * |        |          |the DMA operation will be continuous until all CRC DMA operation is done, and the TRIG_EN
N * |        |          |(CRC_CTL[23]) bit will keep 1until all CRC DMA operation done.
N * |        |          |But in this case, the CRC_BLKD_IF (CRC_DMAISR[1])flag will inactive, user can read CRC
N * |        |          |checksum result only if TRIG_EN (CRC_CTL[23]) clears to 0.
N * |        |          |Note2: When operating in CRC DMA mode (TRIG_EN (CRC_CTL[23]) = 1), if user wants to stop the
N * |        |          |transfer immediately, user can write 1 to CRC_RST (CRC_CTL [1]) bit to stop the
N * |        |          |transmission.
N * |[1]     |CRC_RST   |CRC Engine Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal CRC state machine and internal buffer.
N * |        |          |The others contents of CRC_CTL register will not be cleared.
N * |        |          |This bit will be cleared automatically.
N * |        |          |Note: When operated in CPU PIO mode, setting this bit will reload the initial seed value
N * |        |          |(CRC_SEED register).
N * |[23]    |TRIG_EN   |Trigger Enable
N * |        |          |This bit is used to trigger the CRC DMA transfer.
N * |        |          |0 = No effect.
N * |        |          |1 = CRC DMA data read or write transfer Enabled.
N * |        |          |Note1: If this bit asserts which indicates the CRC engine operation in CRC DMA mode, do not
N * |        |          |fill in any data in CRC_WDATA register.
N * |        |          |Note2: When CRC DMA transfer completed, this bit will be cleared automatically.
N * |        |          |Note3: If the bus error occurs when CRC DMA transfer data, all CRC DMA transfer will be
N * |        |          |stopped.
N * |        |          |Software must reset all DMA channel before trigger DMA again.
N * |[24]    |WDATA_RVS |Write Data Order Reverse
N * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_WDATA
N * |        |          |register.
N * |        |          |0 = Bit order reverse for CRC write data in Disabled.
N * |        |          |1 = Bit order reverse for CRC write data in Enabled (per byre).
N * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is
N * |        |          |0x55DD33BB
N * |[25]    |CHECKSUM_RVS|Checksum Reverse
N * |        |          |This bit is used to enable the bit order reverse function for write data value in
N * |        |          |CRC_CHECKSUM register.
N * |        |          |0 = Bit order reverse for CRC checksum Disabled.
N * |        |          |1 = Bit order reverse for CRC checksum Enabled.
N * |        |          |Note: If the checksum result is 0XDD7B0F2E, the bit order reverse for CRC checksum is
N * |        |          |0x74F0DEBB
N * |[26]    |WDATA_COM |Write Data 1's Complement
N * |        |          |This bit is used to enable the 1's complement function for write data value in CRC_WDATA
N * |        |          |register.
N * |        |          |0 = 1's complement for CRC write data in Disabled.
N * |        |          |1 = 1's complement for CRC write data in Enabled.
N * |[27]    |CHECKSUM_COM|Checksum 1's Complement
N * |        |          |This bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM
N * |        |          |register.
N * |        |          |0 = 1's complement for CRC checksum Disabled.
N * |        |          |1 = 1's complement for CRC checksum Enabled.
N * |[29:28] |CPU_WDLEN |CPU Write Data Length
N * |        |          |This field indicates the CPU write data length only when operating in CPU PIO mode.
N * |        |          |00 = The write data length is 8-bit mode.
N * |        |          |01 = The write data length is 16-bit mode.
N * |        |          |10 = The write data length is 32-bit mode.
N * |        |          |11 = Reserved.
N * |        |          |Note1: This field is only valid when operating in CPU PIO mode.
N * |        |          |Note2: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is
N * |        |          |only CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in
N * |        |          |CRC_WDATA register is only CRC_WDATA [15:0].
N * |[31:30] |CRC_MODE  |CRC Polynomial Mode
N * |        |          |This field indicates the CRC operation polynomial mode.
N * |        |          |00 = CRC-CCITT Polynomial Mode.
N * |        |          |01 = CRC-8 Polynomial Mode.
N * |        |          |10 = CRC-16 Polynomial Mode.
N * |        |          |11 = CRC-32 Polynomial Mode.
N * @var CRC_T::DMASAR
N * Offset: 0x04  CRC DMA Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_DMASAR|CRC DMA Transfer Source Address Register
N * |        |          |This field indicates a 32-bit source address of CRC DMA.
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * |        |          |Note: The source address must be word alignment
N * @var CRC_T::DMABCR
N * Offset: 0x0C  CRC DMA Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRC_DMABCR|CRC DMA Transfer Byte Count Register
N * |        |          |This field indicates a 16-bit total transfer byte count number of CRC DMA
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * @var CRC_T::DMACSAR
N * Offset: 0x14  CRC DMA Current Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_DMACSAR|CRC DMA Current Source Address Register (Read Only)
N * |        |          |This field indicates the current source address where the CRC DMA transfer just occurs.
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * @var CRC_T::DMACBCR
N * Offset: 0x1C  CRC DMA Current Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRC_DMACBCR|CRC DMA Current Remained Byte Count Register (Read Only)
N * |        |          |This field indicates the current remained byte count of CRC DMA.
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * |        |          |Note: Setting CRC_RST (CRC_CTL[1]) bit to 1 will clear this register value.
N * @var CRC_T::DMAIER
N * Offset: 0x20  CRC DMA Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRC_TABORT_IE|CRC DMA Read/Write Target Abort Interrupt Enable
N * |        |          |Enable this bit will generate the CRC DMA Target Abort interrupt signal while CRC_TARBOT_IF
N * |        |          |(CRC_DMAISR[0]) bit is set to 1.
N * |        |          |0 = Target abort interrupt generation Disabled during CRC DMA transfer.
N * |        |          |1 = Target abort interrupt generation Enabled during CRC DMA transfer.
N * |[1]     |CRC_BLKD_IE|CRC DMA Block Transfer Done Interrupt Enable
N * |        |          |Enable this bit will generate the CRC DMA Transfer Done interrupt signal while CRC_BLKD_IF
N * |        |          |(CRC_DMAISR[1]) bit is set to 1.
N * |        |          |0 = Interrupt generator Disabled when CRC DMA transfer done.
N * |        |          |1 = Interrupt generator Enabled when CRC DMA transfer done.
N * @var CRC_T::DMAISR
N * Offset: 0x24  CRC DMA Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRC_TABORT_IF|CRC DMA Read/Write Target Abort Interrupt Flag
N * |        |          |This bit indicates that CRC bus has error or not during CRC DMA transfer.
N * |        |          |0 = No bus error response received during CRC DMA transfer.
N * |        |          |1 = Bus error response received during CRC DMA transfer.
N * |        |          |It is cleared by writing 1 to it through software.
N * |        |          |Note: The bit filed indicate bus master received error response or not.
N * |        |          |If bus master received error response, it means that CRC transfer target abort is happened.
N * |        |          |DMA will stop transfer and respond this event to software then CRC state machine goes to
N * |        |          |IDLE state.
N * |        |          |When target abort occurred, software must reset DMA before transfer those data again.
N * |[1]     |CRC_BLKD_IF|CRC DMA Block Transfer Done Interrupt Flag
N * |        |          |This bit indicates that CRC DMA transfer has finished or not.
N * |        |          |0 = Not finished if TRIG_EN (CRC_CTL[23]) bit has enabled.
N * |        |          |1 = CRC transfer done if TRIG_EN (CRC_CTL[23]) bit has enabled.
N * |        |          |It is cleared by writing 1 to it through software.
N * |        |          |(When CRC DMA transfer done, TRIG_EN (CRC_CTL[23]) bit will be cleared automatically)
N * @var CRC_T::WDATA
N * Offset: 0x80  CRC Write Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_WDATA |CRC Write Data Register
N * |        |          |When operating in CPU PIO mode, software can write data to this field to perform CRC
N * |        |          |operation.
N * |        |          |When operating in DMA mode, this field indicates the DMA read data from memory and cannot be
N * |        |          |written.
N * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only
N * |        |          |CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA
N * |        |          |register is only CRC_WDATA [15:0].
N * @var CRC_T::SEED
N * Offset: 0x84  CRC Seed Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_SEED  |CRC Seed Register
N * |        |          |This field indicates the CRC seed value.
N * @var CRC_T::CHECKSUM
N * Offset: 0x88  CRC Checksum Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_CHECKSUM|CRC Checksum Register
N * |        |          |This fields indicates the CRC checksum result
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  CRC Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t DMASAR;        /* Offset: 0x04  CRC DMA Source Address Register                                    */
X    volatile uint32_t DMASAR;         
N    __I  uint32_t RESERVED0;    
X    volatile const  uint32_t RESERVED0;    
N    __IO uint32_t DMABCR ;       /* Offset: 0x0C  CRC DMA Transfer Byte Count Register                               */
X    volatile uint32_t DMABCR ;        
N    __I  uint32_t RESERVED1;    
X    volatile const  uint32_t RESERVED1;    
N    __I  uint32_t DMACSAR;       /* Offset: 0x14  CRC DMA Current Source Address Register                            */
X    volatile const  uint32_t DMACSAR;        
N    __I  uint32_t RESERVED2;    
X    volatile const  uint32_t RESERVED2;    
N    __I  uint32_t DMACBCR;       /* Offset: 0x1C  CRC DMA Current Transfer Byte Count Register                       */
X    volatile const  uint32_t DMACBCR;        
N    __IO uint32_t DMAIER ;       /* Offset: 0x20  CRC DMA Interrupt Enable Register                                  */
X    volatile uint32_t DMAIER ;        
N    __IO uint32_t DMAISR;        /* Offset: 0x24  CRC DMA Interrupt Status Register                                  */
X    volatile uint32_t DMAISR;         
N    __I  uint32_t RESERVED3[22];
X    volatile const  uint32_t RESERVED3[22];
N    __IO uint32_t WDATA;         /* Offset: 0x80  CRC Write Data Register                                            */
X    volatile uint32_t WDATA;          
N    __IO uint32_t SEED;          /* Offset: 0x84  CRC Seed Register                                                  */
X    volatile uint32_t SEED;           
N    __I  uint32_t CHECKSUM;      /* Offset: 0x88  CRC Checksum Register                                              */
X    volatile const  uint32_t CHECKSUM;       
N
N} CRC_T;
N
N
N
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N/* CRC CTL Bit Field Definitions */
N#define CRC_CTL_CRC_MODE_Pos            30                                      /*!< CRC_T::CTL: CRC_MODE Position */
N#define CRC_CTL_CRC_MODE_Msk            (0x3ul << CRC_CTL_CRC_MODE_Pos)         /*!< CRC_T::CTL: CRC_MODE Mask */
N
N#define CRC_CTL_CPU_WDLEN_Pos           28                                      /*!< CRC_T::CTL: CPU_WDLEN Position */
N#define CRC_CTL_CPU_WDLEN_Msk           (0x3ul << CRC_CTL_CPU_WDLEN_Pos)        /*!< CRC_T::CTL: CPU_WDLEN Mask */
N
N#define CRC_CTL_CHECKSUM_COM_Pos        27                                      /*!< CRC_T::CTL: CHECKSUM_COM Position */
N#define CRC_CTL_CHECKSUM_COM_Msk        (1ul << CRC_CTL_CHECKSUM_COM_Pos)       /*!< CRC_T::CTL: CHECKSUM_COM Mask */
N
N#define CRC_CTL_WDATA_COM_Pos           26                                      /*!< CRC_T::CTL: WDATA_COM Position */
N#define CRC_CTL_WDATA_COM_Msk           (1ul << CRC_CTL_WDATA_COM_Pos)          /*!< CRC_T::CTL: WDATA_COM Mask */
N
N#define CRC_CTL_CHECKSUM_RVS_Pos        25                                      /*!< CRC_T::CTL: CHECKSUM_RVS Position */
N#define CRC_CTL_CHECKSUM_RVS_Msk        (1ul << CRC_CTL_CHECKSUM_RVS_Pos)       /*!< CRC_T::CTL: CHECKSUM_RVS Mask */
N
N#define CRC_CTL_WDATA_RVS_Pos           24                                      /*!< CRC_T::CTL: WDATA_RVS Position */
N#define CRC_CTL_WDATA_RVS_Msk           (1ul << CRC_CTL_WDATA_RVS_Pos)          /*!< CRC_T::CTL: WDATA_RVS Mask */
N
N#define CRC_CTL_TRIG_EN_Pos             23                                      /*!< CRC_T::CTL: TRIG_EN Position */
N#define CRC_CTL_TRIG_EN_Msk             (1ul << CRC_CTL_TRIG_EN_Pos)            /*!< CRC_T::CTL: TRIG_EN Mask */
N
N#define CRC_CTL_CRC_RST_Pos             1                                       /*!< CRC_T::CTL: CRC_RST Position */
N#define CRC_CTL_CRC_RST_Msk             (1ul << CRC_CTL_CRC_RST_Pos)            /*!< CRC_T::CTL: CRC_RST Mask */
N
N#define CRC_CTL_CRCCEN_Pos              0                                       /*!< CRC_T::CTL: CRCCEN Position */
N#define CRC_CTL_CRCCEN_Msk              (1ul << CRC_CTL_CRCCEN_Pos)             /*!< CRC_T::CTL: CRCCEN Mask */
N
N/* CRC DMASAR Bit Field Definitions */
N#define CRC_DMASAR_CRC_DMASAR_Pos       0                                               /*!< CRC_T::DMASAR: CRC_DMASAR Position */
N#define CRC_DMASAR_CRC_DMASAR_Msk       (0xFFFFFFFFul << CRC_DMASAR_CRC_DMASAR_Pos)     /*!< CRC_T::DMASAR: CRC_DMASAR Mask */
N
N/* CRC DMABCR Bit Field Definitions */
N#define CRC_DMABCR_CRC_DMABCR_Pos       0                                               /*!< CRC_T::DMABCR: CRC_DMABCR Position */
N#define CRC_DMABCR_CRC_DMABCR_Msk       (0xFFFFul << CRC_DMABCR_CRC_DMABCR_Pos)         /*!< CRC_T::DMABCR: CRC_DMABCR Mask */
N
N/* CRC DMACSAR Bit Field Definitions */
N#define CRC_DMACSAR_CRC_DMACSAR_Pos     0                                               /*!< CRC_T::DMACSAR: CRC_DMACSAR Position */
N#define CRC_DMACSAR_CRC_DMACSAR_Msk     (0xFFFFFFFFul << CRC_DMACSAR_CRC_DMACSAR_Pos)   /*!< CRC_T::DMACSAR: CRC_DMACSAR Mask */
N
N/* CRC DMACBCR Bit Field Definitions */
N#define CRC_DMACBCR_CRC_DMACBCR_Pos     0                                               /*!< CRC_T::DMACBCR: DMACBCR Position */
N#define CRC_DMACBCR_CRC_DMACBCR_Msk     (0xFFFFul << CRC_DMACBCR_CRC_DMACBCR_Pos)       /*!< CRC_T::DMACBCR: DMACBCR Mask */
N
N/* CRC DMAIER Bit Field Definitions */
N#define CRC_DMAIER_CRC_BLKD_IE_Pos      1                                               /*!< CRC_T::DMAIER: CRC_BLKD_IE Position */
N#define CRC_DMAIER_CRC_BLKD_IE_Msk      (1ul << CRC_DMAIER_CRC_BLKD_IE_Pos)             /*!< CRC_T::DMAIER: CRC_BLKD_IE Mask */
N
N#define CRC_DMAIER_CRC_TABORT_IE_Pos    0                                               /*!< CRC_T::DMAIER: CRC_TABORT_IE Position */
N#define CRC_DMAIER_CRC_TABORT_IE_Msk    (1ul << CRC_DMAIER_CRC_TABORT_IE_Pos)           /*!< CRC_T::DMAIER: CRC_TABORT_IE Mask */
N
N/* CRC DMAISR Bit Field Definitions */
N#define CRC_DMAISR_CRC_BLKD_IF_Pos      1                                               /*!< CRC_T::DMAISR: CRC_BLKD_IF Position */
N#define CRC_DMAISR_CRC_BLKD_IF_Msk      (1ul << CRC_DMAISR_CRC_BLKD_IF_Pos)             /*!< CRC_T::DMAISR: CRC_BLKD_IF Mask */
N
N#define CRC_DMAISR_CRC_TABORT_IF_Pos    0                                               /*!< CRC_T::DMAISR: CRC_TABORT_IF Position */
N#define CRC_DMAISR_CRC_TABORT_IF_Msk    (1ul << CRC_DMAISR_CRC_TABORT_IF_Pos)           /*!< CRC_T::DMAISR: CRC_TABORT_IF Mask */
N
N/* CRC WDATA Bit Field Definitions */
N#define CRC_WDATA_CRC_WDATA_Pos         0                                               /*!< CRC_T::WDATA: CRC_WDATA Position */
N#define CRC_WDATA_CRC_WDATA_Msk         (0xFFFFFFFFul << CRC_WDATA_CRC_WDATA_Pos)       /*!< CRC_T::WDATA: CRC_WDATA Mask */
N
N/* CRC SEED Bit Field Definitions */
N#define CRC_SEED_CRC_SEED_Pos           0                                               /*!< CRC_T::SEED: CRC_SEED Position */
N#define CRC_SEED_CRC_SEED_Msk           (0xFFFFFFFFul << CRC_SEED_CRC_SEED_Pos)         /*!< CRC_T::SEED: CRC_SEED Mask */
N
N/* CRC CHECKSUM Bit Field Definitions */
N#define CRC_CHECKSUM_CRC_CHECKSUM_Pos   0                                               /*!< CRC_T::CHECKSUM: CRC_CHECKSUM Position */
N#define CRC_CHECKSUM_CRC_CHECKSUM_Msk   (0xFFFFFFFFul << CRC_CHECKSUM_CRC_CHECKSUM_Pos) /*!< CRC_T::CHECKSUM: CRC_CHECKSUM Mask */
N/*@}*/ /* end of group CRC_CONST */
N/*@}*/ /* end of group CRC */
N
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller (EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var EBI_T::EBICON
N * Offset: 0x00  EBI Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ExtEN     |EBI Enable
N * |        |          |This bit is the functional enable bit for EBI.
N * |        |          |0 = EBI function is disabled
N * |        |          |1 = EBI function is enabled
N * |[1]     |ExtBW16   |EBI data width 16 bit
N * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
N * |        |          |0 = EBI data width is 8 bit
N * |        |          |1 = EBI data width is 16 bit
N * |[10:8]  |MCLKDIV   |External Output Clock Divider
N * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
N * |        |          |000 = HCLK/1
N * |        |          |001 = HCLK/2
N * |        |          |010 = HCLK/4
N * |        |          |011 = HCLK/8
N * |        |          |100 = HCLK/16
N * |        |          |101 = HCKL/32
N * |        |          |11X = default
N * |        |          |Notice: Default value of output clock is HCLK/1
N * |[18:16] |ExttALE   |Expand Time of ALE
N * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE.
N * |        |          |tALE = (ExttALE + 1) * MCLK
N * @var EBI_T::EXTIME
N * Offset: 0x04  EBI Timing Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:3]   |ExttACC   |EBI Data Access Time
N * |        |          |ExttACC define data access time (tACC).
N * |        |          |tACC = (ExttACC + 1) * MCLK
N * |[10:8]  |ExttAHD   |EBI Data Access Hold Time
N * |        |          |ExttAHD define data access hold time (tAHD).
N * |        |          |tAHD = (ExttAHD + 1) * MCLK
N * |[15:12] |ExtIW2X   |Idle State Cycle After Write
N * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not
N * |        |          |zero.
N * |        |          |Idle state cycle = (ExtIW2X * MCLK)
N * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read
N * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS
N * |        |          |return
N * |        |          |to high if ExtIR2R is not zero.
N * |        |          |Idle state cycle = (ExtIR2R * MCLK)
N * @var EBI_T::EBICON2
N * Offset: 0x08   External Bus Interface General Control Register 2
N * ---------------------------------------------------------------------------------------------------
N */
N
N    __IO uint32_t EBICON;        /* Offset: 0x00  EBI Control Register                                               */
X    volatile uint32_t EBICON;         
N    __IO uint32_t EXTIME;        /* Offset: 0x04  EBI Timing Control Register                                        */
X    volatile uint32_t EXTIME;         
N    __IO uint32_t EBICON2;       /* Offset: 0x08   External Bus Interface General Control Register 2                 */
X    volatile uint32_t EBICON2;        
N
N} EBI_T;
N
N
N
N/**
N    @addtogroup EBI_CONST EBI Bit Field Definition
N    Constant Definitions for EBI Controller
N@{ */
N
N/* EBI EBICON Bit Field Definitions */
N#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI_T::EBICON: ExttALE Position */
N#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI_T::EBICON: ExttALE Mask */
N
N#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI_T::EBICON: MCLKDIV Position */
N#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI_T::EBICON: MCLKDIV Mask */
N
N#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI_T::EBICON: ExtBW16 Position */
N#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI_T::EBICON: ExtBW16 Mask */
N
N#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI_T::EBICON: ExtEN Position */
N#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI_T::EBICON: ExtEN Mask */
N
N/* EBI EXTIME Bit Field Definitions */
N#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI_T::EXTIME: ExtIR2R Position */
N#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI_T::EXTIME: ExtIR2R Mask */
N
N#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI_T::EXTIME: ExtIW2X Position */
N#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI_T::EXTIME: ExtIW2X Mask */
N
N#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI_T::EXTIME: ExttAHD Position */
N#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI_T::EXTIME: ExttAHD Mask */
N
N#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI_T::EXTIME: ExttACC Position */
N#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI_T::EXTIME: ExttACC Mask */
N
N/* EBI EBICON2 Bit Field Definitions */
N#define EBI_EBICON2_WAHD_OFF_Pos    2                                           /*!< EBI_T::EBICON2: WAHD_OFF Position */
N#define EBI_EBICON2_WAHD_OFF_Msk    (1ul << EBI_EBICON2_WAHD_OFF_Pos)           /*!< EBI_T::EBICON2: WAHD_OFF Mask */
N
N#define EBI_EBICON2_RAHD_OFF_Pos    1                                           /*!< EBI_T::EBICON2: RAHD_OFF Position */
N#define EBI_EBICON2_RAHD_OFF_Msk    (1ul << EBI_EBICON2_RAHD_OFF_Pos)           /*!< EBI_T::EBICON2: RAHD_OFF Mask */
N
N#define EBI_EBICON2_WBUFF_EN_Pos    0                                           /*!< EBI_T::EBICON2: WBUFF_EN Position */
N#define EBI_EBICON2_WBUFF_EN_Msk    (1ul << EBI_EBICON2_WBUFF_EN_Pos)           /*!< EBI_T::EBICON2: WBUFF_EN Mask */
N/*@}*/ /* end of group EBI_CONST */
N/*@}*/ /* end of group EBI */
N
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller (FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var FMC_T::ISPCON
N * Offset: 0x00  ISP Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPEN     |ISP Enable
N * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
N * |        |          |1 = Enable ISP function
N * |        |          |0 = Disable ISP function
N * |[1]     |BS        |Boot Select
N * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM,
N * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check
N * |        |          |where
N * |        |          |MCU booted from. This bit is initiated with the inverted value of CBS in Config0 after
N * |        |          |power-
N * |        |          |on reset; It keeps the same value at other reset.
N * |        |          |1 = boot from LDROM
N * |        |          |0 = boot from APROM
N * |[4]     |CFGUEN    |Config Update Enable
N * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of
N * |        |          |program
N * |        |          |code is running in APROM or LDROM.
N * |        |          |1 = Config update enable
N * |        |          |0 = Config update disable
N * |[5]     |LDUEN     |LDROM Update Enable
N * |        |          |LDROM update enable bit.
N * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N * |        |          |0 = LDROM cannot be updated
N * |[6]     |ISPFF     |ISP Fail Flag
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself.
N * |        |          |(2) LDROM writes to itself.
N * |        |          |(3) Destination address is illegal, such as over an available range.
N * |        |          |Write 1 to clear.
N * |[7]     |SWRST     |Software Reset
N * |        |          |Writing 1 to this bit to start software reset.
N * |        |          |It is cleared by hardware after reset is finished.
N * |[10:8]  |PT        |Flash Program Time
N * |        |          |000 = 40 us
N * |        |          |001 = 45 us
N * |        |          |010 = 50 us
N * |        |          |011 = 55 us
N * |        |          |100 = 20 us
N * |        |          |101 = 25 us
N * |        |          |110 = 30 us
N * |        |          |111 = 35 us
N * |[14:12] |ET        |Flash Erase Time
N * |        |          |000 = 20 ms (default)
N * |        |          |001 = 25 ms
N * |        |          |010 = 30 ms
N * |        |          |011 = 35 ms
N * |        |          |100 = 3  ms
N * |        |          |101 = 5  ms
N * |        |          |110 = 10 ms
N * |        |          |111 = 15 ms
N * @var FMC_T::ISPADR
N * Offset: 0x04  ISP Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPADR    |ISP Address
N * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program
N * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation.
N * @var FMC_T::ISPDAT
N * Offset: 0x08  ISP Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT    |ISP Data
N * |        |          |Write data to this register before ISP program operation
N * |        |          |Read data from this register after ISP read operation
N * @var FMC_T::ISPCMD
N * Offset: 0x0C  ISP Command Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command
N * |        |          |ISP command table is shown below:
N * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
N * |        |          |Read          ,    0,    0, 0000
N * |        |          |Program       ,    1,    0, 0001
N * |        |          |Page Erase    ,    1,    0, 0010
N * @var FMC_T::ISPTRG
N * Offset: 0x10  IISP Trigger Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP start trigger
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically
N * |        |          |when ISP
N * |        |          |operation is finish.
N * |        |          |1 = ISP is on going
N * |        |          |0 = ISP done
N * @var FMC_T::DFBADR
N * Offset: 0x14  Data Flash Base Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DFBA      |Data Flash Base Address
N * |        |          |This register indicates data flash start address.
N * |        |          |It is a read only register.
N * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is
N * |        |          |fixed at
N * |        |          |0x01F000 by hardware internally.
N * @var FMC_T::FATCON
N * Offset: 0x18  Flash Access Time Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FPSEN     |Flash Power Save Enable
N * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
N * |        |          |1 = Enable flash power saving
N * |        |          |0 = Disable flash power saving
N * |[3:1]   |FATS      |Flash Access Time Window Select
N * |        |          |These bits are used to decide flash sense amplifier active duration.
N * |        |          |000 = 40 ns
N * |        |          |001 = 50 ns
N * |        |          |010 = 60 ns
N * |        |          |011 = 70 ns
N * |        |          |100 = 80 ns
N * |        |          |101 = 90 ns
N * |        |          |110 = 100 ns
N * |        |          |111 = Reserved
N * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
N * |        |          |1 = Flash access always no wait state (zero wait state)
N * |        |          |0 = Insert wait state while Flash access discontinued address.
N * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong
N * |        |          |code and cause fail result.
N * @var FMC_T::ISPSTA
N * Offset: 0x40  Flash Access Time Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware
N * |        |          |automatically when ISP operation is finished.
N * |        |          |0 = ISP operation finished.
N * |        |          |1 = ISP operation progressed.
N * |        |          |Note: This bit is the same as ISPTRG bit0
N * |[2:1]   |CBS       |Chip Boot Selection (Read Only)
N * |        |          |This is a mirror of CBS in Config0.
N * |[6]     |ISPFF     |ISP Fail Flag (Write-protection Bit)
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself.
N * |        |          |(2) LDROM writes to itself.
N * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
N * |        |          |(4) Destination address is illegal, such as over an available range.
N * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N * |        |          |The current flash address space 0x0000_0000~0x0000_01FF is mapping to the address
N * |        |          |{VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}
N */
N
N    __IO uint32_t ISPCON;        /* Offset: 0x00  ISP Control Register                                               */
X    volatile uint32_t ISPCON;         
N    __IO uint32_t ISPADR;        /* Offset: 0x04  ISP Address Register                                               */
X    volatile uint32_t ISPADR;         
N    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
X    volatile uint32_t ISPDAT;         
N    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP Command Register                                               */
X    volatile uint32_t ISPCMD;         
N    __IO uint32_t ISPTRG;        /* Offset: 0x10  IISP Trigger Control Register                                      */
X    volatile uint32_t ISPTRG;         
N    __I  uint32_t DFBADR;        /* Offset: 0x14  Data Flash Base Address Register                                   */
X    volatile const  uint32_t DFBADR;         
N    __IO uint32_t FATCON;        /* Offset: 0x18  Flash Access Time Control Register                                 */
X    volatile uint32_t FATCON;         
N    __I  uint32_t RESERVED[9];  
X    volatile const  uint32_t RESERVED[9];  
N    __IO uint32_t ISPSTA;        /* Offset: 0x40  ISPSTA control register of FMC                                 */
X    volatile uint32_t ISPSTA;         
N
N} FMC_T;
N
N
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ET_Pos                       12                                      /*!< FMC_T::ISPCON: ET Position */
N#define FMC_ISPCON_ET_Msk                       (7ul << FMC_ISPCON_ET_Pos)              /*!< FMC_T::ISPCON: ET Mask     */
N
N#define FMC_ISPCON_PT_Pos                       8                                       /*!< FMC_T::ISPCON: PT Position */
N#define FMC_ISPCON_PT_Msk                       (7ul << FMC_ISPCON_PT_Pos)              /*!< FMC_T::ISPCON: PT Mask     */
N
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
N#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC_T::ISPCON: BS Mask */
N
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC_T::ISPADR: ISPADR Position */
N#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC_T::ISPADR: ISPADR Mask     */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC_T::ISPDAT: ISPDAT Position */
N#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC_T::ISPDAT: ISPDAT Mask     */
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC_T::ISPCMD: FOEN Position */
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC_T::ISPCMD: FOEN Mask */
N
N#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC_T::ISPCMD: FCEN Position */
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC_T::ISPCMD: FCEN Mask */
N
N#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC_T::ISPCMD: FCTRL Position */
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC_T::ISPCMD: FCTRL Mask */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
N
N/* FMC DFBADR Bit Field Definitions */
N#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC_T::DFBADR: DFBA Position */
N#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC_T::DFBADR: DFBA Mask     */
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_FOMSEL1_Pos                  6                                       /*!< FMC_T::FATCON: FOMSEL1 Position */
N#define FMC_FATCON_FOMSEL1_Msk                  (1ul << FMC_FATCON_FOMSEL1_Pos)         /*!< FMC_T::FATCON: FOMSEL1 Mask */
N
N#define FMC_FATCON_FOMSEL0_Pos                  4                                       /*!< FMC_T::FATCON: FOMSEL0 Position */
N#define FMC_FATCON_FOMSEL0_Msk                  (1ul << FMC_FATCON_FOMSEL0_Pos)         /*!< FMC_T::FATCON: FOMSEL0 Mask */
N
N#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC_T::FATCON: FATS Position */
N#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC_T::FATCON: FATS Mask */
N
N#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC_T::FATCON: FPSEN Position */
N#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC_T::FATCON: FPSEN Mask */
N
N
N#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
N#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
N
N#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
N#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC_T::ISPSTA: CBS Mask */
N
N#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
N#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC_T::ISPSTA: ISPFF Mask */
N
N#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
N#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
N/*@}*/ /* end of group FMC_CONST */
N/*@}*/ /* end of group FMC */
N
N
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller (GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var GPIO_T::PMD
N * Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |PMD0      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[3:2]   |PMD1      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[5:4]   |PMD2      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[7:6]   |PMD3      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[9:8]   |PMD4      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[11:10] |PMD5      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[13:12] |PMD6      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[15:14] |PMD7      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[17:16] |PMD8      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[19:18] |PMD9      |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[21:20] |PMD10     |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[23:22] |PMD11     |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[25:24] |PMD12     |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[27:26] |PMD13     |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[29:28] |PMD14     |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * |[31:30] |PMD15     |GPIOx I/O Pin[N] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be
N * |        |          |Quasi-bidirectional mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only
N * |        |          |mode after chip is powered on.
N * @var GPIO_T::OFFD
N * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |OFFD      |GPIOx Pin[N] Digital Input Path Disable Control
N * |        |          |Each of these bits is used to control if the digital input path of corresponding GPIO pin is
N * |        |          |disabled.
N * |        |          |If input is analog signal, users can disable GPIO digital input path to avoid current
N * |        |          |leakage.
N * |        |          |0 = I/O digital input path Enabled.
N * |        |          |1 = I/O digital input path Disabled (digital input tied to low).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::DOUT
N * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DOUT0     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |DOUT1     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |DOUT2     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |DOUT3     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |DOUT4     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |DOUT5     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |DOUT6     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |DOUT7     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |DOUT8     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |DOUT9     |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |DOUT10    |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |DOUT11    |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |DOUT12    |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |DOUT13    |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |DOUT14    |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |DOUT15    |GPIOx Pin[N] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as
N * |        |          |Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::DMASK
N * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DMASK0    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |DMASK1    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |DMASK2    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |DMASK3    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |DMASK4    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |DMASK5    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |DMASK6    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |DMASK7    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |DMASK8    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |DMASK9    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |DMASK10   |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |DMASK11   |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |DMASK12   |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |DMASK13   |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |DMASK14   |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |DMASK15   |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect
N * |        |          |the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT,
N * |        |          |GPIOEx_DOUT and GPIOFx_DOUT).
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::PIN
N * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PIN0      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |PIN1      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |PIN2      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |PIN3      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |PIN4      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |PIN5      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |PIN6      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |PIN7      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |PIN8      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |PIN9      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |PIN10     |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |PIN11     |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |PIN12     |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |PIN13     |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |PIN14     |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |PIN15     |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is
N * |        |          |low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::DBEN
N * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DBEN0     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |DBEN1     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |DBEN2     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |DBEN3     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |DBEN4     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |DBEN5     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |DBEN6     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |DBEN7     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |DBEN8     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |DBEN9     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |DBEN10    |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |DBEN11    |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |DBEN12    |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |DBEN13    |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |DBEN14    |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |DBEN15    |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle,
N * |        |          |the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period
N * |        |          |is controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::IMD
N * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |IMD0      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |IMD1      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |IMD2      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |IMD3      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |IMD4      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |IMD5      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |IMD6      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |IMD7      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |IMD8      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |IMD9      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |IMD10     |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |IMD11     |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |IMD12     |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |IMD13     |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |IMD14     |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |IMD15     |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will
N * |        |          |occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::IEN
N * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |IF_EN0    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |IF_EN1    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |IF_EN2    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |IF_EN3    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |IF_EN4    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |IF_EN5    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |IF_EN6    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |IF_EN7    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |IF_EN8    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |IF_EN9    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |IF_EN10   |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |IF_EN11   |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |IF_EN12   |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |IF_EN13   |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |IF_EN14   |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |IF_EN15   |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[16]    |IR_EN0    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[17]    |IR_EN1    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[18]    |IR_EN2    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[19]    |IR_EN3    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[20]    |IR_EN4    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[21]    |IR_EN5    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[22]    |IR_EN6    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[23]    |IR_EN7    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[24]    |IR_EN8    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[25]    |IR_EN9    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[26]    |IR_EN10   |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[27]    |IR_EN11   |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[28]    |IR_EN12   |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[29]    |IR_EN13   |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[30]    |IR_EN14   |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[31]    |IR_EN15   |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will
N * |        |          |generate the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::ISRC
N * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISRC0     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[1]     |ISRC1     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[2]     |ISRC2     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[3]     |ISRC3     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[4]     |ISRC4     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[5]     |ISRC5     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[6]     |ISRC6     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[7]     |ISRC7     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[8]     |ISRC8     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[9]     |ISRC9     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[10]    |ISRC10    |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[11]    |ISRC11    |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[12]    |ISRC12    |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[13]    |ISRC13    |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[14]    |ISRC14    |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[15]    |ISRC15    |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N */
N
N    __IO uint32_t PMD;           /* Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control                       */
X    volatile uint32_t PMD;            
N    __IO uint32_t OFFD;          /* Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control     */
X    volatile uint32_t OFFD;           
N    __IO uint32_t DOUT;          /* Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value                          */
X    volatile uint32_t DOUT;           
N    __IO uint32_t DMASK;         /* Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask                     */
X    volatile uint32_t DMASK;          
N    __I  uint32_t PIN;           /* Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value                                  */
X    volatile const  uint32_t PIN;            
N    __IO uint32_t DBEN;          /* Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable                           */
X    volatile uint32_t DBEN;           
N    __IO uint32_t IMD;           /* Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control                     */
X    volatile uint32_t IMD;            
N    __IO uint32_t IEN;           /* Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable                           */
X    volatile uint32_t IEN;            
N    __IO uint32_t ISRC;          /* Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag                      */
X    volatile uint32_t ISRC;           
N
N} GPIO_T;
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var GPIO_DBNCECON_T::DBNCECON
N * Offset: 0x180  External Interrupt De-bounce Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
N * |        |          |0000 = Sample interrupt input once per 1 clocks
N * |        |          |0001 = Sample interrupt input once per 2 clocks
N * |        |          |0010 = Sample interrupt input once per 4 clocks
N * |        |          |0011 = Sample interrupt input once per 8 clocks
N * |        |          |0100 = Sample interrupt input once per 16 clocks
N * |        |          |0101 = Sample interrupt input once per 32 clocks
N * |        |          |0110 = Sample interrupt input once per 64 clocks
N * |        |          |0111 = Sample interrupt input once per 128 clocks
N * |        |          |1000 = Sample interrupt input once per 256 clocks
N * |        |          |1001 = Sample interrupt input once per 2*256 clocks
N * |        |          |1010 = Sample interrupt input once per 4*256clocks
N * |        |          |1011 = Sample interrupt input once per 8*256 clocks
N * |        |          |1100 = Sample interrupt input once per 16*256 clocks
N * |        |          |1101 = Sample interrupt input once per 32*256 clocks
N * |        |          |1110 = Sample interrupt input once per 64*256 clocks
N * |        |          |1111 = Sample interrupt input once per 128*256 clocks
N * |        |          |Sample   interrupt input once per 128*256 clocks
N * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
N * |        |          |0 = De-bounce counter clock source is the HCLK.
N * |        |          |1 = De-bounce counter clock source is the internal 10 kHz low speed oscillator.
N * |[5]     |ICLK_ON   |Interrupt Clock On Mode
N * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to
N * |        |          |1.
N * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N * |        |          |It is recommended to turn off this bit to save system power if no special application
N * |        |          |concern.
N */
N
N    __IO uint32_t DBNCECON;      /* Offset: 0x180  External Interrupt De-bounce Control                              */
X    volatile uint32_t DBNCECON;       
N
N} GPIO_DBNCECON_T;
N
N
N
N/**
N    @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO_T::PMD: PMD15 Position */
N#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO_T::PMD: PMD15 Mask */
N
N#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO_T::PMD: PMD14 Position */
N#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO_T::PMD: PMD14 Mask */
N
N#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO_T::PMD: PMD13 Position */
N#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO_T::PMD: PMD13 Mask */
N
N#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO_T::PMD: PMD12 Position */
N#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO_T::PMD: PMD12 Mask */
N
N#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO_T::PMD: PMD11 Position */
N#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO_T::PMD: PMD11 Mask */
N
N#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO_T::PMD: PMD10 Position */
N#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO_T::PMD: PMD10 Mask */
N
N#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO_T::PMD: PMD9 Position */
N#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO_T::PMD: PMD9 Mask */
N
N#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO_T::PMD: PMD8 Position */
N#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO_T::PMD: PMD8 Mask */
N
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
N#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO_T::OFFD: OFFD Mask */
N
N/* GPIO DOUT Bit Field Definitions */
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
N#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO_T::DOUT: DOUT Mask */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO_T::DMASK: DMASK Mask */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
N#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO_T::PIN: PIN Mask */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
N#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO_T::DBEN: DBEN Mask */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
N#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO_T::IMD: IMD Mask */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
N#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO_T::IEN: IR_EN Mask */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
N#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO_T::IEN: IF_EN Mask */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
N#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO_T::ISRC: ISRC Mask */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Position */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Mask */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Position */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Mask */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Position */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Mask */
N/*@}*/ /* end of group GPIO_CONST */
N/*@}*/ /* end of group GPIO */
N
N
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller (I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var I2C_T::I2CON
N * Offset: 0x00  I2C Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2]     |AA        |Assert Acknowledge Control
N * |        |          |When AA =1 prior to address or data received, an acknowledged (low level to I2Cn_SDA) will
N * |        |          |be returned during the acknowledge clock pulse on the I2Cn_SCL line when 1.) A slave is
N * |        |          |acknowledging the address sent from master, 2.) The receiver devices are acknowledging the
N * |        |          |data sent by transmitter.
N * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to I2Cn_SDA)
N * |        |          |will be returned during the acknowledge clock pulse on the I2Cn_SCL line.
N * |[3]     |SI        |I2C Interrupt Flag
N * |        |          |When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware,
N * |        |          |and if bit EI (I2CON [7]) is set, the I2C interrupt is requested.
N * |        |          |SI must be cleared by software.
N * |        |          |Clear SI by writing 1 to this bit.
N * |[4]     |STO       |I2C STOP Control
N * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check
N * |        |          |the bus condition if a STOP condition is detected this bit will be cleared by hardware
N * |        |          |automatically.
N * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
N * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master
N * |        |          |transmit device.
N * |[5]     |STA       |I2C START Control
N * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START
N * |        |          |condition to bus when the bus is free.
N * |[6]     |ENS1      |I2C Controller Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Set to enable I2C serial function controller.
N * |        |          |When ENS1=1 the I2C serial function enables.
N * |        |          |The multi-function pin function of I2Cn_SDA and I2Cn_SCL must set to I2C function first.
N * |[7]     |EI        |Enable Interrupt
N * |        |          |0 = I2C interrupt Disabled.
N * |        |          |1 = I2C interrupt Enabled.
N * @var I2C_T::I2CADDR0
N * Offset: 0x04  I2C Slave Address Register0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own
N * |        |          |address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CDAT
N * Offset: 0x08  I2C Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CDAT    |I2C Data Register
N * |        |          |Bit [7:0] is located with the 8-bit transferred data of I2C serial port.
N * @var I2C_T::I2CSTATUS
N * Offset: 0x0C  I2C Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CSTATUS |I2C Status Register
N * |        |          |The status register of I2C:
N * |        |          |The three least significant bits are always 0.
N * |        |          |The five most significant bits contain the status code.
N * |        |          |There are 26 possible status codes.
N * |        |          |When I2CSTATUS contains F8H, no serial interrupt is requested.
N * |        |          |All other I2CSTATUS values correspond to defined I2C states.
N * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N * |        |          |A valid status code is present in I2CSTATUS one cycle after SI is set by hardware and is
N * |        |          |still present one cycle after SI has been reset by software.
N * |        |          |In addition, states 00H stands for a Bus Error.
N * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the
N * |        |          |formation frame.
N * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte
N * |        |          |or an acknowledge bit.
N * @var I2C_T::I2CLK
N * Offset: 0x10  I2C Clock Divided Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CLK     |I2C clock divided Register
N * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
N * |        |          |Note: The minimum value of I2CLK is 4.
N * @var I2C_T::I2CTOC
N * Offset: 0x14  I2C Time-out Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Time-out Flag
N * |        |          |This bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt
N * |        |          |enable bit (EI) is set to 1.
N * |        |          |Note: Write 1 to clear this bit.
N * |[1]     |DIV4      |Time-out Counter Input Clock Divided by 4
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |When Enabled, The time-out period is extend 4 times.
N * |[2]     |ENTI      |Time-out Counter Enable/Disable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
N * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
N * @var I2C_T::I2CADDR1
N * Offset: 0x18  I2C Slave Address Register1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own
N * |        |          |address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CADDR2
N * Offset: 0x1C  I2C Slave Address Register2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own
N * |        |          |address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CADDR3
N * Offset: 0x20  I2C Slave Address Register3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own
N * |        |          |address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CADM0
N * Offset: 0x24  I2C Slave Address Mask Register0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as
N * |        |          |address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be
N * |        |          |exact the same as address register.
N * @var I2C_T::I2CADM1
N * Offset: 0x28  I2C Slave Address Mask Register1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as
N * |        |          |address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be
N * |        |          |exact the same as address register.
N * @var I2C_T::I2CADM2
N * Offset: 0x2C  I2C Slave Address Mask Register2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as
N * |        |          |address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be
N * |        |          |exact the same as address register.
N * @var I2C_T::I2CADM3
N * Offset: 0x30  I2C Slave Address Mask Register3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as
N * |        |          |address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be
N * |        |          |exact the same as address register.
N * @var I2C_T::I2CWKUPCON
N * Offset: 0x3C  I2C Wake-up Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WKUPEN    |I2C Wake-up Enable
N * |        |          |0 = I2C wake-up function Disabled.
N * |        |          |1= I2C wake-up function Enabled.
N * @var I2C_T::I2CWKUPSTS
N * Offset: 0x40  I2C Wake-up Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WKUPIF    |I2C Wake-up Flag
N * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
N * |        |          |Software can write 1 to clear this bit.
N */
N
N    __IO uint32_t I2CON;         /* Offset: 0x00  I2C Control Register                                               */
X    volatile uint32_t I2CON;          
N    __IO uint32_t I2CADDR0;      /* Offset: 0x04  I2C Slave Address Register0                                        */
X    volatile uint32_t I2CADDR0;       
N    __IO uint32_t I2CDAT;        /* Offset: 0x08  I2C Data Register                                                  */
X    volatile uint32_t I2CDAT;         
N    __I  uint32_t I2CSTATUS;     /* Offset: 0x0C  I2C Status Register                                                */
X    volatile const  uint32_t I2CSTATUS;      
N    __IO uint32_t I2CLK;         /* Offset: 0x10  I2C Clock Divided Register                                         */
X    volatile uint32_t I2CLK;          
N    __IO uint32_t I2CTOC;        /* Offset: 0x14  I2C Time-out Counter Register                                      */
X    volatile uint32_t I2CTOC;         
N    __IO uint32_t I2CADDR1;      /* Offset: 0x18  I2C Slave Address Register1                                        */
X    volatile uint32_t I2CADDR1;       
N    __IO uint32_t I2CADDR2;      /* Offset: 0x1C  I2C Slave Address Register2                                        */
X    volatile uint32_t I2CADDR2;       
N    __IO uint32_t I2CADDR3;      /* Offset: 0x20  I2C Slave Address Register3                                        */
X    volatile uint32_t I2CADDR3;       
N    __IO uint32_t I2CADM0;       /* Offset: 0x24  I2C Slave Address Mask Register0                                   */
X    volatile uint32_t I2CADM0;        
N    __IO uint32_t I2CADM1;       /* Offset: 0x28  I2C Slave Address Mask Register1                                   */
X    volatile uint32_t I2CADM1;        
N    __IO uint32_t I2CADM2;       /* Offset: 0x2C  I2C Slave Address Mask Register2                                   */
X    volatile uint32_t I2CADM2;        
N    __IO uint32_t I2CADM3;       /* Offset: 0x30  I2C Slave Address Mask Register3                                   */
X    volatile uint32_t I2CADM3;        
N    __I  uint32_t RESERVED0[2];
X    volatile const  uint32_t RESERVED0[2];
N    __IO uint32_t I2CWKUPCON;    /* Offset: 0x3C  I2C Wake-up Control Register                                       */
X    volatile uint32_t I2CWKUPCON;     
N    __IO uint32_t I2CWKUPSTS;    /* Offset: 0x40  I2C Wake-up Status Register                                        */
X    volatile uint32_t I2CWKUPSTS;     
N
N} I2C_T;
N
N
N
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
N
N#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR1: I2CADDR Position */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR1: I2CADDR Mask */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR1: GC Position */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR1: GC Mask */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
N
N/* I2C I2CWKUPCON Bit Field Definitions */
N#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
N#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
N
N/* I2C I2CWKUPSTS Bit Field Definitions */
N#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
N#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
N
N/*@}*/ /* end of group I2C_CONST */
N/*@}*/ /* end of group I2C */
N
N
N
N/*----------------------------- I2S Controller -------------------------------*/
N/** @addtogroup I2S Integrated Inter-chip Sound(I2S)
N  Memory Mapped Structure for I2S Interface Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var I2S_T::CON
N * Offset: 0x00  I2S Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |I2SEN     |I2S Controller Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |TXEN      |Transmit Enable
N * |        |          |0 = Data transmit Disabled.
N * |        |          |1 = Data transmit Enabled.
N * |[2]     |RXEN      |Receive Enable
N * |        |          |0 = Data receiving Disabled.
N * |        |          |1 = Data receiving Enabled.
N * |[3]     |MUTE      |Transmit Mute Enable
N * |        |          |0 = Transmit data is shifted from buffer.
N * |        |          |1 = Send zero on transmit channel.
N * |[5:4]   |WORDWIDTH |Word Width
N * |        |          |00 = data is 8-bit word.
N * |        |          |01 = data is 16-bit word.
N * |        |          |10 = data is 24-bit word.
N * |        |          |11 = data is 32-bit word.
N * |[6]     |MONO      |Monaural Data
N * |        |          |0 = Data is stereo format.
N * |        |          |1 = Data is monaural format.
N * |[7]     |FORMAT    |Data Format
N * |        |          |0 = I2S data format.
N * |        |          |1 = MSB justified data format.
N * |[8]     |SLAVE     |Slave Mode
N * |        |          |I2S can operate as master or slave.
N * |        |          |For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from MCU to
N * |        |          |Audio CODEC chip.
N * |        |          |In Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals
N * |        |          |are received from outer Audio CODEC chip.
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[11:9]  |TXTH      |Transmit FIFO Threshold Level
N * |        |          |If the count of remaining data word (32 bits) in transmit FIFO is equal to or less than
N * |        |          |threshold level then TXTHF (I2SSTATUS[18]) is set.
N * |        |          |000 = 0 word data in transmit FIFO.
N * |        |          |001 = 1 word data in transmit FIFO.
N * |        |          |010 = 2 words data in transmit FIFO.
N * |        |          |011 = 3 words data in transmit FIFO.
N * |        |          |100 = 4 words data in transmit FIFO.
N * |        |          |101 = 5 words data in transmit FIFO.
N * |        |          |110 = 6 words data in transmit FIFO.
N * |        |          |111 = 7 words data in transmit FIFO.
N * |[14:12] |RXTH      |Receive FIFO Threshold Level
N * |        |          |When the count of received data word(s) in buffer is equal to or higher than threshold
N * |        |          |level, RXTHF (I2SSTATUS[10]) will be set.
N * |        |          |000 = 1 word data in receive FIFO.
N * |        |          |001 = 2 word data in receive FIFO.
N * |        |          |010 = 3 word data in receive FIFO.
N * |        |          |011 = 4 word data in receive FIFO.
N * |        |          |100 = 5 word data in receive FIFO.
N * |        |          |101 = 6 word data in receive FIFO.
N * |        |          |110 = 7 word data in receive FIFO.
N * |        |          |111 = 8 word data in receive FIFO.
N * |[15]    |MCLKEN    |Master Clock Enable
N * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on I2S_MCLK pin for
N * |        |          |external audio devices.
N * |        |          |0 = Master clock Disabled.
N * |        |          |1 = Master clock Enabled.
N * |[16]    |RCHZCEN   |Right Channel Zero Cross Detection Enable
N * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are
N * |        |          |all 0 then RZCF flag in I2SSTATUS register is set to 1.
N * |        |          |This function is only available in transmit operation.
N * |        |          |0 = Right channel zero cross detection Disabled.
N * |        |          |1 = Right channel zero cross detection Enabled.
N * |[17]    |LCHZCEN   |Left Channel Zero Cross Detection Enable
N * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are
N * |        |          |all 0 then LZCF flag in I2SSTATUS register is set to 1.
N * |        |          |This function is only available in transmit operation.
N * |        |          |0 = Left channel zero cross detection Disabled.
N * |        |          |1 = Left channel zero cross detection Enabled.
N * |[18]    |CLR_TXFIFO|Clear Transmit FIFO
N * |        |          |Write 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and
N * |        |          |TX_LEVEL[3:0] returns to 0 and
N * |        |          |transmit FIFO becomes empty but data in transmit FIFO is not changed.
N * |        |          |This bit is cleared by hardware automatically. Returns 0 on read.
N * |[19]    |CLR_RXFIFO|Clear Receive FIFO
N * |        |          |Write 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and
N * |        |          |RX_LEVEL[3:0] returns 0 and receive FIFO becomes empty.
N * |        |          |This bit is cleared by hardware automatically. Returns 0 on read.
N * |[20]    |TXDMA     |Enable Transmit DMA
N * |        |          |When TX DMA is enabled, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO
N * |        |          |is not full.
N * |        |          |0 = TX DMA Disabled.
N * |        |          |1 = TX DMA Enabled.
N * |[21]    |RXDMA     |Enable Receive DMA
N * |        |          |When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO
N * |        |          |is not empty.
N * |        |          |0 = RX DMA Disabled.
N * |        |          |1 = RX DMA Enabled.
N * |[23]    |RXLCH     |Receive Left Channel Enable
N * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data
N * |        |          |if RXLCH is set to 0,
N * |        |          |and receive left channel data if RXLCH is set to 1.
N * |        |          |0 = Receive right channel data in Mono mode.
N * |        |          |1 = Receive left channel data in Mono mode.
N * @var I2S_T::CLKDIV
N * Offset: 0x04  I2S Clock Divider Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |MCLK_DIV  |Master Clock Divider
N * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices.
N * |        |          |The master clock rate, F_MCLK, is determined by the following expressions.
N * |        |          |If MCLK_DIV >= 1, F_MCLK = F_I2SCLK/(2x(MCLK_DIV)).
N * |        |          |If MCLK_DIV = 0, F_MCLK = F_I2SCLK.
N * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
N * |        |          |In general, the master clock rate is 256 times sampling clock rate.
N * |[15:8]  |BCLK_DIV  |Bit Clock Divider
N * |        |          |The I2S controller will generate bit clock in Master mode.
N * |        |          |The bit clock rate, F_BCLK, is determined by the following expression.
N * |        |          |F_BCLK = F_I2SCLK /(2x(BCLK_DIV + 1)) , where F_I2SCLK is the frequency of I2S peripheral
N * |        |          |clock.
N * @var I2S_T::IE
N * Offset: 0x08  I2S Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXUDFIE   |Receive FIFO Underflow Interrupt Enable
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[1]     |RXOVFIE   |Receive FIFO Overflow Interrupt Enable
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[2]     |RXTHIE    |Receive FIFO Threshold Level Interrupt Enable
N * |        |          |When the count of data words in receive FIFO is equal to or higher than RXTH (I2SCON[14:12])
N * |        |          |and
N * |        |          |this bit is set to 1, receive FIFO threshold level interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[8]     |TXUDFIE   |Transmit FIFO Underflow Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and the transmit FIFO underflow flag is set to 1.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[9]     |TXOVFIE   |Transmit FIFO Overflow Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and the transmit FIFO overflow flag is set to 1
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[10]    |TXTHIE    |Transmit FIFO Threshold Level Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and the count of data words in transmit FIFO is
N * |        |          |less than TXTH (I2SCON[11:9]).
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[11]    |RZCIE     |Right Channel Zero-Cross Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero-cross event is detected.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[12]    |LZCIE     |Left Channel Zero-Cross Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero-cross event is detected.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * @var I2S_T::STATUS
N * Offset: 0x0C  I2S Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |I2SINT    |I2S Interrupt Flag
N * |        |          |This bit is wire-OR of I2STXINT and I2SRXINT bits.
N * |        |          |0 = No I2S interrupt.
N * |        |          |1 = I2S interrupt.
N * |        |          |Note: This bit is read only.
N * |[1]     |I2SRXINT  |I2S Receive Interrupt
N * |        |          |0 = No receive interrupt.
N * |        |          |1 = Receive interrupt.
N * |        |          |Note: This bit is read only.
N * |[2]     |I2STXINT  |I2S Transmit Interrupt
N * |        |          |0 = No transmit interrupt.
N * |        |          |1 = Transmit interrupt.
N * |        |          |Note: This bit is read only.
N * |[3]     |RIGHT     |Right Channel
N * |        |          |This bit indicates current transmit data is belong to which channel
N * |        |          |0 = Left channel.
N * |        |          |1 = Right channel.
N * |        |          |Note: This bit is read only.
N * |[8]     |RXUDF     |Receive FIFO Underflow Flag
N * |        |          |Underflow event will occur if read the empty receive FIFO.
N * |        |          |0 = No underflow event occurred.
N * |        |          |1 = Underflow.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[9]     |RXOVF     |Receive FIFO Overflow Flag
N * |        |          |When receive FIFO is full and hardware attempt to write data to receive FIFO, this bit will
N * |        |          |be set to 1, data in 1st buffer will be overwrote.
N * |        |          |0 = No overflow.
N * |        |          |1 = Overflow.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[10]    |RXTHF     |Receive FIFO Threshold Flag
N * |        |          |When data word(s) in receive FIFO is equal to or larger than threshold value set in RXTH
N * |        |          |(I2SCON[14:12]).
N * |        |          |The RXTHF bit becomes to 1.
N * |        |          |It keeps at 1 till RX_LEVEL (I2SSTATUS[27:24]) is less than RXTH.
N * |        |          |0 = Data word(s) in FIFO is less than threshold level.
N * |        |          |1 = Data word(s) in FIFO is equal to or larger than threshold level.
N * |        |          |Note: This bit is read only.
N * |[11]    |RXFULL    |Receive FIFO Full
N * |        |          |This bit reflects the count of data in receive FIFO is 8
N * |        |          |0 = Not full.
N * |        |          |1 = Full.
N * |        |          |Note: This bit is read only.
N * |[12]    |RXEMPTY   |Receive FIFO Empty
N * |        |          |This bit reflects the count of data in receive FIFO is 0
N * |        |          |0 = Not empty.
N * |        |          |1 = Empty.
N * |        |          |Note: This bit is read only.
N * |[16]    |TXUDF     |Transmit FIFO Underflow Flag
N * |        |          |If transmit FIFO is empty and hardware reads data from transmit FIFO. This bit will be set
N * |        |          |to 1.
N * |        |          |0 = No underflow.
N * |        |          |1 = Underflow.
N * |        |          |Note: Software can write 1 to clear this bit to 0.
N * |[17]    |TXOVF     |Transmit FIFO Overflow Flag
N * |        |          |This bit will be set to 1 if writes data to transmit FIFO when transmit FIFO is full.
N * |        |          |0 = No overflow.
N * |        |          |1 = Overflow.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[18]    |TXTHF     |Transmit FIFO Threshold Flag
N * |        |          |When the count of data stored in transmit-FIFO is equal to or less than threshold value set
N * |        |          |in TXTH (I2SCON[11:9]).
N * |        |          |The TXTHF bit becomes to 1.
N * |        |          |It keeps at 1 till TX_LEVEL (I2SSTATUS[31:28]) is larger than TXTH.
N * |        |          |0 = Data word(s) in FIFO is larger than threshold level.
N * |        |          |1 = Data word(s) in FIFO is equal to or less than threshold level.
N * |        |          |Note: This bit is read only.
N * |[19]    |TXFULL    |Transmit FIFO Full
N * |        |          |This bit reflects data word number in transmit FIFO is 8
N * |        |          |0 = Not full.
N * |        |          |1 = Full.
N * |        |          |Note: This bit is read only.
N * |[20]    |TXEMPTY   |Transmit FIFO Empty
N * |        |          |This bit reflects data word number in transmit FIFO is 0
N * |        |          |0 = Not empty.
N * |        |          |1 = Empty.
N * |        |          |Note: This bit is read only.
N * |[21]    |TXBUSY    |Transmit Busy
N * |        |          |This bit is cleared to 0 when all data in transmit FIFO and shift buffer is shifted out.
N * |        |          |And set to 1 when 1st data is load to shift buffer.
N * |        |          |0 = Transmit shift buffer is empty.
N * |        |          |1 = Transmit shift buffer is not empty.
N * |        |          |Note: This bit is read only.
N * |[22]    |RZCF      |Right Channel Zero-Cross Flag
N * |        |          |It indicates the sign bit of right channel sample data is changed or all data bits are 0.
N * |        |          |0 = No zero-cross.
N * |        |          |1 = Right channel zero-cross event is detected.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[23]    |LZCF      |Left Channel Zero-Cross Flag
N * |        |          |It indicates the sign bit of left channel sample data is changed or all data bits are 0.
N * |        |          |0 = No zero-cross.
N * |        |          |1 = Left channel zero-cross event is detected.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[27:24] |RX_LEVEL  |Receive FIFO Level
N * |        |          |These bits indicate word number in receive FIFO
N * |        |          |0000 = No data.
N * |        |          |0001 = 1 word in receive FIFO.
N * |        |          |....
N * |        |          |1000 = 8 words in receive FIFO.
N * |[31:28] |TX_LEVEL  |Transmit FIFO Level
N * |        |          |These bits indicate word number in transmit FIFO
N * |        |          |0000 = No data.
N * |        |          |0001 = 1 word in transmit FIFO.
N * |        |          |....
N * |        |          |1000 = 8 words in transmit FIFO.
N * @var I2S_T::TXFIFO
N * Offset: 0x10  I2S Transmit FIFO Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TXFIFO    |Transmit FIFO Register
N * |        |          |I2S contains 8 words (8x32 bits) data buffer for data transmit.
N * |        |          |Write data to this register to prepare data for transmission.
N * |        |          |The remaining word number is indicated by TX_LEVEL (I2SSTATUS[31:28]).
N * @var I2S_T::RXFIFO
N * Offset: 0x14  I2S Receive FIFO Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RXFIFO    |Receive FIFO Register
N * |        |          |I2S contains 8 words (8x32 bits) data buffer for data receive.
N * |        |          |Read this register to get data of receive FIFO.
N * |        |          |The remaining data word number is indicated by RX_LEVEL (I2SSTATUS[27:24]).
N */
N
N    __IO uint32_t CON;           /* Offset: 0x00  I2S Control Register                                               */
X    volatile uint32_t CON;            
N    __IO uint32_t CLKDIV;        /* Offset: 0x04  I2S Clock Divider Control Register                                 */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t IE;            /* Offset: 0x08  I2S Interrupt Enable Register                                      */
X    volatile uint32_t IE;             
N    __IO uint32_t STATUS;        /* Offset: 0x0C  I2S Status Register                                                */
X    volatile uint32_t STATUS;         
N    __O  uint32_t TXFIFO;        /* Offset: 0x10  I2S Transmit FIFO Register                                         */
X    volatile  uint32_t TXFIFO;         
N    __I  uint32_t RXFIFO;        /* Offset: 0x14  I2S Receive FIFO Register                                          */
X    volatile const  uint32_t RXFIFO;         
N
N} I2S_T;
N
N
N
N
N/**
N    @addtogroup I2S_CONST I2S Bit Field Definition
N    Constant Definitions for I2S Controller
N@{ */
N
N/* I2S I2SCON Bit Field Definitions */
N#define I2S_CON_RXLCH_Pos                    23                                   /*!< I2S_T::CON: RXLCH Position         */
N#define I2S_CON_RXLCH_Msk                    (1ul << I2S_CON_RXLCH_Pos)           /*!< I2S_T::CON: RXLCH Mask             */
N
N#define I2S_CON_RXDMA_Pos                    21                                   /*!< I2S_T::CON: RXDMA Position         */
N#define I2S_CON_RXDMA_Msk                    (1ul << I2S_CON_RXDMA_Pos)           /*!< I2S_T::CON: RXDMA Mask             */
N
N#define I2S_CON_TXDMA_Pos                    20                                   /*!< I2S_T::CON: TXDMA Position         */
N#define I2S_CON_TXDMA_Msk                    (1ul << I2S_CON_TXDMA_Pos)           /*!< I2S_T::CON: TXDMA Mask             */
N
N#define I2S_CON_CLR_RXFIFO_Pos               19                                   /*!< I2S_T::CON: CLR_RXFIFO Position    */
N#define I2S_CON_CLR_RXFIFO_Msk               (1ul << I2S_CON_CLR_RXFIFO_Pos)      /*!< I2S_T::CON: CLR_RXFIFO Mask        */
N
N#define I2S_CON_CLR_TXFIFO_Pos               18                                   /*!< I2S_T::CON: CLR_TXFIFO Position    */
N#define I2S_CON_CLR_TXFIFO_Msk               (1ul << I2S_CON_CLR_TXFIFO_Pos)      /*!< I2S_T::CON: CLR_TXFIFO Mask        */
N
N#define I2S_CON_LCHZCEN_Pos                  17                                   /*!< I2S_T::CON: LCHZCEN Position       */
N#define I2S_CON_LCHZCEN_Msk                  (1ul << I2S_CON_LCHZCEN_Pos)         /*!< I2S_T::CON: LCHZCEN Mask           */
N
N#define I2S_CON_RCHZCEN_Pos                  16                                   /*!< I2S_T::CON: RCHZCEN Position       */
N#define I2S_CON_RCHZCEN_Msk                  (1ul << I2S_CON_RCHZCEN_Pos)         /*!< I2S_T::CON: RCHZCEN Mask           */
N
N#define I2S_CON_MCLKEN_Pos                   15                                   /*!< I2S_T::CON: MCLKEN Position        */
N#define I2S_CON_MCLKEN_Msk                   (1ul << I2S_CON_MCLKEN_Pos)          /*!< I2S_T::CON: MCLKEN Mask            */
N
N#define I2S_CON_RXTH_Pos                     12                                   /*!< I2S_T::CON: RXTH Position          */
N#define I2S_CON_RXTH_Msk                     (7ul << I2S_CON_RXTH_Pos)            /*!< I2S_T::CON: RXTH Mask              */
N
N#define I2S_CON_TXTH_Pos                     9                                    /*!< I2S_T::CON: TXTH Position          */
N#define I2S_CON_TXTH_Msk                     (7ul << I2S_CON_TXTH_Pos)            /*!< I2S_T::CON: TXTH Mask              */
N
N#define I2S_CON_SLAVE_Pos                    8                                    /*!< I2S_T::CON: SLAVE Position         */
N#define I2S_CON_SLAVE_Msk                    (1ul << I2S_CON_SLAVE_Pos)           /*!< I2S_T::CON: SLAVE Mask             */
N
N#define I2S_CON_FORMAT_Pos                   7                                    /*!< I2S_T::CON: FORMAT Position        */
N#define I2S_CON_FORMAT_Msk                   (1ul << I2S_CON_FORMAT_Pos)          /*!< I2S_T::CON: FORMAT Mask            */
N
N#define I2S_CON_MONO_Pos                     6                                    /*!< I2S_T::CON: MONO Position          */
N#define I2S_CON_MONO_Msk                     (1ul << I2S_CON_MONO_Pos)            /*!< I2S_T::CON: MONO Mask              */
N
N#define I2S_CON_WORDWIDTH_Pos                4                                    /*!< I2S_T::CON: WORDWIDTH Position     */
N#define I2S_CON_WORDWIDTH_Msk                (3ul << I2S_CON_WORDWIDTH_Pos)       /*!< I2S_T::CON: WORDWIDTH Mask         */
N
N#define I2S_CON_MUTE_Pos                     3                                    /*!< I2S_T::CON: MUTE Position          */
N#define I2S_CON_MUTE_Msk                     (1ul << I2S_CON_MUTE_Pos)            /*!< I2S_T::CON: MUTE Mask              */
N
N#define I2S_CON_RXEN_Pos                     2                                    /*!< I2S_T::CON: RXEN Position          */
N#define I2S_CON_RXEN_Msk                     (1ul << I2S_CON_RXEN_Pos)            /*!< I2S_T::CON: RXEN Mask              */
N
N#define I2S_CON_TXEN_Pos                     1                                    /*!< I2S_T::CON: TXEN Position          */
N#define I2S_CON_TXEN_Msk                     (1ul << I2S_CON_TXEN_Pos)            /*!< I2S_T::CON: TXEN Mask              */
N
N#define I2S_CON_I2SEN_Pos                    0                                    /*!< I2S_T::CON: I2SEN Position         */
N#define I2S_CON_I2SEN_Msk                    (1ul << I2S_CON_I2SEN_Pos)           /*!< I2S_T::CON: I2SEN Mask             */
N
N/* I2S I2SCLKDIV Bit Field Definitions */                                                 
N#define I2S_CLKDIV_BCLK_DIV_Pos              8                                    /*!< I2S_T::CLKDIV: BCLK_DIV Position   */
N#define I2S_CLKDIV_BCLK_DIV_Msk              (0xFFul << I2S_CLKDIV_BCLK_DIV_Pos)  /*!< I2S_T::CLKDIV: BCLK_DIV Mask       */
N
N#define I2S_CLKDIV_MCLK_DIV_Pos              0                                    /*!< I2S_T::CLKDIV: MCLK_DIV Position   */
N#define I2S_CLKDIV_MCLK_DIV_Msk              (7ul << I2S_CLKDIV_MCLK_DIV_Pos)     /*!< I2S_T::CLKDIV: MCLK_DIV Mask       */
N
N/* I2S I2SIE Bit Field Definitions */                                                     
N#define I2S_IE_LZCIE_Pos                     12                                   /*!< I2S_T::IE: LZCIE Position          */
N#define I2S_IE_LZCIE_Msk                     (1ul << I2S_IE_LZCIE_Pos)            /*!< I2S_T::IE: LZCIE Mask              */
N
N#define I2S_IE_RZCIE_Pos                     11                                   /*!< I2S_T::IE: RZCIE Position          */
N#define I2S_IE_RZCIE_Msk                     (1ul << I2S_IE_RZCIE_Pos)            /*!< I2S_T::IE: RZCIE Mask              */
N
N#define I2S_IE_TXTHIE_Pos                    10                                   /*!< I2S_T::IE: TXTHIE Position         */
N#define I2S_IE_TXTHIE_Msk                    (1ul << I2S_IE_TXTHIE_Pos)           /*!< I2S_T::IE: TXTHIE Mask             */
N
N#define I2S_IE_TXOVFIE_Pos                   9                                    /*!< I2S_T::IE: TXOVFIE Position        */
N#define I2S_IE_TXOVFIE_Msk                   (1ul << I2S_IE_TXOVFIE_Pos)          /*!< I2S_T::IE: TXOVFIE Mask            */
N
N#define I2S_IE_TXUDFIE_Pos                   8                                    /*!< I2S_T::IE: TXUDFIE Position        */
N#define I2S_IE_TXUDFIE_Msk                   (1ul << I2S_IE_TXUDFIE_Pos)          /*!< I2S_T::IE: TXUDFIE Mask            */
N
N#define I2S_IE_RXTHIE_Pos                    2                                    /*!< I2S_T::IE: RXTHIE Position         */
N#define I2S_IE_RXTHIE_Msk                    (1ul << I2S_IE_RXTHIE_Pos)           /*!< I2S_T::IE: RXTHIE Mask             */
N
N#define I2S_IE_RXOVFIE_Pos                   1                                    /*!< I2S_T::IE: RXOVFIE Position        */
N#define I2S_IE_RXOVFIE_Msk                   (1ul << I2S_IE_RXOVFIE_Pos)          /*!< I2S_T::IE: RXOVFIE Mask            */
N
N#define I2S_IE_RXUDFIE_Pos                   0                                    /*!< I2S_T::IE: RXUDFIE Position        */
N#define I2S_IE_RXUDFIE_Msk                   (1ul << I2S_IE_RXUDFIE_Pos)          /*!< I2S_T::IE: RXUDFIE Mask            */
N
N
N/* I2S I2SSTATUS Bit Field Definitions */
N#define I2S_STATUS_TX_LEVEL_Pos              28                                   /*!< I2S_T::STATUS: TX_LEVEL Position   */
N#define I2S_STATUS_TX_LEVEL_Msk              (0xFul << I2S_STATUS_TX_LEVEL_Pos)   /*!< I2S_T::STATUS: TX_LEVEL Mask       */
N
N#define I2S_STATUS_RX_LEVEL_Pos              24                                   /*!< I2S_T::STATUS: RX_LEVEL Position   */
N#define I2S_STATUS_RX_LEVEL_Msk              (0xFul << I2S_STATUS_RX_LEVEL_Pos)   /*!< I2S_T::STATUS: RX_LEVEL Mask       */
N
N#define I2S_STATUS_LZCF_Pos                  23                                   /*!< I2S_T::STATUS: LZCF Position       */
N#define I2S_STATUS_LZCF_Msk                  (1ul << I2S_STATUS_LZCF_Pos)         /*!< I2S_T::STATUS: LZCF Mask           */
N
N#define I2S_STATUS_RZCF_Pos                  22                                   /*!< I2S_T::STATUS: RZCF Position       */
N#define I2S_STATUS_RZCF_Msk                  (1ul << I2S_STATUS_RZCF_Pos)         /*!< I2S_T::STATUS: RZCF Mask           */
N
N#define I2S_STATUS_TXBUSY_Pos                21                                   /*!< I2S_T::STATUS: TXBUSY Position     */
N#define I2S_STATUS_TXBUSY_Msk                (1ul << I2S_STATUS_TXBUSY_Pos)       /*!< I2S_T::STATUS: TXBUSY Mask         */
N
N#define I2S_STATUS_TXEMPTY_Pos               20                                   /*!< I2S_T::STATUS: TXEMPTY Position    */
N#define I2S_STATUS_TXEMPTY_Msk               (1ul << I2S_STATUS_TXEMPTY_Pos)      /*!< I2S_T::STATUS: TXEMPTY Mask        */
N
N#define I2S_STATUS_TXFULL_Pos                19                                   /*!< I2S_T::STATUS: TXFULL Position     */
N#define I2S_STATUS_TXFULL_Msk                (1ul << I2S_STATUS_TXFULL_Pos)       /*!< I2S_T::STATUS: TXFULL Mask         */
N
N#define I2S_STATUS_TXTHF_Pos                 18                                   /*!< I2S_T::STATUS: TXTHF Position      */
N#define I2S_STATUS_TXTHF_Msk                 (1ul << I2S_STATUS_TXTHF_Pos)        /*!< I2S_T::STATUS: TXTHF Mask          */
N
N#define I2S_STATUS_TXOVF_Pos                 17                                   /*!< I2S_T::STATUS: TXOVF Position      */
N#define I2S_STATUS_TXOVF_Msk                 (1ul << I2S_STATUS_TXOVF_Pos)        /*!< I2S_T::STATUS: TXOVF Mask          */
N
N#define I2S_STATUS_TXUDF_Pos                 16                                   /*!< I2S_T::STATUS: TXUDF Position      */
N#define I2S_STATUS_TXUDF_Msk                 (1ul << I2S_STATUS_TXUDF_Pos)        /*!< I2S_T::STATUS: TXUDF Mask          */
N
N#define I2S_STATUS_RXEMPTY_Pos               12                                   /*!< I2S_T::STATUS: RXEMPTY Position    */
N#define I2S_STATUS_RXEMPTY_Msk               (1ul << I2S_STATUS_RXEMPTY_Pos)      /*!< I2S_T::STATUS: RXEMPTY Mask        */
N
N#define I2S_STATUS_RXFULL_Pos                11                                   /*!< I2S_T::STATUS: RXFULL Position     */
N#define I2S_STATUS_RXFULL_Msk                (1ul << I2S_STATUS_RXFULL_Pos)       /*!< I2S_T::STATUS: RXFULL Mask         */
N
N#define I2S_STATUS_RXTHF_Pos                 10                                   /*!< I2S_T::STATUS: RXTHF Position      */
N#define I2S_STATUS_RXTHF_Msk                 (1ul << I2S_STATUS_RXTHF_Pos)        /*!< I2S_T::STATUS: RXTHF Mask          */
N
N#define I2S_STATUS_RXOVF_Pos                 9                                    /*!< I2S_T::STATUS: RXOVF Position      */
N#define I2S_STATUS_RXOVF_Msk                 (1ul << I2S_STATUS_RXOVF_Pos)        /*!< I2S_T::STATUS: RXOVF Mask          */
N
N#define I2S_STATUS_RXUDF_Pos                 8                                    /*!< I2S_T::STATUS: RXUDF Position      */
N#define I2S_STATUS_RXUDF_Msk                 (1ul << I2S_STATUS_RXUDF_Pos)        /*!< I2S_T::STATUS: RXUDF Mask          */
N
N#define I2S_STATUS_RIGHT_Pos                 3                                    /*!< I2S_T::STATUS: RIGHT Position      */
N#define I2S_STATUS_RIGHT_Msk                 (1ul << I2S_STATUS_RIGHT_Pos)        /*!< I2S_T::STATUS: RIGHT Mask          */
N
N#define I2S_STATUS_I2STXINT_Pos              2                                    /*!< I2S_T::STATUS: I2STXINT Position   */
N#define I2S_STATUS_I2STXINT_Msk              (1ul << I2S_STATUS_I2STXINT_Pos)     /*!< I2S_T::STATUS: I2STXINT Mask       */
N
N#define I2S_STATUS_I2SRXINT_Pos              1                                    /*!< I2S_T::STATUS: I2SRXINT Position   */
N#define I2S_STATUS_I2SRXINT_Msk              (1ul << I2S_STATUS_I2SRXINT_Pos)     /*!< I2S_T::STATUS: I2SRXINT Mask       */
N
N#define I2S_STATUS_I2SINT_Pos                0                                    /*!< I2S_T::STATUS: I2SINT Position     */
N#define I2S_STATUS_I2SINT_Msk                (1ul << I2S_STATUS_I2SINT_Pos)       /*!< I2S_T::STATUS: I2SINT Mask         */
N
N/*@}*/ /* end of group I2S_CONST */
N/*@}*/ /* end of group I2S */
N
N
N
N/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup PDMA Peripheral Direct Memory Access Controller (PDMA)
N    Memory Mapped Structure for PDMA Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PDMA_T::CSR
N * Offset: 0x00  PDMA Channel x Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PDMACEN   |PDMA Channel Enable
N * |        |          |Setting this bit to 1 enables PDMA operation.
N * |        |          |If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE
N * |        |          |state.
N * |        |          |Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.
N * |[1]     |SW_RST    |Software Engine Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal state machine, pointers and internal buffer.
N * |        |          |The contents of control register will not be cleared.
N * |        |          |This bit will be automatically cleared after few clock cycles.
N * |[3:2]   |MODE_SEL  |PDMA Mode Selection
N * |        |          |00 = Memory to Memory mode (Memory-to-Memory).
N * |        |          |01 = Peripheral to Memory mode (Peripheral-to-Memory).
N * |        |          |10 = Memory to Peripheral mode (Memory-to-Peripheral).
N * |[5:4]   |SAD_SEL   |Transfer Source Address Direction Selection
N * |        |          |00 = Transfer source address is increasing successively.
N * |        |          |01 = Reserved.
N * |        |          |10 = Transfer source address is fixed (This feature can be used when data where transferred
N * |        |          |from a single source to multiple destinations).
N * |        |          |11 = Reserved.
N * |[7:6]   |DAD_SEL   |Transfer Destination Address Direction Selection
N * |        |          |00 = Transfer destination address is increasing successively.
N * |        |          |01 = Reserved.
N * |        |          |10 = Transfer destination address is fixed.
N * |        |          |(This feature can be used when data where transferred from multiple sources to a single
N * |        |          |destination).
N * |        |          |11 = Reserved.
N * |[20:19] |APB_TWS   |Peripheral Transfer Width Selection
N * |        |          |00 = One word (32-bit) is transferred for every PDMA operation.
N * |        |          |01 = One byte (8-bit) is transferred for every PDMA operation.
N * |        |          |10 = One half-word (16-bit) is transferred for every PDMA operation.
N * |        |          |11 = Reserved.
N * |        |          |Note: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory
N * |        |          |mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).
N * |[23]    |TRIG_EN   |Trigger Enable
N * |        |          |0 = No effect.
N * |        |          |1 = PDMA data read or write transfer Enabled.
N * |        |          |Note: When PDMA transfer completed, this bit will be cleared automatically.
N * |        |          |If the bus error occurs, all PDMA transfer will be stopped.
N * |        |          |Software must reset all PDMA channel, and then trigger again.
N * @var PDMA_T::SAR
N * Offset: 0x04  PDMA Channel x Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_SAR  |PDMA Transfer Source Address Register
N * |        |          |This field indicates a 32-bit source address of PDMA.
N * |        |          |Note: The source address must be word alignment.
N * @var PDMA_T::DAR
N * Offset: 0x08  PDMA Channel x Destination Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_DAR  |PDMA Transfer Destination Address Register
N * |        |          |This field indicates a 32-bit destination address of PDMA.
N * |        |          |Note: The destination address must be word alignment
N * @var PDMA_T::BCR
N * Offset: 0x0C  PDMA Channel x Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDMA_BCR  |PDMA Transfer Byte Count Register
N * |        |          |This field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.
N * @var PDMA_T::POINT
N * Offset: 0x10  PDMA Channel x Internal buffer pointer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PDMA_POINT|PDMA Internal Buffer Pointer Register (Read Only)
N * |        |          |This field indicates the internal buffer pointer.
N * @var PDMA_T::CSAR
N * Offset: 0x14  PDMA Channel x Current Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_CSAR |PDMA Current Source Address Register (Read Only)
N * |        |          |This field indicates the source address where the PDMA transfer just occurred.
N * @var PDMA_T::CDAR
N * Offset: 0x18  PDMA Channel x Current Destination Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_CDAR |PDMA Current Destination Address Register (Read Only)
N * |        |          |This field indicates the destination address where the PDMA transfer just occurred.
N * @var PDMA_T::CBCR
N * Offset: 0x1C  PDMA Channel x Current Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDMA_CBCR |PDMA Current Byte Count Register (Read Only)
N * |        |          |This field indicates the current remained byte count of PDMA.
N * |        |          |Note: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".
N * @var PDMA_T::IER
N * Offset: 0x20  PDMA Channel x Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TABORT_IE |PDMA Read/Write Target Abort Interrupt Enable
N * |        |          |0 = Target abort interrupt generation Disabled during PDMA transfer.
N * |        |          |1 = Target abort interrupt generation Enabled during PDMA transfer.
N * |[1]     |BLKD_IE   |PDMA Block Transfer Done Interrupt Enable
N * |        |          |0 = Interrupt generator Disabled when PDMA transfer is done.
N * |        |          |1 = Interrupt generator Enabled when PDMA transfer is done.
N * @var PDMA_T::ISR
N * Offset: 0x24  PDMA Channel x Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TABORT_IF |PDMA Read/Write Target Abort Interrupt Flag
N * |        |          |Write 1 to clear this bit to 0.
N * |        |          |0 = No bus ERROR response received.
N * |        |          |1 = Bus ERROR response received.
N * |        |          |Note: This bit filed indicates bus master received ERROR response or not.
N * |        |          |If bus master received ERROR response, it means that target abort is happened.
N * |        |          |PDMA controller will stop transfer and respond this event to software then goes to IDLE
N * |        |          |state.
N * |        |          |When target abort occurred, software must reset PDMA, and then transfer those data again.
N * |[1]     |BLKD_IF   |PDMA Block Transfer Done Interrupt Flag
N * |        |          |This bit indicates that PDMA has finished all transfers.
N * |        |          |0 = Not finished.
N * |        |          |1 = Done.
N * |        |          |Write 1 to clear this bit to 0.
N * @var PDMA_T::SBUF
N * Offset: 0x80  PDMA Channel x Shared Buffer FIFO x Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_SBUF0|PDMA Shared Buffer FIFO 0 (Read Only)
N * |        |          |Each channel has its own 1 word internal buffer.
N */
N
N    __IO uint32_t CSR;           /* Offset: 0x00  PDMA Channel x Control Register                                    */
X    volatile uint32_t CSR;            
N    __IO uint32_t SAR;           /* Offset: 0x04  PDMA Channel x Source Address Register                             */
X    volatile uint32_t SAR;            
N    __IO uint32_t DAR;           /* Offset: 0x08  PDMA Channel x Destination Address Register                        */
X    volatile uint32_t DAR;            
N    __IO uint32_t BCR;           /* Offset: 0x0C  PDMA Channel x Transfer Byte Count Register                        */
X    volatile uint32_t BCR;            
N    __I  uint32_t POINT;         /* Offset: 0x10  PDMA Channel x Internal buffer pointer Register                    */
X    volatile const  uint32_t POINT;          
N    __I  uint32_t CSAR;          /* Offset: 0x14  PDMA Channel x Current Source Address Register                     */
X    volatile const  uint32_t CSAR;           
N    __I  uint32_t CDAR;          /* Offset: 0x18  PDMA Channel x Current Destination Address Register                */
X    volatile const  uint32_t CDAR;           
N    __I  uint32_t CBCR;          /* Offset: 0x1C  PDMA Channel x Current Transfer Byte Count Register                */
X    volatile const  uint32_t CBCR;           
N    __IO uint32_t IER;           /* Offset: 0x20  PDMA Channel x Interrupt Enable Register                           */
X    volatile uint32_t IER;            
N    __IO uint32_t ISR;           /* Offset: 0x24  PDMA Channel x Interrupt Status Register                           */
X    volatile uint32_t ISR;            
N    __I  uint32_t RESERVE[22];  
X    volatile const  uint32_t RESERVE[22];  
N    __I  uint32_t SBUF;          /* Offset: 0x80  PDMA Channel x Shared Buffer FIFO x Register                       */
X    volatile const  uint32_t SBUF;           
N
N} PDMA_T;
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PDMA_GCR_T::GCRCSR
N * Offset: 0x00  PDMA Global Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8]     |CLK0_EN   |PDMA Controller Channel 0 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[9]     |CLK1_EN   |PDMA Controller Channel 1 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[10]    |CLK2_EN   |PDMA Controller Channel 2 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[11]    |CLK3_EN   |PDMA Controller Channel 3 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[12]    |CLK4_EN   |PDMA Controller Channel 4 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[13]    |CLK5_EN   |PDMA Controller Channel 5 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[14]    |CLK6_EN   |PDMA Controller Channel 6 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[15]    |CLK7_EN   |PDMA Controller Channel 7 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[16]    |CLK8_EN   |PDMA Controller Channel 8 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[24]    |CRC_CLK_EN|CRC Controller Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * @var PDMA_GCR_T::PDSSR0
N * Offset: 0x04  PDMA Service Selection Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |SPI0_RXSEL|PDMA SPI0 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI0 RX.
N * |        |          |Software can change the channel RX setting by this field.
N * |        |          |For example, SPI0_RXSEL (PDMA_PDSSR0[3:0]) = 0110, that means SPI0_RX is connected to
N * |        |          |PDMA_CH6.
N * |        |          |0000: CH0
N * |        |          |0001: CH1
N * |        |          |0010: CH2
N * |        |          |0011: CH3
N * |        |          |0100: CH4
N * |        |          |0101: CH5
N * |        |          |0110: CH6
N * |        |          |0111: CH7
N * |        |          |1000: CH8
N * |        |          |Others : Reserved
N * |[7:4]   |SPI0_TXSEL|PDMA SPI0 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI0 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[11:8]  |SPI1_RXSEL|PDMA SPI1 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI1 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[15:12] |SPI1_TXSEL|PDMA SPI1 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI1 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[19:16] |SPI2_RXSEL|PDMA SPI2 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI2 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[23:20] |SPI2_TXSEL|PDMA SPI2 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI2 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[27:24] |SPI3_RXSEL|PDMA SPI3 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI3 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[31:28] |SPI3_TXSEL|PDMA SPI3 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI3 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * @var PDMA_GCR_T::PDSSR1
N * Offset: 0x08  PDMA Service Selection Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |UART0_RXSEL|PDMA UART0 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART0 RX.
N * |        |          |Software can change the channel RX setting by this field.
N * |        |          |For example, UART0_RXSEL (PDMA_PDSSR1[3:0]) = 0110, which means UART0_RX is connected to
N * |        |          |PDMA_CH6.
N * |        |          |0000: CH0
N * |        |          |0001: CH1
N * |        |          |0010: CH2
N * |        |          |0011: CH3
N * |        |          |0100: CH4
N * |        |          |0101: CH5
N * |        |          |0110: CH6
N * |        |          |0111: CH7
N * |        |          |1000: CH8
N * |        |          |Others : Reserved
N * |[7:4]   |UART0_TXSEL|PDMA UART0 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART0 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * |[11:8]  |UART1_RXSEL|PDMA UART1 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART1 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * |[15:12] |UART1_TXSEL|PDMA UART1 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART1 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * |[27:24] |ADC_RXSEL |PDMA ADC RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral ADC RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * @var PDMA_GCR_T::GCRISR
N * Offset: 0x0C  PDMA Global Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INTR0     |Interrupt Status Of Channel 0
N * |        |          |This bit is the interrupt status of PDMA channel0.
N * |        |          |Note: This bit is read only
N * |[1]     |INTR1     |Interrupt Status Of Channel 1
N * |        |          |This bit is the interrupt status of PDMA channel1.
N * |        |          |Note: This bit is read only
N * |[2]     |INTR2     |Interrupt Status Of Channel 2
N * |        |          |This bit is the interrupt status of PDMA channel2.
N * |        |          |Note: This bit is read only
N * |[3]     |INTR3     |Interrupt Status Of Channel 3
N * |        |          |This bit is the interrupt status of PDMA channel3.
N * |        |          |Note: This bit is read only
N * |[4]     |INTR4     |Interrupt Status Of Channel 4
N * |        |          |This bit is the interrupt status of PDMA channel4.
N * |        |          |Note: This bit is read only
N * |[5]     |INTR5     |Interrupt Status Of Channel 5
N * |        |          |This bit is the interrupt status of PDMA channel5.
N * |        |          |Note: This bit is read only
N * |[6]     |INTR6     |Interrupt Status Of Channel 6
N * |        |          |This bit is the interrupt status of PDMA channel6.
N * |        |          |Note: This bit is read only
N * |[7]     |INTR7     |Interrupt Status Of Channel 7
N * |        |          |This bit is the interrupt status of PDMA channel7.
N * |        |          |Note: This bit is read only
N * |[8]     |INTR8     |Interrupt Status Of Channel 8
N * |        |          |This bit is the interrupt status of PDMA channel8.
N * |        |          |Note: This bit is read only
N * |[16]    |INTRCRC   |Interrupt Status Of CRC Controller
N * |        |          |This bit is the interrupt status of CRC controller
N * |        |          |Note: This bit is read only
N * |[31]    |INTR      |Interrupt Status
N * |        |          |This bit is the interrupt status of PDMA controller.
N * |        |          |Note: This bit is read only
N * @var PDMA_GCR_T::PDSSR2
N * Offset: 0x10  PDMA Service Selection Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |I2S_RXSEL |PDMA I2S RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral I2S RX.
N * |        |          |Software can change the channel RX setting by this field.
N * |        |          |For example: I2S_RXSEL (PDMA_PDSSR2[3:0]) = 0110, that means I2S_RX is connected to
N * |        |          |PDMA_CH6.
N * |        |          |0000: CH0
N * |        |          |0001: CH1
N * |        |          |0010: CH2
N * |        |          |0011: CH3
N * |        |          |0100: CH4
N * |        |          |0101: CH5
N * |        |          |0110: CH6
N * |        |          |0111: CH7
N * |        |          |1000: CH8
N * |        |          |Others : Reserved
N * |[7:4]   |I2S_TXSEL |PDMA I2S TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral I2S TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as I2S_RXSEL (PDMA_PDSSR2[3:0]) field.
N * |        |          |Please refer to the explanation of I2S_RXSEL (PDMA_PDSSR2[3:0]).
N */
N
N    __IO uint32_t GCRCSR;        /* Offset: 0x00  PDMA Global Control Register                                       */
X    volatile uint32_t GCRCSR;         
N    __IO uint32_t PDSSR0;        /* Offset: 0x04  PDMA Service Selection Control Register 0                          */
X    volatile uint32_t PDSSR0;         
N    __IO uint32_t PDSSR1;        /* Offset: 0x08  PDMA Service Selection Control Register 1                          */
X    volatile uint32_t PDSSR1;         
N    __IO uint32_t GCRISR;        /* Offset: 0x0C  PDMA Global Interrupt Status Register                              */
X    volatile uint32_t GCRISR;         
N    __IO uint32_t PDSSR2;        /* Offset: 0x10  PDMA Service Selection Control Register 2                          */
X    volatile uint32_t PDSSR2;         
N
N} PDMA_GCR_T;
N
N
N
N/**
N    @addtogroup PDMA_CONST PDMA Bit Field Definition
N    Constant Definitions for PDMA Controller
N@{ */
N
N
N/* PDMA CSR Bit Field Definitions */
N#define PDMA_CSR_TRIG_EN_Pos                        23                              /*!< PDMA_T::CSR: TRIG_EN Position */
N#define PDMA_CSR_TRIG_EN_Msk                        (1ul << PDMA_CSR_TRIG_EN_Pos)   /*!< PDMA_T::CSR: TRIG_EN Mask */
N
N#define PDMA_CSR_APB_TWS_Pos                        19                              /*!< PDMA_T::CSR: APB_TWS Position */
N#define PDMA_CSR_APB_TWS_Msk                        (3ul << PDMA_CSR_APB_TWS_Pos)   /*!< PDMA_T::CSR: APB_TWS Mask */
N
N#define PDMA_CSR_DAD_SEL_Pos                        6                               /*!< PDMA_T::CSR: DAD_SEL Position */
N#define PDMA_CSR_DAD_SEL_Msk                        (3ul << PDMA_CSR_DAD_SEL_Pos)   /*!< PDMA_T::CSR: DAD_SEL Mask */
N
N#define PDMA_CSR_SAD_SEL_Pos                        4                               /*!< PDMA_T::CSR: SAD_SEL Position */
N#define PDMA_CSR_SAD_SEL_Msk                        (3ul << PDMA_CSR_SAD_SEL_Pos)   /*!< PDMA_T::CSR: SAD_SEL Mask */
N
N#define PDMA_CSR_MODE_SEL_Pos                       2                               /*!< PDMA_T::CSR: MODE_SEL Position */
N#define PDMA_CSR_MODE_SEL_Msk                       (3ul << PDMA_CSR_MODE_SEL_Pos)  /*!< PDMA_T::CSR: MODE_SEL Mask */
N
N#define PDMA_CSR_SW_RST_Pos                         1                               /*!< PDMA_T::CSR: SW_RST Position */
N#define PDMA_CSR_SW_RST_Msk                         (1ul << PDMA_CSR_SW_RST_Pos)    /*!< PDMA_T::CSR: SW_RST Mask */
N
N#define PDMA_CSR_PDMACEN_Pos                        0                               /*!< PDMA_T::CSR: PDMACEN Position */
N#define PDMA_CSR_PDMACEN_Msk                        (1ul << PDMA_CSR_PDMACEN_Pos)   /*!< PDMA_T::CSR: PDMACEN Mask */
N
N/* PDMA BCR Bit Field Definitions */
N#define PDMA_BCR_BCR_Pos                            0                               /*!< PDMA_T::BCR: BCR Position */
N#define PDMA_BCR_BCR_Msk                            (0xFFFFul << PDMA_BCR_BCR_Pos)  /*!< PDMA_T::BCR: BCR Mask */
N
N/* PDMA POINT Bit Field Definitions */
N#define PDMA_POINT_POINT_Pos                        0                               /*!< PDMA_T::POINT: POINT Position */
N#define PDMA_POINT_POINT_Msk                        (0xFul << PDMA_POINT_POINT_Pos) /*!< PDMA_T::POINT: POINT Mask */
N
N/* PDMA CBCR Bit Field Definitions */
N#define PDMA_CBCR_CBCR_Pos                          0                                   /*!< PDMA_T::CBCR: CBCR Position */
N#define PDMA_CBCR_CBCR_Msk                          (0xFFFFul << PDMA_CBCR_CBCR_Pos)    /*!< PDMA_T::CBCR: CBCR Mask */
N
N
N/* PDMA IER Bit Field Definitions */
N#define PDMA_IER_BLKD_IE_Pos                        1                               /*!< PDMA_T::IER: BLKD_IE Position */
N#define PDMA_IER_BLKD_IE_Msk                        (1ul << PDMA_IER_BLKD_IE_Pos)   /*!< PDMA_T::IER: BLKD_IE Mask */
N
N#define PDMA_IER_TABORT_IE_Pos                      0                               /*!< PDMA_T::IER: TABORT_IE Position */
N#define PDMA_IER_TABORT_IE_Msk                      (1ul << PDMA_IER_TABORT_IE_Pos) /*!< PDMA_T::IER: TABORT_IE Mask */
N
N/* PDMA ISR Bit Field Definitions */
N#define PDMA_ISR_BLKD_IF_Pos                        1                               /*!< PDMA_T::ISR: BLKD_IF Position */
N#define PDMA_ISR_BLKD_IF_Msk                        (1ul << PDMA_ISR_BLKD_IF_Pos)   /*!< PDMA_T::ISR: BLKD_IF Mask */
N
N#define PDMA_ISR_TABORT_IF_Pos                      0                               /*!< PDMA_T::ISR: TABORT_IF Position */
N#define PDMA_ISR_TABORT_IF_Msk                      (1ul << PDMA_ISR_TABORT_IF_Pos) /*!< PDMA_T::ISR: TABORT_IF Mask */
N
N/* PDMA GCRCSR Bit Field Definitions */
N#define PDMA_GCRCSR_CRC_CLK_EN_Pos                  24                                  /*!< PDMA_GCR_T::GCRCSR: CRC_CLK_EN Position */
N#define PDMA_GCRCSR_CRC_CLK_EN_Msk                  (1ul << PDMA_GCRCSR_CRC_CLK_EN_Pos) /*!< PDMA_GCR_T::GCRCSR: CRC_CLK_EN Mask */
N
N#define PDMA_GCRCSR_CLK8_EN_Pos                     16                                  /*!< PDMA_GCR_T::GCRCSR: CLK8_EN Position */
N#define PDMA_GCRCSR_CLK8_EN_Msk                     (1ul << PDMA_GCRCSR_CLK8_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK8_EN Mask */
N
N#define PDMA_GCRCSR_CLK7_EN_Pos                     15                                  /*!< PDMA_GCR_T::GCRCSR: CLK7_EN Position */
N#define PDMA_GCRCSR_CLK7_EN_Msk                     (1ul << PDMA_GCRCSR_CLK7_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK7_EN Mask */
N
N#define PDMA_GCRCSR_CLK6_EN_Pos                     14                                  /*!< PDMA_GCR_T::GCRCSR: CLK6_EN Position */
N#define PDMA_GCRCSR_CLK6_EN_Msk                     (1ul << PDMA_GCRCSR_CLK6_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK6_EN Mask */
N
N#define PDMA_GCRCSR_CLK5_EN_Pos                     13                                  /*!< PDMA_GCR_T::GCRCSR: CLK5_EN Position */
N#define PDMA_GCRCSR_CLK5_EN_Msk                     (1ul << PDMA_GCRCSR_CLK5_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK5_EN Mask */
N
N#define PDMA_GCRCSR_CLK4_EN_Pos                     12                                  /*!< PDMA_GCR_T::GCRCSR: CLK4_EN Position */
N#define PDMA_GCRCSR_CLK4_EN_Msk                     (1ul << PDMA_GCRCSR_CLK4_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK4_EN Mask */
N
N#define PDMA_GCRCSR_CLK3_EN_Pos                     11                                  /*!< PDMA_GCR_T::GCRCSR: CLK3_EN Position */
N#define PDMA_GCRCSR_CLK3_EN_Msk                     (1ul << PDMA_GCRCSR_CLK3_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK3_EN Mask */
N
N#define PDMA_GCRCSR_CLK2_EN_Pos                     10                                  /*!< PDMA_GCR_T::GCRCSR: CLK2_EN Position */
N#define PDMA_GCRCSR_CLK2_EN_Msk                     (1ul << PDMA_GCRCSR_CLK2_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK2_EN Mask */
N
N#define PDMA_GCRCSR_CLK1_EN_Pos                     9                                   /*!< PDMA_GCR_T::GCRCSR: CLK1_EN Position */
N#define PDMA_GCRCSR_CLK1_EN_Msk                     (1ul << PDMA_GCRCSR_CLK1_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK1_EN Mask */
N
N#define PDMA_GCRCSR_CLK0_EN_Pos                     8                                   /*!< PDMA_GCR_T::GCRCSR: CLK0_EN Position */
N#define PDMA_GCRCSR_CLK0_EN_Msk                     (1ul << PDMA_GCRCSR_CLK0_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK0_EN Mask */
N
N/* PDMA PDSSR0 Bit Field Definitions */
N#define PDMA_PDSSR0_SPI3_TXSEL_Pos                  28                                      /*!< PDMA_GCR_T::PDSSR0: SPI3_TXSEL Position */
N#define PDMA_PDSSR0_SPI3_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI3_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI3_RXSEL_Pos                  24                                      /*!< PDMA_GCR_T::PDSSR0: SPI3_RXSEL Position */
N#define PDMA_PDSSR0_SPI3_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI3_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI2_TXSEL_Pos                  20                                      /*!< PDMA_GCR_T::PDSSR0: SPI2_TXSEL Position */
N#define PDMA_PDSSR0_SPI2_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI2_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI2_RXSEL_Pos                  16                                      /*!< PDMA_GCR_T::PDSSR0: SPI2_RXSEL Position */
N#define PDMA_PDSSR0_SPI2_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI2_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI1_TXSEL_Pos                  12                                      /*!< PDMA_GCR_T::PDSSR0: SPI1_TXSEL Position */
N#define PDMA_PDSSR0_SPI1_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI1_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI1_RXSEL_Pos                  8                                       /*!< PDMA_GCR_T::PDSSR0: SPI1_RXSEL Position */
N#define PDMA_PDSSR0_SPI1_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI1_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI0_TXSEL_Pos                  4                                       /*!< PDMA_GCR_T::PDSSR0: SPI0_TXSEL Position */
N#define PDMA_PDSSR0_SPI0_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI0_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI0_RXSEL_Pos                  0                                       /*!< PDMA_GCR_T::PDSSR0: SPI0_RXSEL Position */
N#define PDMA_PDSSR0_SPI0_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI0_RXSEL Mask */
N
N/* PDMA PDSSR1 Bit Field Definitions */
N#define PDMA_PDSSR1_ADC_RXSEL_Pos                   24                                      /*!< PDMA_GCR_T::PDSSR1: ADC_RXSEL Position */
N#define PDMA_PDSSR1_ADC_RXSEL_Msk                   (0xFul << PDMA_PDSSR1_ADC_RXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR1: ADC_RXSEL Mask */
N
N#define PDMA_PDSSR1_UART1_TXSEL_Pos                 12                                      /*!< PDMA_GCR_T::PDSSR1: UART1_TXSEL Position */
N#define PDMA_PDSSR1_UART1_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_TXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART1_TXSEL Mask */
N
N#define PDMA_PDSSR1_UART1_RXSEL_Pos                 8                                       /*!< PDMA_GCR_T::PDSSR1: UART1_RXSEL Position */
N#define PDMA_PDSSR1_UART1_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_RXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART1_RXSEL Mask */
N
N#define PDMA_PDSSR1_UART0_TXSEL_Pos                 4                                       /*!< PDMA_GCR_T::PDSSR1: UART0_TXSEL Position */
N#define PDMA_PDSSR1_UART0_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_TXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART0_TXSEL Mask */
N
N#define PDMA_PDSSR1_UART0_RXSEL_Pos                 0                                       /*!< PDMA_GCR_T::PDSSR1: UART0_RXSEL Position */
N#define PDMA_PDSSR1_UART0_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_RXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART0_RXSEL Mask */
N
N/* PDMA GCRISR Bit Field Definitions */
N#define PDMA_GCRISR_INTR_Pos                        31                              /*!< PDMA_GCR_T::GCRISR: INTR Position */
N#define PDMA_GCRISR_INTR_Msk                        (1ul << PDMA_GCRISR_INTR_Pos)   /*!< PDMA_GCR_T::GCRISR: INTR Mask */
N
N#define PDMA_GCRISR_INTRCRC_Pos                     16                               /*!< PDMA_GCR_T::GCRISR: INTRCRC Position */
N#define PDMA_GCRISR_INTRCRC_Msk                     (1ul << PDMA_GCRISR_INTRCRC_Pos) /*!< PDMA_GCR_T::GCRISR: INTRCRC Mask */
N
N#define PDMA_GCRISR_INTR8_Pos                       8                               /*!< PDMA_GCR_T::GCRISR: INTR8 Position */
N#define PDMA_GCRISR_INTR8_Msk                       (1ul << PDMA_GCRISR_INTR8_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR8 Mask */
N
N#define PDMA_GCRISR_INTR7_Pos                       7                               /*!< PDMA_GCR_T::GCRISR: INTR7 Position */
N#define PDMA_GCRISR_INTR7_Msk                       (1ul << PDMA_GCRISR_INTR7_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR7 Mask */
N
N#define PDMA_GCRISR_INTR6_Pos                       6                               /*!< PDMA_GCR_T::GCRISR: INTR6 Position */
N#define PDMA_GCRISR_INTR6_Msk                       (1ul << PDMA_GCRISR_INTR6_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR6 Mask */
N
N#define PDMA_GCRISR_INTR5_Pos                       5                               /*!< PDMA_GCR_T::GCRISR: INTR5 Position */
N#define PDMA_GCRISR_INTR5_Msk                       (1ul << PDMA_GCRISR_INTR5_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR5 Mask */
N
N#define PDMA_GCRISR_INTR4_Pos                       4                               /*!< PDMA_GCR_T::GCRISR: INTR4 Position */
N#define PDMA_GCRISR_INTR4_Msk                       (1ul << PDMA_GCRISR_INTR4_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR4 Mask */
N
N#define PDMA_GCRISR_INTR3_Pos                       3                               /*!< PDMA_GCR_T::GCRISR: INTR3 Position */
N#define PDMA_GCRISR_INTR3_Msk                       (1ul << PDMA_GCRISR_INTR3_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR3 Mask */
N
N#define PDMA_GCRISR_INTR2_Pos                       2                               /*!< PDMA_GCR_T::GCRISR: INTR2 Position */
N#define PDMA_GCRISR_INTR2_Msk                       (1ul << PDMA_GCRISR_INTR2_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR2 Mask */
N
N#define PDMA_GCRISR_INTR1_Pos                       1                               /*!< PDMA_GCR_T::GCRISR: INTR1 Position */
N#define PDMA_GCRISR_INTR1_Msk                       (1ul << PDMA_GCRISR_INTR1_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR1 Mask */
N
N#define PDMA_GCRISR_INTR0_Pos                       0                               /*!< PDMA_GCR_T::GCRISR: INTR0 Position */
N#define PDMA_GCRISR_INTR0_Msk                       (1ul << PDMA_GCRISR_INTR0_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR0 Mask */
N
N/* PDMA PDSSR2 Bit Field Definitions */
N#define PDMA_PDSSR2_I2S_TXSEL_Pos                   4                                       /*!< PDMA_GCR_T::PDSSR2: I2S_TXSEL Position */
N#define PDMA_PDSSR2_I2S_TXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_TXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR2: I2S_TXSEL Mask */
N
N#define PDMA_PDSSR2_I2S_RXSEL_Pos                   0                                       /*!< PDMA_GCR_T::PDSSR2: I2S_RXSEL Position */
N#define PDMA_PDSSR2_I2S_RXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_RXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR2: I2S_RXSEL Mask */
N/*@}*/ /* end of group PDMA_CONST */
N/*@}*/ /* end of group PDMA */
N
N
N
N/*------------------------------ PS2 Controller ------------------------------*/
N/** @addtogroup PS2 PS2 Serial Interface(PS2)
N  Memory Mapped Structure for PS2 Serial Interface Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PS2_T::PS2CON
N * Offset: 0x00  PS/2 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PS2EN     |Enable PS/2 Device
N * |        |          |Enable PS/2 device controller
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |TXINTEN   |Enable Transmit Interrupt
N * |        |          |0 = Data transmit complete interrupt Disabled.
N * |        |          |1 = Data transmit complete interrupt Enabled.
N * |[2]     |RXINTEN   |Enable Receive Interrupt
N * |        |          |0 = Data receive complete interrupt Disabled.
N * |        |          |1 = Data receive complete interrupt Enabled.
N * |[6:3]   |TXFIFO_DEPTH|Transmit Data FIFO Depth
N * |        |          |There are 16 bytes buffer for data transmit.
N * |        |          |Software can define the FIFO depth from 1 to 16 bytes depends on application needs.
N * |        |          |0 = 1 byte.
N * |        |          |1 = 2 bytes.
N * |        |          |...
N * |        |          |14 = 15 bytes.
N * |        |          |15 = 16 bytes.
N * |[7]     |ACK       |Acknowledge Enable
N * |        |          |0 = Always send acknowledge to host at 12th clock for host to device communication.
N * |        |          |1 = If parity bit error or stop bit is not received correctly, acknowledge bit will not be
N * |        |          |sent to host at 12th clock.
N * |[8]     |CLRFIFO   |Clear TX FIFO
N * |        |          |Write 1 to this bit to terminate device to host transmission.
N * |        |          |The TXEMPTY(PS2STATUS[7]) bit will be set to 1 and pointer BYTEIDEX(PS2STATUS[11:8]) is
N * |        |          |reset to 0 regardless there is residue data in buffer or not.
N * |        |          |The buffer content is not been cleared.
N * |        |          |0 = Not active.
N * |        |          |1 = Clear FIFO.
N * |[9]     |OVERRIDE  |Software Override PS/2 CLK/DATA Pin State
N * |        |          |0 = PS2_CLK and PS2_DATA pins are controlled by internal state machine.
N * |        |          |1 = PS2_CLK and PS2_DATA pins are controlled by software.
N * |[10]    |FPS2CLK   |Force PS2CLK Line
N * |        |          |It forces PS2_CLK line high or low regardless of the internal state of the device controller
N * |        |          |if OVERRIDE(PS2CON[9]) is set to 1.
N * |        |          |0 = Force PS2_CLK line low.
N * |        |          |1 = Force PS2_CLK line high.
N * |[11]    |FPS2DAT   |Force PS2DATA Line
N * |        |          |It forces PS2_DATA high or low regardless of the internal state of the device controller if
N * |        |          |OVERRIDE (PS2CON[9]) is set to 1.
N * |        |          |0 = Force PS2_DATA low.
N * |        |          |1 = Force PS2_DATA high.
N * @var PS2_T::PS2TXDATA0
N * Offset: 0x04  PS/2 Transmit Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE
N * |        |          |state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2TXDATA1
N * Offset: 0x08  PS/2 Transmit Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE
N * |        |          |state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2TXDATA2
N * Offset: 0x0C  PS/2 Transmit Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE
N * |        |          |state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2TXDATA3
N * Offset: 0x10  PS/2 Transmit Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE
N * |        |          |state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2RXDATA
N * Offset: 0x14  PS/2 Receive Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |RXDATA    |Received Data
N * |        |          |For host to device communication, after acknowledge bit is sent, the received data is copied
N * |        |          |from receive shift register to PS2RXDATA register.
N * |        |          |CPU must read this register before next byte reception complete, otherwise the data will be
N * |        |          |overwritten and RXOVF(PS2STATUS[6]) bit will be set to 1.
N * @var PS2_T::PS2STATUS
N * Offset: 0x18  PS/2 Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PS2CLK    |CLK Pin State
N * |        |          |This bit reflects the status of the PS2_CLK line after synchronizing.
N * |[1]     |PS2DATA   |DATA Pin State
N * |        |          |This bit reflects the status of the PS2_DATA line after synchronizing and sampling.
N * |[2]     |FRAMERR   |Frame Error
N * |        |          |For host to device communication, this bit sets to 1 if STOP bit (logic 1) is not received.
N * |        |          |If frame error occurs, the PS/2_DATA line may keep at low state after 12th clock.
N * |        |          |At this moment, software overrides PS2_CLK to send clock till PS2_DATA release to high
N * |        |          |state.
N * |        |          |After that, device sends a "Resend" command to host.
N * |        |          |0 = No frame error.
N * |        |          |1 = Frame error occur.
N * |        |          |Write 1 to clear this bit.
N * |[3]     |RXPARITY  |Received Parity
N * |        |          |This bit reflects the parity bit for the last received data byte (odd parity).
N * |        |          |This bit is read only.
N * |[4]     |RXBUSY    |Receive Busy
N * |        |          |This bit indicates that the PS/2 device is currently receiving data.
N * |        |          |0 = Idle.
N * |        |          |1 = Currently receiving data.
N * |        |          |This bit is read only.
N * |[5]     |TXBUSY    |Transmit Busy
N * |        |          |This bit indicates that the PS/2 device is currently sending data.
N * |        |          |0 = Idle.
N * |        |          |1 = Currently sending data.
N * |        |          |This bit is read only.
N * |[6]     |RXOVF     |RX Buffer Overwrite
N * |        |          |0 = No overwrite.
N * |        |          |1 = Data in PS2RXDATA register is overwritten by new received data.
N * |        |          |Write 1 to clear this bit.
N * |[7]     |TXEMPTY   |TX FIFO Empty
N * |        |          |When software writes data to PS2TXDATA0-3, the TXEMPTY bit is cleared to 0 immediately if
N * |        |          |PS2EN(PS2CON[0]) is enabled.
N * |        |          |When transmitted data byte number is equal to FIFODEPTH(PS2CON[6:3]) then TXEMPTY bit is set
N * |        |          |to 1.
N * |        |          |0 = There is data to be transmitted.
N * |        |          |1 = FIFO is empty.
N * |        |          |This bit is read only.
N * |[11:8]  |BYTEIDX   |Byte Index
N * |        |          |It indicates which data byte in transmit data shift register.
N * |        |          |When all data in FIFO is transmitted and it will be cleared to 0.
N * |        |          |This bit is read only.
N * |        |          |BYTEIDX,    DATA Transmit , BYTEIDX,    DATA Transmit
N * |        |          |0000   , PS2TXDATA0[ 7: 0], 1000   , PS2TXDATA2[ 7: 0],
N * |        |          |0001   , PS2TXDATA0[15: 8], 1001   , PS2TXDATA2[15: 8],
N * |        |          |0010   , PS2TXDATA0[23:16], 1010   , PS2TXDATA2[23:16],
N * |        |          |0011   , PS2TXDATA0[31:24], 1011   , PS2TXDATA2[31:24],
N * |        |          |0100   , PS2TXDATA1[ 7: 0], 1100   , PS2TXDATA3[ 7: 0],
N * |        |          |0101   , PS2TXDATA1[15: 8], 1101   , PS2TXDATA3[15: 8],
N * |        |          |0110   , PS2TXDATA1[23:16], 1110   , PS2TXDATA3[23:16],
N * |        |          |0111   , PS2TXDATA1[31:24], 1111   , PS2TXDATA3[31:24],
N * @var PS2_T::PS2INTID
N * Offset: 0x1C  PS/2 Interrupt Identification Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXINT     |Receive Interrupt
N * |        |          |This bit is set to 1 when acknowledge bit is sent for Host to device communication.
N * |        |          |Interrupt occurs if RXINTEN(PS2CON[2]) bit is set to 1.
N * |        |          |0 = No interrupt.
N * |        |          |1 = Receive interrupt occurs.
N * |        |          |Write 1 to clear this bit to 0.
N * |[1]     |TXINT     |Transmit Interrupt
N * |        |          |This bit is set to 1 after STOP bit is transmitted.
N * |        |          |Interrupt occur if TXINTEN(PS2CON[1]) bit is set to 1.
N * |        |          |0 = No interrupt.
N * |        |          |1 = Transmit interrupt occurs.
N * |        |          |Write 1 to clear this bit to 0.
N */
N
N    __IO uint32_t PS2CON;        /* Offset: 0x00  PS/2 Control Register                                              */
X    volatile uint32_t PS2CON;         
N    __IO uint32_t PS2TXDATA0;    /* Offset: 0x04  PS/2 Transmit Data Register 0                                      */
X    volatile uint32_t PS2TXDATA0;     
N    __IO uint32_t PS2TXDATA1;    /* Offset: 0x08  PS/2 Transmit Data Register 1                                      */
X    volatile uint32_t PS2TXDATA1;     
N    __IO uint32_t PS2TXDATA2;    /* Offset: 0x0C  PS/2 Transmit Data Register 2                                      */
X    volatile uint32_t PS2TXDATA2;     
N    __IO uint32_t PS2TXDATA3;    /* Offset: 0x10  PS/2 Transmit Data Register 3                                      */
X    volatile uint32_t PS2TXDATA3;     
N    __IO uint32_t PS2RXDATA;     /* Offset: 0x14  PS/2 Receive Data Register                                         */
X    volatile uint32_t PS2RXDATA;      
N    __IO uint32_t PS2STATUS;     /* Offset: 0x18  PS/2 Status Register                                               */
X    volatile uint32_t PS2STATUS;      
N    __IO uint32_t PS2INTID;      /* Offset: 0x1C  PS/2 Interrupt Identification Register                             */
X    volatile uint32_t PS2INTID;       
N
N} PS2_T;
N
N
N
N
N/**
N    @addtogroup PS2_CONST PS2 Bit Field Definition
N    Constant Definitions for PS2 Controller
N@{ */
N
N/* PS2 PS2CON Bit Field Definitions */
N#define PS2_PS2CON_PS2EN_Pos                       0                                        /*!< PS2_T::PS2CON: PS2EN Position */
N#define PS2_PS2CON_PS2EN_Msk                       (1ul << PS2_PS2CON_PS2EN_Pos)            /*!< PS2_T::PS2CON: PS2EN Mask */
N
N#define PS2_PS2CON_TXINTEN_Pos                     1                                        /*!< PS2_T::PS2CON: TXINTEN Position */
N#define PS2_PS2CON_TXINTEN_Msk                     (1ul << PS2_PS2CON_TXINTEN_Pos)          /*!< PS2_T::PS2CON: TXINTEN Mask */
N
N#define PS2_PS2CON_RXINTEN_Pos                     2                                        /*!< PS2_T::PS2CON: RXINTEN Position */
N#define PS2_PS2CON_RXINTEN_Msk                     (1ul << PS2_PS2CON_RXINTEN_Pos)          /*!< PS2_T::PS2CON: RXINTEN Mask */
N
N#define PS2_PS2CON_TXFIFO_DEPTH_Pos                3                                        /*!< PS2_T::PS2CON: TXFIFO_DEPTH Position */
N#define PS2_PS2CON_TXFIFO_DEPTH_Msk                (0xFul << PS2_PS2CON_TXFIFO_DEPTH_Pos)   /*!< PS2_T::PS2CON: TXFIFO_DEPTH Mask */
N
N#define PS2_PS2CON_ACK_Pos                         7                                        /*!< PS2_T::PS2CON: ACK Position */
N#define PS2_PS2CON_ACK_Msk                         (1ul << PS2_PS2CON_ACK_Pos)              /*!< PS2_T::PS2CON: ACK Mask */
N
N#define PS2_PS2CON_CLRFIFO_Pos                     8                                        /*!< PS2_T::PS2CON: CLRFIFO Position */
N#define PS2_PS2CON_CLRFIFO_Msk                     (1ul << PS2_PS2CON_CLRFIFO_Pos)          /*!< PS2_T::PS2CON: CLRFIFO Mask */
N
N#define PS2_PS2CON_OVERRIDE_Pos                    9                                        /*!< PS2_T::PS2CON: OVERRIDE Position */
N#define PS2_PS2CON_OVERRIDE_Msk                    (1ul << PS2_PS2CON_OVERRIDE_Pos)         /*!< PS2_T::PS2CON: OVERRIDE Mask */
N
N#define PS2_PS2CON_FPS2CLK_Pos                     10                                       /*!< PS2_T::PS2CON: FPS2CLK Position */
N#define PS2_PS2CON_FPS2CLK_Msk                     (1ul << PS2_PS2CON_FPS2CLK_Pos)          /*!< PS2_T::PS2CON: FPS2CLK Mask */
N
N#define PS2_PS2CON_FPS2DAT_Pos                     11                                       /*!< PS2_T::PS2CON: FPS2DAT Position */
N#define PS2_PS2CON_FPS2DAT_Msk                     (1ul << PS2_PS2CON_FPS2DAT_Pos)          /*!< PS2_T::PS2CON: FPS2DAT Mask */
N
N/* PS/2 PS2RXDATA Bit Field Definitions */
N#define PS2_PS2RXDATA_RXDATA_Pos                   0                                        /*!< PS2_T::PS2RXDATA: RXDATA Position */
N#define PS2_PS2RXDATA_RXDATA_Msk                   (0xFFul << PS2_PS2RXDATA_RXDATA_Pos)     /*!< PS2_T::PS2RXDATA: RXDATA Mask */
N
N/* PS/2 PS2STATUS Bit Field Definitions */
N#define PS2_PS2STATUS_PS2CLK_Pos                   0                                        /*!< PS2_T::PS2STATUS: PS2CLK Position */
N#define PS2_PS2STATUS_PS2CLK_Msk                   (1ul << PS2_PS2STATUS_PS2CLK_Pos)        /*!< PS2_T::PS2STATUS: PS2CLK Mask */
N
N#define PS2_PS2STATUS_PS2DATA_Pos                  1                                        /*!< PS2_T::PS2STATUS: PS2DATA Position */
N#define PS2_PS2STATUS_PS2DATA_Msk                  (1ul << PS2_PS2STATUS_PS2DATA_Pos)       /*!< PS2_T::PS2STATUS: PS2DATA Mask */
N
N#define PS2_PS2STATUS_FRAMERR_Pos                  2                                        /*!< PS2_T::PS2STATUS: FRAMERR Position */
N#define PS2_PS2STATUS_FRAMERR_Msk                  (1ul << PS2_PS2STATUS_FRAMERR_Pos)       /*!< PS2_T::PS2STATUS: FRAMERR Mask */
N
N#define PS2_PS2STATUS_RXPARITY_Pos                 3                                        /*!< PS2_T::PS2STATUS: RXPARITY Position */
N#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos)      /*!< PS2_T::PS2STATUS: RXPARITY Mask */
N
N#define PS2_PS2STATUS_RXBUSY_Pos                   4                                        /*!< PS2_T::PS2STATUS: RXBUSY Position */
N#define PS2_PS2STATUS_RXBUSY_Msk                   (1ul << PS2_PS2STATUS_RXBUSY_Pos)        /*!< PS2_T::PS2STATUS: RXBUSY Mask */
N
N#define PS2_PS2STATUS_TXBUSY_Pos                   5                                        /*!< PS2_T::PS2STATUS: TXBUSY Position */
N#define PS2_PS2STATUS_TXBUSY_Msk                   (1ul << PS2_PS2STATUS_TXBUSY_Pos)        /*!< PS2_T::PS2STATUS: TXBUSY Mask */
N
N#define PS2_PS2STATUS_RXOVF_Pos                    6                                        /*!< PS2_T::PS2STATUS: RXOVF Position */
N#define PS2_PS2STATUS_RXOVF_Msk                    (1ul << PS2_PS2STATUS_RXOVF_Pos)         /*!< PS2_T::PS2STATUS: RXOVF Mask */
N
N#define PS2_PS2STATUS_TXEMPTY_Pos                  7                                        /*!< PS2_T::PS2STATUS: TXEMPTY Position */
N#define PS2_PS2STATUS_TXEMPTY_Msk                  (1ul << PS2_PS2STATUS_TXEMPTY_Pos)       /*!< PS2_T::PS2STATUS: TXEMPTY Mask */
N
N#define PS2_PS2STATUS_BYTEIDX_Pos                  8                                        /*!< PS2_T::PS2STATUS: BYTEIDX Position */
N#define PS2_PS2STATUS_BYTEIDX_Msk                  (0xFul << PS2_PS2STATUS_BYTEIDX_Pos)     /*!< PS2_T::PS2STATUS: BYTEIDX Mask */
N
N/* PS/2 PS2INTID Bit Field Definitions */
N#define PS2_PS2INTID_RXINT_Pos                     0                                        /*!< PS2_T::PS2INTID: RXINT Position */
N#define PS2_PS2INTID_RXINT_Msk                     (1ul << PS2_PS2INTID_RXINT_Pos)          /*!< PS2_T::PS2INTID: RXINT Mask */
N                                                                                                    
N#define PS2_PS2INTID_TXINT_Pos                     1                                        /*!< PS2_T::PS2INTID: TXINT Position */
N#define PS2_PS2INTID_TXINT_Msk                     (1ul << PS2_PS2INTID_TXINT_Pos)          /*!< PS2_T::PS2INTID: TXINT Mask */
N/*@}*/ /* end of group PS2_CONST */
N/*@}*/ /* end of group PS2 */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller (PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PWM_T::PPR
N * Offset: 0x00  PWM Prescaler Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits     |Field     |Descriptions
N * | :----:  | :----:   | :---- |
N * |[7:0]    |CP01      |Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)
N * |         |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer
N * |         |          |If CP01=0, then the clock prescaler 0 output clock will be stopped.
N * |         |          |So corresponding PWM-timer will also be stopped.
N * |[15:8]   |CP23      |Clock Prescaler 2 (PWM-Timer2 / 3 For Group A And PWM-Timer 6 / 7 For Group B)
N * |         |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer
N * |         |          |If CP23=0, then the clock prescaler 2 output clock will be stopped.
N * |         |          |So corresponding PWM-timer will also be stopped.
N * |[23:16]  |DZI01     |Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |         |          |These 8-bit determine the Dead-zone length.
N * |        |          |The unit time of Dead-zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK (where
N * |        |          |xy could be 01 or 45, depends on selected PWM channel.).
N * |[31:24]  |DZI23     |Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |         |          |These 8-bit determine the Dead-zone length.
N * |        |          |The unit time of Dead-zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK (where
N * |        |          |xy could be 23 or 67, depends on selected PWM channel.).
N * @var PWM_T::CSR
N * Offset: 0x04  PWM Clock Source Divider Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits      |Field     |Descriptions
N * | :----:   | :----:   | :---- |
N * |[2:0]     |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |(Table is the same as CSR3)
N * |[6:4]     |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |(Table is the same as CSR3)
N * |[10:8]    |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |(Table is the same as CSR3)
N * |[14:12]   |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |CSRx[2:0] = Input clock divider
N * |          |          |100 = 1
N * |          |          |011 = 16
N * |          |          |010 = 8
N * |          |          |001 = 4
N * |          |          |000 = 2
N * @var PWM_T::PCR
N * Offset: 0x08  PWM Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits     |Field         |Descriptions
N * | :----:  | :----:       | :---- |
N * |[0]      |CH0EN         |PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = The corresponding PWM-Timer stops running.
N * |         |              |1 = The corresponding PWM-Timer starts running.
N * |[1]      |CH0PINV       |PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = PWM0 output polar inverse Disabled.
N * |         |              |1 = PWM0 output polar inverse Enabled.
N * |[2]      |CH0INV        |PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = Inverter Disabled.
N * |         |              |1 = Inverter Enabled.
N * |[3]      |CH0MOD        |PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.
N * |[4]      |DZEN01        |Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |         |              |0 = Disabled.
N * |         |              |1 = Enabled.
N * |        |          |Note: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary
N * |        |          |pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM
N * |        |          |group B.
N * |[5]      |DZEN23        |Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |         |              |0 = Disabled.
N * |         |              |1 = Enabled.
N * |        |          |Note: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary
N * |        |          |pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM
N * |        |          |group B.
N * |[8]      |CH1EN         |PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = Corresponding PWM-Timer Stopped.
N * |         |              |1 = Corresponding PWM-Timer Start Running.
N * |[9]      |CH1PINV       |PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = PWM1 output polar inverse Disabled.
N * |         |              |1 = PWM1 output polar inverse Enabled.
N * |[10]     |CH1INV        |PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = Inverter Disable.
N * |         |              |1 = Inverter Enable.
N * |[11]     |CH1MOD        |PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.
N * |[16]     |CH2EN         |PWM-Timer 2 Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = Corresponding PWM-Timer Stopped.
N * |         |              |1 = Corresponding PWM-Timer Start Running.
N * |[17]     |CH2PINV       |PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = PWM2 output polar inverse Disabled.
N * |         |              |1 = PWM2 output polar inverse Enabled.
N * |[18]     |CH2INV        |PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = Inverter Disabled.
N * |         |              |1 = Inverter Enabled.
N * |[19]     |CH2MOD        |PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.
N * |[24]     |CH3EN         |PWM-Timer 3 Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = Corresponding PWM-Timer Stopped.
N * |         |              |1 = Corresponding PWM-Timer Start Running.
N * |[25]     |CH3PINV       |PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = PWM3 output polar inverse Disable.
N * |         |              |1 = PWM3 output polar inverse Enable.
N * |[26]     |CH3INV        |PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = Inverter Disabled.
N * |         |              |1 = Inverter Enabled.
N * |[27]     |CH3MOD        |PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.
N * |[30]     |PWM01TYPE     |PWM01 Aligned Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |         |              |0 = Edge-aligned type.
N * |         |              |1 = Center-aligned type.
N * |[31]     |PWM23TYPE     |PWM23 Aligned Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |         |              |0 = Edge-aligned type.
N * |         |              |1 = Center-aligned type.
N * @var PWM_T::CNR0
N * Offset: 0x0C  PWM Counter Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR0
N * Offset: 0x0C  PWM Counter Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::PDR0
N * Offset: 0x14  PWM Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::CNR1
N * Offset: 0x18  PWM Counter Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR1
N * Offset: 0x1C  PWM Comparator Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMRx      |PWM Comparator Register
N * |        |          |CMR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR1
N * Offset: 0x20  PWM Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::CNR2
N * Offset: 0x24  PWM Counter Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR2
N * Offset: 0x28  PWM Comparator Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMRx      |PWM Comparator Register
N * |        |          |CMR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR2
N * Offset: 0x2C  PWM Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::CNR3
N * Offset: 0x30  PWM Counter Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR3
N * Offset: 0x34  PWM Comparator Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMRx      |PWM Comparator Register
N * |        |          |CMR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR3
N * Offset: 0x38  PWM Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::PBCR
N * Offset: 0x3C  PWM Backward Compatible Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BCn       |PWM Backward Compatible Register
N * |        |          |0 = Configure write 0 to clear CFLRI0~3 and CRLRI0~3.
N * |        |          |1 = Configure write 1 to clear CFLRI0~3 and CRLRI0~3.
N * |        |          |Refer to the CCR0/CCR2 register bit 6, 7, 22, 23 description
N * |        |          |Note: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being
N * |        |          |cleared when writing CCR0/CCR2.
N * @var PWM_T::PIER
N * Offset: 0x40  PWM Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWMIE0    |PWM Channel 0 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |PWMIE1    |PWM Channel 1 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[2]     |PWMIE2    |PWM Channel 2 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[3]     |PWMIE3    |PWM Channel 3 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[8]     |PWMDIE0   |PWM Channel 0 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[9]     |PWMDIE1   |PWM Channel 1 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[10]    |PWMDIE2   |PWM Channel 2 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[11]    |PWMDIE3   |PWM Channel 3 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[16]    |INT01TYPE |PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |        |          |0 = PWMIFn will be set if PWM counter underflow.
N * |        |          |1 = PWMIFn will be set if PWM counter matches CNRn register.
N * |        |          |Note: This bit is effective when PWM in Center-aligned type only.
N * |[17]    |INT23TYPE |PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |        |          |0 = PWMIFn will be set if PWM counter underflow.
N * |        |          |1 = PWMIFn will be set if PWM counter matches CNRn register.
N * |        |          |Note: This bit is effective when PWM in Center-aligned type only.
N * @var PWM_T::PIIR
N * Offset: 0x44  PWM Interrupt Indication Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWMIF0    |PWM Channel 0 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend
N * |        |          |on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[1]     |PWMIF1    |PWM Channel 1 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend
N * |        |          |on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[2]     |PWMIF2    |PWM Channel 2 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend
N * |        |          |on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[3]     |PWMIF3    |PWM Channel 3 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend
N * |        |          |on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[8]     |PWMDIF0   |PWM Channel 0 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * |[9]     |PWMDIF1   |PWM Channel 1 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * |[10]    |PWMDIF2   |PWM Channel 2 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * |[11]    |PWMDIF3   |PWM Channel 3 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * @var PWM_T::CCR0
N * Offset: 0x50  PWM Capture Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INV0      |Channel 0 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[1]     |CRL_IE0   |Channel 0 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will
N * |        |          |issue an Interrupt.
N * |[2]     |CFL_IE0   |Channel 0 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will
N * |        |          |issue an Interrupt.
N * |[3]     |CAPCH0EN  |Channel 0 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 0 Disabled.
N * |        |          |1 = Capture function on PWM group channel 0 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and
N * |        |          |CFLR (Falling latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0
N * |        |          |Interrupt.
N * |[4]     |CAPIF0    |Channel 0 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0 = 1), a rising transition
N * |        |          |occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition
N * |        |          |will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled
N * |        |          |(CFL_IE0 = 1).
N * |        |          |Write 1 to clear this bit to 0.
N * |[6]     |CRLRI0    |CRLR0 Latched Indicator Bit
N * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear
N * |        |          |this bit to 0 if the BCn bit is 1.
N * |[7]     |CFLRI0    |CFLR0 Latched Indicator Bit
N * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear
N * |        |          |this bit to0 if BCn bit is 1.
N * |[16]    |INV1      |Channel 1 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[17]    |CRL_IE1   |Channel 1 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will
N * |        |          |issue an Interrupt.
N * |[18]    |CFL_IE1   |Channel 1 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will
N * |        |          |issue an Interrupt.
N * |[19]    |CAPCH1EN  |Channel 1 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 1 Disabled.
N * |        |          |1 = Capture function on PWM group channel 1 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR
N * |        |          |(Falling latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1
N * |        |          |Interrupt.
N * |[20]    |CAPIF1    |Channel 1 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1 = 1), a rising transition
N * |        |          |occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition
N * |        |          |will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled
N * |        |          |(CFL_IE1 = 1).
N * |        |          |Write 1 to clear this bit to 0.
N * |[22]    |CRLRI1    |CRLR1 Latched Indicator Bit
N * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to0 if BCn bit is 1.
N * |[23]    |CFLRI1    |CFLR1 Latched Indicator Bit
N * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to 0 if BCn bit is 1.
N * @var PWM_T::CCR2
N * Offset: 0x54  PWM Capture Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INV2      |Channel 2 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[1]     |CRL_IE2   |Channel 2 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will
N * |        |          |issue an Interrupt.
N * |[2]     |CFL_IE2   |Channel 2 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will
N * |        |          |issue an Interrupt.
N * |[3]     |CAPCH2EN  |Channel 2 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 2 Disabled.
N * |        |          |1 = Capture function on PWM group channel 2 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and
N * |        |          |CFLR (Falling latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2
N * |        |          |Interrupt.
N * |[4]     |CAPIF2    |Channel 2 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition
N * |        |          |occurs at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition
N * |        |          |will cause CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled
N * |        |          |(CFL_IE2=1).
N * |        |          |Write 1 to clear this bit to 0
N * |[6]     |CRLRI2    |CRLR2 Latched Indicator Bit
N * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear
N * |        |          |this bit to 0 if the BCn bit is 1.
N * |[7]     |CFLRI2    |CFLR2 Latched Indicator Bit
N * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to 0 if the BCn bit is 1.
N * |[16]    |INV3      |Channel 3 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[17]    |CRL_IE3   |Channel 3 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will
N * |        |          |issue an Interrupt.
N * |[18]    |CFL_IE3   |Channel 3 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will
N * |        |          |issue an Interrupt.
N * |[19]    |CAPCH3EN  |Channel 3 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 3 Disabled.
N * |        |          |1 = Capture function on PWM group channel 3 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR
N * |        |          |(Falling latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3
N * |        |          |Interrupt.
N * |[20]    |CAPIF3    |Channel 3 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition
N * |        |          |occurs at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition
N * |        |          |will cause CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled
N * |        |          |(CFL_IE3=1).
N * |        |          |Write 1 to clear this bit to 0
N * |[22]    |CRLRI3    |CRLR3 Latched Indicator Bit
N * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear
N * |        |          |this bit to 0 if the BCn bit is 1.
N * |[23]    |CFLRI3    |CFLR3 Latched Indicator Bit
N * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear
N * |        |          |this bit to 0 if the BCn bit is 1.
N * @var PWM_T::CRLR0
N * Offset: 0x58  PWM Capture Rising Latch Register (Channel 0)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR0
N * Offset: 0x5C  PWM Capture Falling Latch Register (Channel 0)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR1
N * Offset: 0x60  PWM Capture Rising Latch Register (Channel 1)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR1
N * Offset: 0x64  PWM Capture Falling Latch Register (Channel 1)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR2
N * Offset: 0x68  PWM Capture Rising Latch Register (Channel 2)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR2
N * Offset: 0x6C  PWM Capture Falling Latch Register (Channel 2)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR3
N * Offset: 0x70  PWM Capture Rising Latch Register (Channel 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR3
N * Offset: 0x74  PWM Capture Falling Latch Register (Channel 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CAPENR
N * Offset: 0x78  PWM Capture Input 0~3 Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CINEN0    |Channel 0 Capture Input Enable
N * |        |          |0 = PWM Channel 0 capture input path Disabled.
N * |        |          |The input of PWM channel 0 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 0 capture input path Enabled.
N * |        |          |The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM0.
N * |[1]     |CINEN1    |Channel 1 Capture Input Enable
N * |        |          |0 = PWM Channel 1 capture input path Disabled.
N * |        |          |The input of PWM channel 1 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 1 capture input path Enabled.
N * |        |          |The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM1.
N * |[2]     |CINEN2    |Channel 2 Capture Input Enable
N * |        |          |0 = PWM Channel 2 capture input path Disabled.
N * |        |          |The input of PWM channel 2 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 2 capture input path Enabled.
N * |        |          |The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM2.
N * |[3]     |CINEN3    |Channel 3 Capture Input Enable
N * |        |          |0 = PWM Channel 3 capture input path Disabled.
N * |        |          |The input of PWM channel 3 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 3 capture input path Enabled.
N * |        |          |The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM3.
N * @var PWM_T::POE
N * Offset: 0x7C  PWM Output Enable for Channel 0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |POE0      |Channel 0 Output Enable Register
N * |        |          |0 = PWM channel 0 output to pin Disabled.
N * |        |          |1 = PWM channel 0 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * |[1]     |POE1      |Channel 1 Output Enable Register
N * |        |          |0 = PWM channel 1 output to pin Disabled.
N * |        |          |1 = PWM channel 1 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * |[2]     |POE2      |Channel 2 Output Enable Register
N * |        |          |0 = PWM channel 2 output to pin Disabled.
N * |        |          |1 = PWM channel 2 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * |[3]     |POE3      |Channel 3 Output Enable Register
N * |        |          |0 = PWM channel 3 output to pin Disabled.
N * |        |          |1 = PWM channel 3 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * @var PWM_T::TCON
N * Offset: 0x80  PWM Trigger Control for Channel 0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0TEN   |Channel 0 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 0 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 0 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set
N * |        |          |to 1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * |[1]     |PWM1TEN   |Channel 1 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 1 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 1 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set
N * |        |          |to 1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * |[2]     |PWM2TEN   |Channel 2 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 2 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 2 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set
N * |        |          |to 1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * |[3]     |PWM3TEN   |Channel 3 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 3 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 3 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set
N * |        |          |to 1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * @var PWM_T::TSTATUS
N * Offset: 0x84  PWM Trigger Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0TF    |Channel 0 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up
N * |        |          |counts to CNR if PWM0TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[1]     |PWM1TF    |Channel 1 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up
N * |        |          |count to CNR if PWM1TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[2]     |PWM2TF    |Channel 2 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up
N * |        |          |count to CNR if PWM2TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[3]     |PWM3TF    |Channel 3 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up
N * |        |          |count to CNR if PWM3TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * @var PWM_T::SYNCBUSY0
N * Offset: 0x88  PWM0 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a
N * |        |          |busy time to update these values completely because PWM clock may be different from system
N * |        |          |clock domain.
N * |        |          |Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0
N * |        |          |operation mode (PCR[3]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode
N * |        |          |(PCR[3]) and will be cleared by hardware automatically when PWM update these value
N * |        |          |completely.
N * @var PWM_T::SYNCBUSY1
N * Offset: 0x8C  PWM1 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have
N * |        |          |a busy time to update these values completely because PWM clock may be different from system
N * |        |          |clock domain.
N * |        |          |Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1
N * |        |          |operation mode (PCR[11]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode
N * |        |          |(PCR[11]) and will be cleared by hardware automatically when PWM update these value
N * |        |          |completely.
N * @var PWM_T::SYNCBUSY2
N * Offset: 0x90  PWM2 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When Software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]), PWM will have a
N * |        |          |busy time to update these values completely because PWM clock may be different from system
N * |        |          |clock domain.
N * |        |          |Software needs to check this busy status before writing CNR2/CMR2/PPR or switching PWM2
N * |        |          |operation mode (PCR[19]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when software writes CNR2/CMR2/PPR or switch PWM2 operation mode
N * |        |          |(PCR[19]) and will be cleared by hardware automatically when PWM update these value
N * |        |          |completely.
N * @var PWM_T::SYNCBUSY3
N * Offset: 0x94  PWM3 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]), PWM will have a
N * |        |          |busy time to update these values completely because PWM clock may be different from system
N * |        |          |clock domain.
N * |        |          |Software need to check this busy status before writing CNR3/CMR3/PPR or switching PWM3
N * |        |          |operation mode (PCR[27]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when Software writes CNR3/CMR3/PPR or switch PWM3 operation mode
N * |        |          |(PCR[27]) and will be cleared by hardware automatically when PWM update these value
N * |        |          |completely.
N */
N
N    __IO uint32_t PPR;           /* Offset: 0x00  PWM Prescaler Register                                             */
X    volatile uint32_t PPR;            
N    __IO uint32_t CSR;           /* Offset: 0x04  PWM Clock Source Divider Select Register                           */
X    volatile uint32_t CSR;            
N    __IO uint32_t PCR;           /* Offset: 0x08  PWM Control Register                                               */
X    volatile uint32_t PCR;            
N    __IO uint32_t CNR0;          /* Offset: 0x0C  PWM Counter Register 0                                             */
X    volatile uint32_t CNR0;           
N    __IO uint32_t CMR0;          /* Offset: 0x10  PWM Comparator Register 0                                          */
X    volatile uint32_t CMR0;           
N    __I  uint32_t PDR0;          /* Offset: 0x14  PWM Data Register 0                                                */
X    volatile const  uint32_t PDR0;           
N    __IO uint32_t CNR1;          /* Offset: 0x18  PWM Counter Register 1                                             */
X    volatile uint32_t CNR1;           
N    __IO uint32_t CMR1;          /* Offset: 0x1C  PWM Comparator Register 1                                          */
X    volatile uint32_t CMR1;           
N    __I  uint32_t PDR1;          /* Offset: 0x20  PWM Data Register 1                                                */
X    volatile const  uint32_t PDR1;           
N    __IO uint32_t CNR2;          /* Offset: 0x24  PWM Counter Register 2                                             */
X    volatile uint32_t CNR2;           
N    __IO uint32_t CMR2;          /* Offset: 0x28  PWM Comparator Register 2                                          */
X    volatile uint32_t CMR2;           
N    __I  uint32_t PDR2;          /* Offset: 0x2C  PWM Data Register 2                                                */
X    volatile const  uint32_t PDR2;           
N    __IO uint32_t CNR3;          /* Offset: 0x30  PWM Counter Register 3                                             */
X    volatile uint32_t CNR3;           
N    __IO uint32_t CMR3;          /* Offset: 0x34  PWM Comparator Register 3                                          */
X    volatile uint32_t CMR3;           
N    __I  uint32_t PDR3;          /* Offset: 0x38  PWM Data Register 3                                                */
X    volatile const  uint32_t PDR3;           
N    __IO uint32_t PBCR;          /* Offset: 0x3C  PWM Backward Compatible Register                                   */
X    volatile uint32_t PBCR;           
N    __IO uint32_t PIER;          /* Offset: 0x40  PWM Interrupt Enable Register                                      */
X    volatile uint32_t PIER;           
N    __IO uint32_t PIIR;          /* Offset: 0x44  PWM Interrupt Indication Register                                  */
X    volatile uint32_t PIIR;           
N    __I  uint32_t RESERVE1[2];  
X    volatile const  uint32_t RESERVE1[2];  
N    __IO uint32_t CCR0;          /* Offset: 0x50  PWM Capture Control Register 0                                     */
X    volatile uint32_t CCR0;           
N    __IO uint32_t CCR2;          /* Offset: 0x54  PWM Capture Control Register 2                                     */
X    volatile uint32_t CCR2;           
N    __IO uint32_t CRLR0;         /* Offset: 0x58  PWM Capture Rising Latch Register (Channel 0)                      */
X    volatile uint32_t CRLR0;          
N    __IO uint32_t CFLR0;         /* Offset: 0x5C  PWM Capture Falling Latch Register (Channel 0)                     */
X    volatile uint32_t CFLR0;          
N    __IO uint32_t CRLR1;         /* Offset: 0x60  PWM Capture Rising Latch Register (Channel 1)                      */
X    volatile uint32_t CRLR1;          
N    __IO uint32_t CFLR1;         /* Offset: 0x64  PWM Capture Falling Latch Register (Channel 1)                     */
X    volatile uint32_t CFLR1;          
N    __IO uint32_t CRLR2;         /* Offset: 0x68  PWM Capture Rising Latch Register (Channel 2)                      */
X    volatile uint32_t CRLR2;          
N    __IO uint32_t CFLR2;         /* Offset: 0x6C  PWM Capture Falling Latch Register (Channel 2)                     */
X    volatile uint32_t CFLR2;          
N    __IO uint32_t CRLR3;         /* Offset: 0x70  PWM Capture Rising Latch Register (Channel 3)                      */
X    volatile uint32_t CRLR3;          
N    __IO uint32_t CFLR3;         /* Offset: 0x74  PWM Capture Falling Latch Register (Channel 3)                     */
X    volatile uint32_t CFLR3;          
N    __IO uint32_t CAPENR;        /* Offset: 0x78  PWM Capture Input 0~3 Enable Register                              */
X    volatile uint32_t CAPENR;         
N    __IO uint32_t POE;           /* Offset: 0x7C  PWM Output Enable for Channel 0~3                                  */
X    volatile uint32_t POE;            
N    __IO uint32_t TCON;          /* Offset: 0x80  PWM Trigger Control for Channel 0~3                                */
X    volatile uint32_t TCON;           
N    __IO uint32_t TSTATUS;       /* Offset: 0x84  PWM Trigger Status Register                                        */
X    volatile uint32_t TSTATUS;        
N    __IO uint32_t SYNCBUSY0;     /* Offset: 0x88  PWM0 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY0;      
N    __IO uint32_t SYNCBUSY1;     /* Offset: 0x8C  PWM1 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY1;      
N    __IO uint32_t SYNCBUSY2;     /* Offset: 0x90  PWM2 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY2;      
N    __IO uint32_t SYNCBUSY3;     /* Offset: 0x94  PWM3 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY3;      
N
N} PWM_T;
N
N
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM_T::PPR: DZI23 Position */
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM_T::PPR: DZI23 Mask */
N
N#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM_T::PPR: DZI01 Position */
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM_T::PPR: DZI01 Mask */
N
N#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM_T::PPR: CP23 Position */
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM_T::PPR: CP23 Mask */
N
N#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM_T::PPR: CP01 Position */
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM_T::PPR: CP01 Mask */
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM_T::CSR: CSR3 Position */
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM_T::CSR: CSR3 Mask */
N
N#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM_T::CSR: CSR2 Position */
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM_T::CSR: CSR2 Mask */
N
N#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM_T::CSR: CSR1 Position */
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM_T::CSR: CSR1 Mask */
N
N#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM_T::CSR: CSR0 Position */
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM_T::CSR: CSR0 Mask */
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM_T::PCR: PWM23TYPE Position */
N#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM_T::PCR: PWM23TYPE Mask */
N
N#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM_T::PCR: PWM01TYPE Position */
N#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM_T::PCR: PWM01TYPE Mask */
N
N#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM_T::PCR: CH3MOD Position */
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM_T::PCR: CH3MOD Mask */
N
N#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM_T::PCR: CH3INV Position */
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM_T::PCR: CH3INV Mask */
N
N#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM_T::PCR: CH3PINV Position */
N#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM_T::PCR: CH3PINV Mask */
N
N#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM_T::PCR: CH3EN Position */
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM_T::PCR: CH3EN Mask */
N
N#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM_T::PCR: CH2MOD Position */
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM_T::PCR: CH2MOD Mask */
N
N#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM_T::PCR: CH2INV Position */
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM_T::PCR: CH2INV Mask */
N
N#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM_T::PCR: CH2PINV Position */
N#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM_T::PCR: CH2PINV Mask */
N
N#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM_T::PCR: CH2EN Position */
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM_T::PCR: CH2EN Mask */
N
N#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM_T::PCR: CH1MOD Position */
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM_T::PCR: CH1MOD Mask */
N
N#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM_T::PCR: CH1INV Position */
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM_T::PCR: CH1INV Mask */
N
N#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM_T::PCR: CH1PINV Position */
N#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM_T::PCR: CH1PINV Mask */
N
N#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM_T::PCR: CH1EN Position */
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM_T::PCR: CH1EN Mask */
N
N#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM_T::PCR: DZEN23 Position */
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM_T::PCR: DZEN23 Mask */
N
N#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM_T::PCR: DZEN01 Position */
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM_T::PCR: DZEN01 Mask */
N
N#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM_T::PCR: CH0MOD Position */
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM_T::PCR: CH0MOD Mask */
N
N#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM_T::PCR: CH0INV Position */
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM_T::PCR: CH0INV Mask */
N
N#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM_T::PCR: CH0PINV Position */
N#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM_T::PCR: CH0PINV Mask */
N
N#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM_T::PCR: CH0EN Position */
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM_T::PCR: CH0EN Mask */
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM_T::CNR0: CNR Position */
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM_T::CNR0: CNR Mask */
N                                                                                            
N/* PWM CMR Bit Field Definitions */                                                         
N#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM_T::CMR0: CMR Position */
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM_T::CMR0: CMR Mask */
N                                                                                            
N/* PWM PDR Bit Field Definitions */                                                         
N#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM_T::PDR0: PDR Position */
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM_T::PDR0: PDR Mask */
N
N/* PWM PBCR Bit Field Definitions */
N#define PWM_PBCR_BCn_Pos                         0                                  /*!< PWM_T::PBCR: BCn Position */
N#define PWM_PBCR_BCn_Msk                         (1ul << PWM_PBCR_BCn_Pos)          /*!< PWM_T::PBCR: BCn Mask */
N
N/* PWM PIER Bit Field Definitions */
N
N#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM_T::PIER: INT23TYPE Position */
N#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM_T::PIER: INT23TYPE Mask */
N
N#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM_T::PIER: INT01TYPE Position */
N#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM_T::PIER: INT01TYPE Mask */
N
N#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM_T::PIER: PWMDIE3 Position */
N#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM_T::PIER: PWMDIE3 Mask */
N
N#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM_T::PIER: PWMDIE2 Position */
N#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM_T::PIER: PWMDIE2 Mask */
N
N#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM_T::PIER: PWMDIE1 Position */
N#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM_T::PIER: PWMDIE1 Mask */
N
N#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM_T::PIER: PWMDIE0 Position */
N#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM_T::PIER: PWMDIE0 Mask */
N
N#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM_T::PIER: PWMIE3 Position */
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM_T::PIER: PWMIE3 Mask */
N
N#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM_T::PIER: PWMIE2 Position */
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM_T::PIER: PWMIE2 Mask */
N
N#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM_T::PIER: PWMIE1 Position */
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM_T::PIER: PWMIE1 Mask */
N
N#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM_T::PIER: PWMIE0 Position */
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM_T::PIER: PWMIE0 Mask */
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM_T::PIIR: PWMDIF3 Position */
N#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM_T::PIIR: PWMDIF3 Mask */
N
N#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM_T::PIIR: PWMDIF2 Position */
N#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM_T::PIIR: PWMDIF2 Mask */
N
N#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM_T::PIIR: PWMDIF1 Position */
N#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM_T::PIIR: PWMDIF1 Mask */
N
N#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM_T::PIIR: PWMDIF0 Position */
N#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM_T::PIIR: PWMDIF0 Mask */
N
N#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM_T::PIIR: PWMIF3 Position */
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM_T::PIIR: PWMIF3 Mask */
N
N#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM_T::PIIR: PWMIF2 Position */
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM_T::PIIR: PWMIF2 Mask */
N
N#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM_T::PIIR: PWMIF1 Position */
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM_T::PIIR: PWMIF1 Mask */
N
N#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM_T::PIIR: PWMIF0 Position */
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM_T::PIIR: PWMIF0 Mask */
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM_T::CCR0: CFLRI1 Position */
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM_T::CCR0: CFLRI1 Mask */
N
N#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM_T::CCR0: CRLRI1 Position */
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM_T::CCR0: CRLRI1 Mask */
N
N#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM_T::CCR0: CAPIF1 Position */
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM_T::CCR0: CAPIF1 Mask */
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM_T::CCR0: CAPCH1EN Position */
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM_T::CCR0: CAPCH1EN Mask */
N
N#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM_T::CCR0: CFL_IE1 Position */
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM_T::CCR0: CFL_IE1 Mask */
N
N#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM_T::CCR0: CRL_IE1 Position */
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM_T::CCR0: CRL_IE1 Mask */
N
N#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM_T::CCR0: INV1 Position */
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM_T::CCR0: INV1 Mask */
N
N#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM_T::CCR0: CFLRI0 Position */
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM_T::CCR0: CFLRI0 Mask */
N
N#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM_T::CCR0: CRLRI0 Position */
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM_T::CCR0: CRLRI0 Mask */
N
N#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM_T::CCR0: CAPIF0 Position */
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM_T::CCR0: CAPIF0 Mask */
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM_T::CCR0: CAPCH0EN Position */
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM_T::CCR0: CAPCH0EN Mask */
N
N#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM_T::CCR0: CFL_IE0 Position */
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM_T::CCR0: CFL_IE0 Mask */
N
N#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM_T::CCR0: CRL_IE0 Position */
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM_T::CCR0: CRL_IE0 Mask */
N
N#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM_T::CCR0: INV0 Position */
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM_T::CCR0: INV0 Mask */
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM_T::CCR2: CFLRI3 Position */
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM_T::CCR2: CFLRI3 Mask */
N
N#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM_T::CCR2: CRLRI3 Position */
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM_T::CCR2: CRLRI3 Mask */
N
N#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM_T::CCR2: CAPIF3 Position */
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM_T::CCR2: CAPIF3 Mask */
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM_T::CCR2: CAPCH3EN Position */
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM_T::CCR2: CAPCH3EN Mask */
N
N#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM_T::CCR2: CFL_IE3 Position */
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM_T::CCR2: CFL_IE3 Mask */
N
N#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM_T::CCR2: CRL_IE3 Position */
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM_T::CCR2: CRL_IE3 Mask */
N
N#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM_T::CCR2: INV3 Position */
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM_T::CCR2: INV3 Mask */
N
N#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM_T::CCR2: CFLRI2 Position */
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM_T::CCR2: CFLRI2 Mask */
N
N#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM_T::CCR2: CRLRI2 Position */
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM_T::CCR2: CRLRI2 Mask */
N
N#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM_T::CCR2: CAPIF2 Position */
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM_T::CCR2: CAPIF2 Mask */
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM_T::CCR2: CAPCH2EN Position */
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM_T::CCR2: CAPCH2EN Mask */
N
N#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM_T::CCR2: CFL_IE2 Position */
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM_T::CCR2: CFL_IE2 Mask */
N
N#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM_T::CCR2: CRL_IE2 Position */
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM_T::CCR2: CRL_IE2 Mask */
N
N#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM_T::CCR2: INV2 Position */
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM_T::CCR2: INV2 Mask */
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM_T::CRLR0: CRLR Position */
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM_T::CRLR0: CRLR Mask */
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM_T::CFLR0: CFLR Position */
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM_T::CFLR0: CFLR Mask */
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM_T::CAPENR: CINEN3 Position */
N#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM_T::CAPENR: CINEN3 Mask */
N
N#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM_T::CAPENR: CINEN2 Position */
N#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM_T::CAPENR: CINEN2 Mask */
N
N#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM_T::CAPENR: CINEN1 Position */
N#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM_T::CAPENR: CINEN1 Mask */
N
N#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM_T::CAPENR: CINEN0 Position */
N#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM_T::CAPENR: CINEN0 Mask */
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_POE3_Pos                        3                                   /*!< PWM_T::POE: POE3 Position */
N#define PWM_POE_POE3_Msk                        (1ul << PWM_POE_POE3_Pos)           /*!< PWM_T::POE: POE3 Mask */
N
N#define PWM_POE_POE2_Pos                        2                                   /*!< PWM_T::POE: POE2 Position */
N#define PWM_POE_POE2_Msk                        (1ul << PWM_POE_POE2_Pos)           /*!< PWM_T::POE: POE2 Mask */
N
N#define PWM_POE_POE1_Pos                        1                                   /*!< PWM_T::POE: POE1 Position */
N#define PWM_POE_POE1_Msk                        (1ul << PWM_POE_POE1_Pos)           /*!< PWM_T::POE: POE1 Mask */
N
N#define PWM_POE_POE0_Pos                        0                                   /*!< PWM_T::POE: POE0 Position */
N#define PWM_POE_POE0_Msk                        (1ul << PWM_POE_POE0_Pos)           /*!< PWM_T::POE: POE0 Mask */
N
N/* PWM TCON Bit Field Definitions */
N
N#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM_T::TCON: PWM3TEN Position */
N#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM_T::TCON: PWM3TEN Mask */
N
N#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM_T::TCON: PWM2TEN Position */
N#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM_T::TCON: PWM2TEN Mask */
N
N#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM_T::TCON: PWM1TEN Position */
N#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM_T::TCON: PWM1TEN Mask */
N
N#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM_T::TCON: PWM0TEN Position */
N#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM_T::TCON: PWM0TEN Mask */
N
N/* PWM TSTATUS Bit Field Definitions */
N
N#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM_T::TSTATUS: PWM3TF Position */
N#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM_T::TSTATUS: PWM3TF Mask */
N
N#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM_T::TSTATUS: PWM2TF Position */
N#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM_T::TSTATUS: PWM2TF Mask */
N
N#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM_T::TSTATUS: PWM1TF Position */
N#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM_T::TSTATUS: PWM1TF Mask */
N
N#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM_T::TSTATUS: PWM0TF Position */
N#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM_T::TSTATUS: PWM0TF Mask */
N
N/* PWM SYNCBUSY0 Bit Field Definitions */
N#define PWM_SYNCBUSY0_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY0: S_BUSY Position */
N#define PWM_SYNCBUSY0_S_BUSY_Msk                (1ul << PWM_SYNCBUSY0_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY0: S_BUSY Mask */
N
N/* PWM SYNCBUSY1 Bit Field Definitions */
N#define PWM_SYNCBUSY1_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY1: S_BUSY Position */
N#define PWM_SYNCBUSY1_S_BUSY_Msk                (1ul << PWM_SYNCBUSY1_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY1: S_BUSY Mask */
N
N/* PWM SYNCBUSY2 Bit Field Definitions */
N#define PWM_SYNCBUSY2_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY2: S_BUSY Position */
N#define PWM_SYNCBUSY2_S_BUSY_Msk                (1ul << PWM_SYNCBUSY2_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY2: S_BUSY Mask */
N
N/* PWM SYNCBUSY3 Bit Field Definitions */
N#define PWM_SYNCBUSY3_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY3: S_BUSY Position */
N#define PWM_SYNCBUSY3_S_BUSY_Msk                (1ul << PWM_SYNCBUSY3_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY3: S_BUSY Mask */
N/*@}*/ /* end of group PWM_CONST */
N/*@}*/ /* end of group PWM */
N
N
N
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller (RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var RTC_T::INIR
N * Offset: 0x00  RTC Initiation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INIR0_Active|RTC Active Status (Read Only)
N * |        |          |0 = RTC is at reset state.
N * |        |          |1 = RTC is at normal active state.
N * |[31:1]  |INIR      |RTC Initiation
N * |        |          |When RTC block is powered on, RTC is at reset state.
N * |        |          |User has to write a number (0xa5eb1357) to INIR to make RTC leaving reset state.
N * |        |          |Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
N * |        |          |The INIR is a write-only field and read value will be always 0.
N * @var RTC_T::AER
N * Offset: 0x04  RTC Access Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |AER       |RTC Register Access Enable Password (Write Only)
N * |        |          |Writing 0xA965 to this register will enable RTC access and keep 1024 RTC clocks.
N * |[16]    |ENF       |RTC Register Access Enable Flag (Read Only)
N * |        |          |0 = RTC register read/write access Disabled.
N * |        |          |1 = RTC register read/write access Enabled.
N * |        |          |This bit will be set after AER[15:0] is load a 0xA965, and will be cleared automatically
N * |        |          |after 1024 RTC clocks.
N * @var RTC_T::FCR
N * Offset: 0x08  RTC Frequency Compensation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |FRACTION  |Fraction Part
N * |        |          |Formula = (fraction part of detected value) x 60.
N * |        |          |Note: Digit in FCR must be expressed as hexadecimal number.
N * |[11:8]  |INTEGER   |Integer Part
N * @var RTC_T::TLR
N * Offset: 0x0C  Time Loading Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1SEC      |1-Sec Time Digit (0~9)
N * |[6:4]   |10SEC     |10-Sec Time Digit (0~5)
N * |[11:8]  |1MIN      |1-Min Time Digit (0~9)
N * |[14:12] |10MIN     |10-Min Time Digit (0~5)
N * |[19:16] |1HR       |1-Hour Time Digit (0~9)
N * |[21:20] |10HR      |10-Hour Time Digit (0~2)
N * @var RTC_T::CLR
N * Offset: 0x10  Calendar Loading Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1DAY      |1-Day Calendar Digit (0~9)
N * |[5:4]   |10DAY     |10-Day Calendar Digit (0~3)
N * |[11:8]  |1MON      |1-Month Calendar Digit (0~9)
N * |[12]    |10MON     |10-Month Calendar Digit (0~1)
N * |[19:16] |1YEAR     |1-Year Calendar Digit (0~9)
N * |[23:20] |10YEAR    |10-Year Calendar Digit (0~9)
N * @var RTC_T::TSSR
N * Offset: 0x14  Time Scale Selection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |24H_12H   |24-Hour / 12-Hour Time Scale Selection
N * |        |          |It indicates that RTC TLR and TAR counter are in 24-hour time scale or 12-hour time scale.
N * |        |          |0 = 24-hour time scale selected.
N * |        |          |1 = 24-hour time scale selected.
N * @var RTC_T::DWR
N * Offset: 0x18  Day of the Week Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |DWR       |Day Of The Week Register
N * |        |          |000 = Sunday.
N * |        |          |001 = Monday.
N * |        |          |010 = Tuesday.
N * |        |          |011 = Wednesday.
N * |        |          |100 = Thursday.
N * |        |          |101 = Friday.
N * |        |          |110 = Saturday.
N * |        |          |111 = Reserved.
N * @var RTC_T::TAR
N * Offset: 0x1C  Time Alarm Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1SEC      |1-Sec Time Digit of Alarm Setting (0~9)
N * |[6:4]   |10SEC     |10-Sec Time Digit of Alarm Setting (0~5)
N * |[11:8]  |1MIN      |1-Min Time Digit of Alarm Setting (0~9)
N * |[14:12] |10MIN     |10-Min Time Digit of Alarm Setting (0~5)
N * |[19:16] |1HR       |1-Hour Time Digit of Alarm Setting (0~9)
N * |[21:20] |10HR      |10-Hour Time Digit of Alarm Setting (0~2)
N * @var RTC_T::CAR
N * Offset: 0x20  Calendar Alarm Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1DAY      |1-Day Calendar Digit of Alarm Setting (0~9)
N * |[5:4]   |10DAY     |10-Day Calendar Digit of Alarm Setting (0~3)
N * |[11:8]  |1MON      |1-Month Calendar Digit of Alarm Setting (0~9)
N * |[12]    |10MON     |10-Month Calendar Digit of Alarm Setting (0~1)
N * |[19:16] |1YEAR     |1-Year Calendar Digit of Alarm Setting (0~9)
N * |[23:20] |10YEAR    |10-Year Calendar Digit of Alarm Setting (0~9)
N * @var RTC_T::LIR
N * Offset: 0x24  Leap Year Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LIR       |Leap Year Indication Register (Read Only)
N * |        |          |0 = This year is not a leap year.
N * |        |          |1 = This year is a leap year.
N * @var RTC_T::RIER
N * Offset: 0x28  RTC Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |AIER      |Alarm Interrupt Enable
N * |        |          |This bit is used to enable/disable RTC Alarm Interrupt, and generate an interrupt signal if
N * |        |          |AIF (RIIR[0] RTC Alarm Interrupt Flag) is set to 1.
N * |        |          |0 = RTC Alarm Interrupt Disabled.
N * |        |          |1 = RTC Alarm Interrupt Enabled.
N * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode
N * |        |          |and RTC Alarm Interrupt signal generated.
N * |[1]     |TIER      |Time Tick Interrupt Enable
N * |        |          |This bit is used to enable/disable RTC Time Tick Interrupt, and generate an interrupt signal
N * |        |          |if TIF (RIIR[1] RTC Time Tick Interrupt Flag) is set to 1.
N * |        |          |0 = RTC Time Tick Interrupt Disabled.
N * |        |          |1 = RTC Time Tick Interrupt Enabled.
N * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode
N * |        |          |and RTC Time Tick Interrupt signal generated.
N * |[2]     |SNOOPIER  |Snoop Detection Interrupt Enable
N * |        |          |This bit is used to enable/disable RTC Snoop Detection Interrupt, and generate an interrupt
N * |        |          |signal if SNOOPIF (RIIR[2] RTC Snoop Detection Interrupt Flag) is set to 1.
N * |        |          |0 = Snoop detected interrupt Disabled.
N * |        |          |1 = Snoop detected interrupt Enabled.
N * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode
N * |        |          |and RTC Snoop Interrupt signal generated.
N * @var RTC_T::RIIR
N * Offset: 0x2C  RTC Interrupt Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |AIF       |RTC Alarm Interrupt Flag
N * |        |          |When RTC time counters TLR and CLR match the alarm setting time registers TAR and CAR, this
N * |        |          |bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled AIER
N * |        |          |(RIER[0]) is set to 1.
N * |        |          |Chip will be wake-up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.
N * |        |          |0 = Alarm condition is not matched.
N * |        |          |1 = Alarm condition is matched.
N * |        |          |Note: Write 1 to clear this bit.
N * |[1]     |TIF       |RTC Time Tick Interrupt Flag
N * |        |          |When RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if
N * |        |          |RTC Tick Interrupt enabled TIER (RIER[1]) is set to 1.
N * |        |          |Chip will also be wake-up if RTC Tick Interrupt is enabled and this bit is set to 1 when
N * |        |          |chip is running at Power-down mode.
N * |        |          |0 = Tick condition does not occur.
N * |        |          |1 = Tick condition occur.
N * |        |          |Note: Write 1 to clear to clear this bit.
N * |[2]     |SNOOPIF   |Snoop Detection Interrupt Flag
N * |        |          |When snooper pin transition event is detected, this bit is set to 1 and an interrupt is
N * |        |          |generated if Snoop Detection Interrupt enabled SNOOPIER (RIER[2]) is set to1.
N * |        |          |Chip will be wake-up from Power-down mode if Snoop Detection Interrupt is enabled.
N * |        |          |0 = No snoop event is detected.
N * |        |          |1 = Snoop event is detected.
N * |        |          |Note: Write 1 to clear this bit.
N * @var RTC_T::TTR
N * Offset: 0x30  RTC Time Tick Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |TTR       |Time Tick Register
N * |        |          |These bits are used to select RTC time tick period for Periodic Time Tick Interrupt request.
N * |        |          |000 = Time tick is 1 second.
N * |        |          |001 = Time tick is 1/2 second.
N * |        |          |010 = Time tick is 1/4 second.
N * |        |          |011 = Time tick is 1/8 second.
N * |        |          |100 = Time tick is 1/16 second.
N * |        |          |101 = Time tick is 1/32 second.
N * |        |          |110 = Time tick is 1/64 second.
N * |        |          |111 = Time tick is 1/28 second.
N * |        |          |Note: This register can be read back after the RTC register access enable bit ENF (AER[16])
N * |        |          |is active.
N * @var RTC_T::SPRCTL
N * Offset: 0x3C  RTC Spare Functional Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SNOOPEN   |Snoop Detection Enable
N * |        |          |0 = Snoop detection function Disabled.
N * |        |          |1 = Snoop detection function Enabled.
N * |[1]     |SNOOPLEVEL|Snoop Detection Level Selection
N * |        |          |This bit controls snoop detect event is high level/rising edge or low level/falling edge.
N * |        |          |0 = Low level/Falling edge detection.
N * |        |          |1 = High level/Rising edge detection.
N * |[2]     |SPREN     |SPR Register Enable
N * |        |          |0 = Spare register is Disabled.
N * |        |          |1 = Spare register is Enabled.
N * |        |          |Note: When spare register is disabled, RTC SPR0 ~ SPR19 cannot be accessed.
N * |[3]     |SNOOPMODE |Snoop Detection Mode Selection
N * |        |          |This bit controls snoop detect event is edge or level detection.
N * |        |          |0 = Level detection.
N * |        |          |1 = Edge detection.
N * |[5]     |SPRCFLG   |Spare Register Clear Flag
N * |        |          |This bit indicates if the SPR0 ~ SPR19 content is cleared when snoop specify event is
N * |        |          |detected.
N * |        |          |0 = Spare register content is not cleared.
N * |        |          |1 = Spare register content is cleared.
N * |        |          |Note: Writes 1 to clear this bit.
N * |[7]     |SPRRDY    |SPR Register Ready
N * |        |          |This bit indicates if the registers SPRCTL, SPR0 ~ SPR19 are ready to be accessed.
N * |        |          |After user writing registers SPRCTL, SPR0 ~ SPR19, read this bit to check if these registers
N * |        |          |are updated done is necessary.
N * |        |          |0 = SPRCTL, SPR0 ~ SPR19 updating is in progress.
N * |        |          |1 = SPRCTL, SPR0 ~ SPR19 are updated done and ready to be accessed.
N * |        |          |Note: This bit is read only and any write to it won't take any effect.
N * @var RTC_T::SPR
N * Offset: 0x40  RTC Spare Register 0 ~ 19
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |SPARE     |SPARE Register
N * |        |          |This field is used to store back-up information defined by software.
N * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
N * |        |          |Before store back-up information in to SPARE register, software should write 0xA965 to AER
N * |        |          |to make sure register read/write enable.
N */
N
N    __IO uint32_t INIR;          /* Offset: 0x00  RTC Initiation Register                                            */
X    volatile uint32_t INIR;           
N    __IO uint32_t AER;           /* Offset: 0x04  RTC Access Enable Register                                         */
X    volatile uint32_t AER;            
N    __IO uint32_t FCR;           /* Offset: 0x08  RTC Frequency Compensation Register                                */
X    volatile uint32_t FCR;            
N    __IO uint32_t TLR;           /* Offset: 0x0C  Time Loading Register                                              */
X    volatile uint32_t TLR;            
N    __IO uint32_t CLR;           /* Offset: 0x10  Calendar Loading Register                                          */
X    volatile uint32_t CLR;            
N    __IO uint32_t TSSR;          /* Offset: 0x14  Time Scale Selection Register                                      */
X    volatile uint32_t TSSR;           
N    __IO uint32_t DWR;           /* Offset: 0x18  Day of the Week Register                                           */
X    volatile uint32_t DWR;            
N    __IO uint32_t TAR;           /* Offset: 0x1C  Time Alarm Register                                                */
X    volatile uint32_t TAR;            
N    __IO uint32_t CAR;           /* Offset: 0x20  Calendar Alarm Register                                            */
X    volatile uint32_t CAR;            
N    __I  uint32_t LIR;           /* Offset: 0x24  Leap Year Indicator Register                                       */
X    volatile const  uint32_t LIR;            
N    __IO uint32_t RIER;          /* Offset: 0x28  RTC Interrupt Enable Register                                      */
X    volatile uint32_t RIER;           
N    __IO uint32_t RIIR;          /* Offset: 0x2C  RTC Interrupt Indicator Register                                   */
X    volatile uint32_t RIIR;           
N    __IO uint32_t TTR;           /* Offset: 0x30  RTC Time Tick Register                                             */
X    volatile uint32_t TTR;            
N    __I  uint32_t RESERVED[2];  
X    volatile const  uint32_t RESERVED[2];  
N    __IO uint32_t SPRCTL;        /* Offset: 0x3C  RTC Spare Functional Control Register                              */
X    volatile uint32_t SPRCTL;         
N    __IO uint32_t SPR[20];       /* Offset: 0x40  RTC Spare Register 0 ~ 19                                          */
X    volatile uint32_t SPR[20];        
N
N} RTC_T;
N
N
N
N/**
N    @addtogroup RTC_CONST RTC Bit Field Definition
N    Constant Definitions for RTC Controller
N@{ */
N
N/* RTC INIR Bit Field Definitions */
N#define RTC_INIR_INIR_Pos       0                                               /*!< RTC_T::INIR: INIR Position */
N#define RTC_INIR_INIR_Msk       (0xFFFFFFFFul << RTC_INIR_INIR_Pos)             /*!< RTC_T::INIR: INIR Mask */
N
N#define RTC_INIR_ACTIVE_Pos     0                                               /*!< RTC_T::INIR: ACTIVE Position */
N#define RTC_INIR_ACTIVE_Msk     (1ul << RTC_INIR_ACTIVE_Pos)                    /*!< RTC_T::INIR: ACTIVE Mask */
N
N/* RTC AER Bit Field Definitions */
N#define RTC_AER_ENF_Pos         16                                              /*!< RTC_T::AER: ENF Position */
N#define RTC_AER_ENF_Msk         (1ul << RTC_AER_ENF_Pos)                        /*!< RTC_T::AER: ENF Mask */
N
N#define RTC_AER_AER_Pos         0                                               /*!< RTC_T::AER: AER Position */
N#define RTC_AER_AER_Msk         (0xFFFFul << RTC_AER_AER_Pos)                   /*!< RTC_T::AER: AER Mask */
N
N/* RTC FCR Bit Field Definitions */
N#define RTC_FCR_INTEGER_Pos     8                                               /*!< RTC_T::FCR: INTEGER Position */
N#define RTC_FCR_INTEGER_Msk     (0xFul << RTC_FCR_INTEGER_Pos)                  /*!< RTC_T::FCR: INTEGER Mask */
N
N#define RTC_FCR_FRACTION_Pos    0                                               /*!< RTC_T::FCR: FRACTION Position */
N#define RTC_FCR_FRACTION_Msk    (0x3Ful << RTC_FCR_FRACTION_Pos)                /*!< RTC_T::FCR: FRACTION Mask */
N
N/* RTC TLR Bit Field Definitions */
N#define RTC_TLR_10HR_Pos        20                                              /*!< RTC_T::TLR: 10HR Position */
N#define RTC_TLR_10HR_Msk        (0x3ul << RTC_TLR_10HR_Pos)                     /*!< RTC_T::TLR: 10HR Mask */
N
N#define RTC_TLR_1HR_Pos         16                                              /*!< RTC_T::TLR: 1HR Position */
N#define RTC_TLR_1HR_Msk         (0xFul << RTC_TLR_1HR_Pos)                      /*!< RTC_T::TLR: 1HR Mask */
N
N#define RTC_TLR_10MIN_Pos       12                                              /*!< RTC_T::TLR: 10MIN Position */
N#define RTC_TLR_10MIN_Msk       (0x7ul << RTC_TLR_10MIN_Pos)                    /*!< RTC_T::TLR: 10MIN Mask */
N
N#define RTC_TLR_1MIN_Pos        8                                               /*!< RTC_T::TLR: 1MIN Position */
N#define RTC_TLR_1MIN_Msk        (0xFul << RTC_TLR_1MIN_Pos)                     /*!< RTC_T::TLR: 1MIN Mask */
N
N#define RTC_TLR_10SEC_Pos       4                                               /*!< RTC_T::TLR: 10SEC Position */
N#define RTC_TLR_10SEC_Msk       (0x7ul << RTC_TLR_10SEC_Pos)                    /*!< RTC_T::TLR: 10SEC Mask */
N
N#define RTC_TLR_1SEC_Pos        0                                               /*!< RTC_T::TLR: 1SEC Position */
N#define RTC_TLR_1SEC_Msk        (0xFul << RTC_TLR_1SEC_Pos)                     /*!< RTC_T::TLR: 1SEC Mask */
N
N/* RTC CLR Bit Field Definitions */
N#define RTC_CLR_10YEAR_Pos      20                                              /*!< RTC_T::CLR: 10YEAR Position */
N#define RTC_CLR_10YEAR_Msk      (0xFul << RTC_CLR_10YEAR_Pos)                   /*!< RTC_T::CLR: 10YEAR Mask */
N
N#define RTC_CLR_1YEAR_Pos       16                                              /*!< RTC_T::CLR: 1YEAR Position */
N#define RTC_CLR_1YEAR_Msk       (0xFul << RTC_CLR_1YEAR_Pos)                    /*!< RTC_T::CLR: 1YEAR Mask */
N
N#define RTC_CLR_10MON_Pos       12                                              /*!< RTC_T::CLR: 10MON Position */
N#define RTC_CLR_10MON_Msk       (1ul << RTC_CLR_10MON_Pos)                      /*!< RTC_T::CLR: 10MON Mask */
N
N#define RTC_CLR_1MON_Pos        8                                               /*!< RTC_T::CLR: 1MON Position */
N#define RTC_CLR_1MON_Msk        (0xFul << RTC_CLR_1MON_Pos)                     /*!< RTC_T::CLR: 1MON Mask */
N
N#define RTC_CLR_10DAY_Pos       4                                               /*!< RTC_T::CLR: 10DAY Position */
N#define RTC_CLR_10DAY_Msk       (0x3ul << RTC_CLR_10DAY_Pos)                    /*!< RTC_T::CLR: 10DAY Mask */
N
N#define RTC_CLR_1DAY_Pos        0                                               /*!< RTC_T::CLR: 1DAY Position */
N#define RTC_CLR_1DAY_Msk        (0xFul << RTC_CLR_1DAY_Pos)                     /*!< RTC_T::CLR: 1DAY Mask */
N
N/* RTC TSSR Bit Field Definitions */
N#define RTC_TSSR_24H_12H_Pos    0                                               /*!< RTC_T::TSSR: 24H_12H Position */
N#define RTC_TSSR_24H_12H_Msk    (1ul << RTC_TSSR_24H_12H_Pos)                   /*!< RTC_T::TSSR: 24H_12H Mask */
N
N/* RTC DWR Bit Field Definitions */
N#define RTC_DWR_DWR_Pos         0                                               /*!< RTC_T::DWR: DWR Position */
N#define RTC_DWR_DWR_Msk         (0x7ul << RTC_DWR_DWR_Pos)                      /*!< RTC_T::DWR: DWR Mask */
N
N/* RTC TAR Bit Field Definitions */
N#define RTC_TAR_10HR_Pos        20                                              /*!< RTC_T::TAR: 10HR Position */
N#define RTC_TAR_10HR_Msk        (0x3ul << RTC_TAR_10HR_Pos)                     /*!< RTC_T::TAR: 10HR Mask */
N
N#define RTC_TAR_1HR_Pos         16                                              /*!< RTC_T::TAR: 1HR Position */
N#define RTC_TAR_1HR_Msk         (0xFul << RTC_TAR_1HR_Pos)                      /*!< RTC_T::TAR: 1HR Mask */
N
N#define RTC_TAR_10MIN_Pos       12                                              /*!< RTC_T::TAR: 10MIN Position */
N#define RTC_TAR_10MIN_Msk       (0x7ul << RTC_TAR_10MIN_Pos)                    /*!< RTC_T::TAR: 10MIN Mask */
N
N#define RTC_TAR_1MIN_Pos        8                                               /*!< RTC_T::TAR: 1MIN Position */
N#define RTC_TAR_1MIN_Msk        (0xFul << RTC_TAR_1MIN_Pos)                     /*!< RTC_T::TAR: 1MIN Mask */
N
N#define RTC_TAR_10SEC_Pos       4                                               /*!< RTC_T::TAR: 10SEC Position */
N#define RTC_TAR_10SEC_Msk       (0x7ul << RTC_TAR_10SEC_Pos)                    /*!< RTC_T::TAR: 10SEC Mask */
N
N#define RTC_TAR_1SEC_Pos        0                                               /*!< RTC_T::TAR: 1SEC Position */
N#define RTC_TAR_1SEC_Msk        (0xFul << RTC_TAR_1SEC_Pos)                     /*!< RTC_T::TAR: 1SEC Mask */
N
N/* RTC CAR Bit Field Definitions */
N#define RTC_CAR_10YEAR_Pos      20                                              /*!< RTC_T::CAR: 10YEAR Position */
N#define RTC_CAR_10YEAR_Msk      (0xFul << RTC_CAR_10YEAR_Pos)                   /*!< RTC_T::CAR: 10YEAR Mask */
N
N#define RTC_CAR_1YEAR_Pos       16                                              /*!< RTC_T::CAR: 1YEAR Position */
N#define RTC_CAR_1YEAR_Msk       (0xFul << RTC_CAR_1YEAR_Pos)                    /*!< RTC_T::CAR: 1YEAR Mask */
N
N#define RTC_CAR_10MON_Pos       12                                              /*!< RTC_T::CAR: 10MON Position */
N#define RTC_CAR_10MON_Msk       (1ul << RTC_CAR_10MON_Pos)                      /*!< RTC_T::CAR: 10MON Mask */
N
N#define RTC_CAR_1MON_Pos        8                                               /*!< RTC_T::CAR: 1MON Position */
N#define RTC_CAR_1MON_Msk        (0xFul << RTC_CAR_1MON_Pos)                     /*!< RTC_T::CAR: 1MON Mask */
N
N#define RTC_CAR_10DAY_Pos       4                                               /*!< RTC_T::CAR: 10DAY Position */
N#define RTC_CAR_10DAY_Msk       (0x3ul << RTC_CAR_10DAY_Pos)                    /*!< RTC_T::CAR: 10DAY Mask */
N
N#define RTC_CAR_1DAY_Pos        0                                               /*!< RTC_T::CAR: 1DAY Position */
N#define RTC_CAR_1DAY_Msk        (0xFul << RTC_CAR_1DAY_Pos)                     /*!< RTC_T::CAR: 1DAY Mask */
N
N/* RTC LIR Bit Field Definitions */
N#define RTC_LIR_LIR_Pos         0                                               /*!< RTC_T::LIR: LIR Position */
N#define RTC_LIR_LIR_Msk         (1ul << RTC_LIR_LIR_Pos)                        /*!< RTC_T::LIR: LIR Mask */
N
N/* RTC RIER Bit Field Definitions */
N#define RTC_RIER_SNOOPIER_Pos   2                                               /*!< RTC_T::RIER: SNOOPIER Position */
N#define RTC_RIER_SNOOPIER_Msk   (1ul << RTC_RIER_SNOOPIER_Pos)                  /*!< RTC_T::RIER: SNOOPIER Mask */
N
N#define RTC_RIER_TIER_Pos       1                                               /*!< RTC_T::RIER: TIER Position */
N#define RTC_RIER_TIER_Msk       (1ul << RTC_RIER_TIER_Pos)                      /*!< RTC_T::RIER: TIER Mask */
N
N#define RTC_RIER_AIER_Pos       0                                               /*!< RTC_T::RIER: AIER Position */
N#define RTC_RIER_AIER_Msk       (1ul << RTC_RIER_AIER_Pos)                      /*!< RTC_T::RIER: AIER Mask */
N
N/* RTC RIIR Bit Field Definitions */
N#define RTC_RIIR_SNOOPIF_Pos    2                                               /*!< RTC_T::RIIR: SNOOPIF Position */
N#define RTC_RIIR_SNOOPIF_Msk    (1ul << RTC_RIIR_SNOOPIF_Pos)                   /*!< RTC_T::RIIR: SNOOPIF Mask */
N
N#define RTC_RIIR_TIF_Pos        1                                               /*!< RTC_T::RIIR: TIF Position */
N#define RTC_RIIR_TIF_Msk        (1ul << RTC_RIIR_TIF_Pos)                       /*!< RTC_T::RIIR: TIF Mask */
N
N#define RTC_RIIR_AIF_Pos        0                                               /*!< RTC_T::RIIR: AIF Position */
N#define RTC_RIIR_AIF_Msk        (1ul << RTC_RIIR_AIF_Pos)                       /*!< RTC_T::RIIR: AIF Mask */
N
N/* RTC TTR Bit Field Definitions */
N#define RTC_TTR_TTR_Pos         0                                               /*!< RTC_T::TTR: TTR Position */
N#define RTC_TTR_TTR_Msk         (0x7ul << RTC_TTR_TTR_Pos)                      /*!< RTC_T::TTR: TTR Mask */
N
N/* RTC SPRCTL Bit Field Definitions */
N#define RTC_SPRCTL_SPRRDY_Pos       7                                           /*!< RTC_T::SPRCTL: SPRRDY Position */
N#define RTC_SPRCTL_SPRRDY_Msk       (1ul << RTC_SPRCTL_SPRRDY_Pos)              /*!< RTC_T::SPRCTL: SPRRDY Mask */
N
N#define RTC_SPRCTL_SPRCFLG_Pos      5                                           /*!< RTC_T::SPRCTL: SPRCFLG Position */
N#define RTC_SPRCTL_SPRCFLG_Msk      (1ul << RTC_SPRCTL_SPRCFLG_Pos)             /*!< RTC_T::SPRCTL: SPRCFLG Mask */
N
N#define RTC_SPRCTL_SNOOPMODE_Pos    3                                           /*!< RTC_T::SPRCTL: SNOOPMODE Position */
N#define RTC_SPRCTL_SNOOPMODE_Msk    (1ul << RTC_SPRCTL_SNOOPMODE_Pos)           /*!< RTC_T::SPRCTL: SNOOPMODE Mask */
N
N#define RTC_SPRCTL_SPREN_Pos        2                                           /*!< RTC_T::SPRCTL: SPREN Position */
N#define RTC_SPRCTL_SPREN_Msk        (1ul << RTC_SPRCTL_SPREN_Pos)               /*!< RTC_T::SPRCTL: SPREN Mask */
N
N#define RTC_SPRCTL_SNOOPLEVEL_Pos   1                                           /*!< RTC_T::SPRCTL: SNOOPLEVEL Position */
N#define RTC_SPRCTL_SNOOPLEVEL_Msk   (1ul << RTC_SPRCTL_SNOOPLEVEL_Pos)          /*!< RTC_T::SPRCTL: SNOOPLEVEL Mask */
N
N#define RTC_SPRCTL_SNOOPEN_Pos      0                                           /*!< RTC_T::SPRCTL: SNOOPEN Position */
N#define RTC_SPRCTL_SNOOPEN_Msk      (1ul << RTC_SPRCTL_SNOOPEN_Pos)             /*!< RTC_T::SPRCTL: SNOOPEN Mask */
N/*@}*/ /* end of group RTC_CONST */
N/*@}*/ /* end of group RTC */
N
N
N
N
N/*---------------------- Smart Card Host Interface Controller -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface Controller (SC)
N    Memory Mapped Structure for SC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N    /**
N * @var SC_T::RBR
N * Offset: 0x00  SC Receiving Buffer Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |RBR       |Receiving Buffer
N * |        |          |By reading RBR, the SC will return an 8-bit received data.
N * @var SC_T::THR
N * Offset: 0x00  SC Transmit Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |THR       |Transmit Holding Buffer
N * |        |          |By writing data to THR, the SC will send out an 8-bit data.
N * |        |          |Note: If SC_CEN(SC_CTL[0]) is not enabled, THR cannot be programmed.
N * @var SC_T::CTL
N * Offset: 0x04  SC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC_CEN    |SC Engine Enable Control
N * |        |          |Set this bit to 1 to enable SC operation.
N * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
N * |[1]     |DIS_RX    |RX Transition Disable Control
N * |        |          |0 = The receiver Enabled.
N * |        |          |1 = The receiver Disabled.
N * |        |          |Note:
N * |        |          |If AUTO_CON_EN (SC_CTL[3])is enabled, these fields must be ignored.
N * |[2]     |DIS_TX    |TX Transition Disable Control
N * |        |          |0 = The transceiver Enabled.
N * |        |          |1 = The transceiver Disabled.
N * |[3]     |AUTO_CON_EN|Auto Convention Enable Control
N * |        |          |0 = Auto-convention Disabled.
N * |        |          |1 = Auto-convention Enabled.
N * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention,
N * |        |          |CON_SEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse
N * |        |          |convention, and CON_SEL (SC_CTL[5:4]) will be set to 11.
N * |        |          |If software enables auto convention function, the setting step must be done before Answer to
N * |        |          |Reset state and the first data must be 0x3B or 0x3F.
N * |        |          |After hardware received first data and stored it at buffer, hardware will decided the
N * |        |          |convention and change the CON_SEL (SC_CTL[5:4]) bits automatically.
N * |        |          |If the first data is not 0x3B or 0x3F, hardware will generate an interrupt INT_ACON_ERR (if
N * |        |          |ACON_ERR IE (SC_IER[10]) = 1 to CPU.
N * |[5:4]   |CON_SEL   |Convention Selection
N * |        |          |00 = Direct convention.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Inverse convention.
N * |        |          |Note:
N * |        |          |If AUTO_CON_EN(SC_CTL[3]) enabled, this fields are ignored.
N * |[7:6]   |RX_FTRI_LEV|Rx Buffer Trigger Level
N * |        |          |When the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be
N * |        |          |set (if IER [RDA_IEN] is enabled, an interrupt will be generated).
N * |        |          |00 = INTR_RDA Trigger Level with 01 Bytes.
N * |        |          |01 = INTR_RDA Trigger Level with 02 Bytes.
N * |        |          |10 = INTR_RDA Trigger Level with 03 Bytes.
N * |        |          |11 = Reserved.
N * |[12:8]  |BGT       |Block Guard Time (BGT)
N * |        |          |Block guard time means the minimum bit length between the leading edges of two consecutive
N * |        |          |characters between different transfer directions.
N * |        |          |This field indicates the counter for the bit length of block guard time.
N * |        |          |According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5)
N * |        |          |to this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
N * |        |          |Note:
N * |        |          |The real block guard time is BGT + 1.
N * |[14:13] |TMR_SEL   |Timer Selection
N * |        |          |00 = All internal timer function Disabled.
N * |        |          |01 = Internal 24 bit timer Enabled.
N * |        |          |Software can configure it by setting SC_TMR0 [23:0].
N * |        |          |SC_TMR1 and SC_TMR2 will be ignored in this mode.
N * |        |          |10 = internal 24 bit timer and 8 bit internal timer Enabled.
N * |        |          |Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit
N * |        |          |timer by setting SC_TMR1[7:0].
N * |        |          |SC_TMR2 will be ignored in this mode.
N * |        |          |11 = Internal 24 bit timer and two 8 bit timers Enabled.
N * |        |          |Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0].
N * |[15]    |SLEN      |Stop Bit Length
N * |        |          |This field indicates the length of stop bit.
N * |        |          |0 = The stop bit length is 2 ETU.
N * |        |          |1= The stop bit length is 1 ETU.
N * |        |          |Note:
N * |        |          |The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length
N * |[18:16] |RX_ERETRY |RX Error Retry Count Number
N * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity
N * |        |          |error has occurred
N * |        |          |Note1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.
N * |        |          |Note2: This field cannot be changed when RX_ERETRY_EN enabled.
N * |        |          |The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.
N * |[19]    |RX_ERETRY_EN|RX Error Retry Enable Control
N * |        |          |This bit enables receiver retry function when parity error has occurred.
N * |        |          |0 = RX error retry function Disabled.
N * |        |          |1 = RX error retry function Enabled.
N * |        |          |Note: Software must fill in the RX_ERETRY value before enabling this bit.
N * |[22:20] |TX_ERETRY |TX Error Retry Count Number
N * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity
N * |        |          |error has occurred.
N * |        |          |Note1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.
N * |        |          |Note2: This field cannot be changed when TX_ERETRY_EN enabled.
N * |        |          |The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.
N * |[23]    |TX_ERETRY_EN|TX Error Retry Enable Control
N * |        |          |This bit enables transmitter retry function when parity error has occurred.
N * |        |          |0 = TX error retry function Disabled.
N * |        |          |1 = TX error retry function Enabled.
N * |[25:24] |CD_DEB_SEL|Card Detect De-Bounce Selection
N * |        |          |This field indicates the card detect de-bounce selection.
N * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample
N * |        |          |card removal once per 128 engine clocks.
N * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample
N * |        |          |card removal once per 64 engine clocks.
N * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample
N * |        |          |card removal once per 32 engine clocks.
N * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample
N * |        |          |card removal once per 16 engine clocks.
N * |[30]    |SYNC      |SYNC Flag Indicator
N * |        |          |Due to synchronization, software should check this bit before writing a new value to
N * |        |          |RX_ERETRY and TX_ERETRY.
N * |        |          |0 = synchronizing is completion, user can write new data to RX_ERETRY and TX_ERETRY.
N * |        |          |1 = Last value is synchronizing.
N * |        |          |Note: This bit is read only.
N * @var SC_T::ALTCTL
N * Offset: 0x08  SC Alternate Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_RST    |TX Software Reset
N * |        |          |When TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will
N * |        |          |be cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note:
N * |        |          |This bit will be auto cleared after reset is complete.
N * |[1]     |RX_RST    |Rx Software Reset
N * |        |          |When RX_RST is set, all the bytes in the receiver buffer and Rx internal state machine will
N * |        |          |be cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the Rx internal state machine and pointers.
N * |        |          |Note:
N * |        |          |This bit will be auto cleared after reset is complete.
N * |[2]     |DACT_EN   |Deactivation Sequence Generator Enable Control
N * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Deactivation sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the deactivation sequence completed, this bit will be cleared automatically and the
N * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TX_RST, and RX_RST at the same time.
N * |        |          |Note3:
N * |        |          |If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[3]     |ACT_EN    |Activation Sequence Generator Enable Control
N * |        |          |This bit enables SC controller to initiate the card by activation sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Activation sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the activation sequence completed, this bit will be cleared automatically and the
N * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill
N * |        |          |this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note3:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[4]     |WARST_EN  |Warm Reset Sequence Generator Enable Control
N * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Warm reset sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the warm reset sequence completed, this bit will be cleared automatically and the
N * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill
N * |        |          |this bit, TX_RST, and RX_RST at the same time.
N * |        |          |Note3:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[5]     |TMR0_SEN  |Internal Timer0 Start Enable Control
N * |        |          |This bit enables Timer 0 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 24 bit timer when TMR_SEL (SC_CTL[14:13]) = 01.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMR0[26] = 0), this bit will be
N * |        |          |auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TX_RST and RX_RST at the same time.
N * |        |          |Note4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[6]     |TMR1_SEN  |Internal Timer1 Start Enable Control
N * |        |          |This bit enables Timer 1 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 8 bit timer when TMR_SEL(SC_CTL[14:13]) = 10 or
N * |        |          |TMR_SEL(SC_CTL[14:13]) = 11.
N * |        |          |Don't filled TMR1_SEN when TMR_SEL(SC_CTL[14:13]) = 00 or TMR_SEL(SC_CTL[14:13]) = 01.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMR1[26] = 0), this bit will be
N * |        |          |auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill
N * |        |          |this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note4:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[7]     |TMR2_SEN  |Internal Timer2 Start Enable Control
N * |        |          |This bit enables Timer 2 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 8 bit timer when TMR_SEL(SC_CTL[14:13]) = 11.
N * |        |          |Don't filled TMR2_SEN when TMR_SEL(SC_CTL[14:13]) = 00 or TMR_SEL(SC_CTL[14:13]) = 01 or
N * |        |          |TMR_SEL(SC_CTL[14:13]) = 10.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMR2[26] = 0), this bit will be
N * |        |          |auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note4:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[9:8]   |INIT_SEL  |Initial Timing Selection
N * |        |          |This fields indicates the timing of hardware initial state (activation or warm-reset or
N * |        |          |deactivation).
N * |        |          |Unit: SC clock
N * |        |          |Activation: refer to SC Activation Sequence in Figure 5-100.
N * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 5-101.
N * |        |          |Deactivation: refer to Deactivation Sequence in Figure 5-102.
N * |[12]    |RX_BGT_EN |Receiver Block Guard Time Function Enable Control
N * |        |          |0 = Receiver block guard time function Disabled.
N * |        |          |1 = Receiver block guard time function Enabled.
N * |[13]    |TMR0_ATV  |Internal Timer0 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer0.
N * |        |          |0 = Timer0 is not active.
N * |        |          |1 = Timer0 is active.
N * |[14]    |TMR1_ATV  |Internal Timer1 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer1.
N * |        |          |0 = Timer1 is not active.
N * |        |          |1 = Timer1 is active.
N * |[15]    |TMR2_ATV  |Internal Timer2 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer2.
N * |        |          |0 = Timer2 is not active.
N * |        |          |1 = Timer2 is active.
N * |[16]    |OUTSEL    |Smartcard Data Pin Output Mode Selection
N * |        |          |Use this bit to select smartcard data pin (SC_DATA) output mode
N * |        |          |0 = Quasi mode.
N * |        |          |1 = Open-drain mode.
N * @var SC_T::EGTR
N * Offset: 0x0C  SC Extend Guard Time Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |EGT       |Extended Guard Time
N * |        |          |This field indicates the extended guard timer value.
N * |        |          |Note:
N * |        |          |The counter is ETU base and the real extended guard time is EGT.
N * @var SC_T::RFTMR
N * Offset: 0x10  SC Receive buffer Time-out Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |RFTM      |SC Receiver Buffer Time-Out (ETU Base)
N * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data
N * |        |          |word.
N * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by
N * |        |          |reading SC_RBR buffer, a receiver time-out interrupt INT_RTMR will be generated(if
N * |        |          |RTMR_IE(SC_IER[9]) = 1 ).
N * |        |          |Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5
N * |        |          |Note2:
N * |        |          |Fill all 0 to this field indicates to disable this function.
N * @var SC_T::ETUCR
N * Offset: 0x14  SC ETU Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |ETU_RDIV  |ETU Rate Divider
N * |        |          |The field indicates the clock rate divider.
N * |        |          |The real ETU is ETU_RDIV + 1.
N * |        |          |Note:
N * |        |          |Software can configure this field, but this field must be greater than 0x004.
N * |[15]    |COMPEN_EN |Compensation Mode Enable Control
N * |        |          |This bit enables clock compensation function.
N * |        |          |When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles,
N * |        |          |where n is the value to be written into the ETU_RDIV .
N * |        |          |0 = Compensation function Disabled.
N * |        |          |1 = Compensation function Enabled.
N * @var SC_T::IER
N * Offset: 0x18  SC Interrupt Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IE    |Receive Data Reach Interrupt Enable Control
N * |        |          |This field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6])
N * |        |          |interrupt enable.
N * |        |          |0 = Receive data reach trigger level interrupt Disabled.
N * |        |          |1 = Receive data reach trigger level interrupt Enabled.
N * |[1]     |TXBE_IE   |Transmit Buffer Empty Interrupt Enable Control
N * |        |          |This field is used for transmit buffer empty interrupt enable.
N * |        |          |0 = Transmit buffer empty interrupt Disabled.
N * |        |          |1 = Transmit buffer empty interrupt Enabled.
N * |[2]     |TERR_IE   |Transfer Error Interrupt Enable Control
N * |        |          |This field is used for transfer error interrupt enable.
N * |        |          |The transfer error states is at SC_SR register which includes receiver break error
N * |        |          |RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_SR[5]), parity error RX_EPA_F(SC_SR[4]),
N * |        |          |receiver buffer overflow error RX_OVER_F(SC_SR[0]), transmit buffer overflow error
N * |        |          |TX_OVER_F(SC_SR[8]), receiver retry over limit error RX_OVER_REERR(SC_SR[22]) and
N * |        |          |transmitter retry over limit error TX_OVER_REERR(SC_SR[30]).
N * |        |          |0 = Transfer error interrupt Disabled.
N * |        |          |1 = Transfer error interrupt Enabled.
N * |[3]     |TMR0_IE   |Timer0 Interrupt Enable Control
N * |        |          |This field is used to enable TMR0 interrupt enable.
N * |        |          |0 = Timer0 interrupt Disabled.
N * |        |          |1 = Timer0 interrupt Enabled.
N * |[4]     |TMR1_IE   |Timer1 Interrupt Enable Control
N * |        |          |This field is used to enable the TMR1 interrupt.
N * |        |          |0 = Timer1 interrupt Disabled.
N * |        |          |1 = Timer1 interrupt Enabled.
N * |[5]     |TMR2_IE   |Timer2 Interrupt Enable Control
N * |        |          |This field is used for TMR2 interrupt enable.
N * |        |          |0 = Timer2 interrupt Disabled.
N * |        |          |1 = Timer2 interrupt Enabled.
N * |[6]     |BGT_IE    |Block Guard Time Interrupt Enable Control
N * |        |          |This field is used for block guard time interrupt enable.
N * |        |          |0 = Block guard time Disabled.
N * |        |          |1 = Block guard time Enabled.
N * |[7]     |CD_IE     |Card Detect Interrupt Enable Control
N * |        |          |This field is used for card detect interrupt enable. The card detect status is
N * |        |          |CD_INS_F(SC_SR[12])
N * |        |          |0 = Card detect interrupt Disabled.
N * |        |          |1 = Card detect interrupt Enabled.
N * |[8]     |INIT_IE   |Initial End Interrupt Enable Control
N * |        |          |This field is used for activation (ACT_EN(SC_ALTCTL[3] = 1)), deactivation ((DACT_EN
N * |        |          |SC_ALTCTL[2]) = 1) and warm reset (WARST_EN (SC_ALTCTL [4])) sequence interrupt enable.
N * |        |          |0 = Initial end interrupt Disabled.
N * |        |          |1 = Initial end interrupt Enabled.
N * |[9]     |RTMR_IE   |Receiver Buffer Time-Out Interrupt Enable Control
N * |        |          |This field is used for receiver buffer time-out interrupt enable.
N * |        |          |0 = Receiver buffer time-out interrupt Disabled.
N * |        |          |1 = Receiver buffer time-out interrupt Enabled.
N * |[10]    |ACON_ERR_IE|Auto Convention Error Interrupt Enable Control
N * |        |          |This field is used for auto-convention error interrupt enable.
N * |        |          |0 = Auto-convention error interrupt Disabled.
N * |        |          |1 = Auto-convention error interrupt Enabled.
N * @var SC_T::ISR
N * Offset: 0x1C  SC Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IS    |Receive Data Reach Interrupt Status Flag (Read Only)
N * |        |          |This field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6])
N * |        |          |interrupt status flag.
N * |        |          |Note: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]).
N * |        |          |If software reads data from SC_RBR and receiver buffer data byte number is less than
N * |        |          |RX_FTRI_LEV (SC_CTL[7:6]), this bit will be cleared automatically.
N * |[1]     |TBE_IS    |Transmit Buffer Empty Interrupt Status Flag (Read Only)
N * |        |          |This field is used for transmit buffer empty interrupt status flag.
N * |        |          |Note: This field is the status flag of transmit buffer empty state.
N * |        |          |If software wants to clear this bit, software must write data to THR(SC_THR[7:0]) buffer and
N * |        |          |then this bit will be cleared automatically.
N * |[2]     |TERR_IS   |Transfer Error Interrupt Status Flag (Read Only)
N * |        |          |This field is used for transfer error interrupt status flag.
N * |        |          |The transfer error states is at SC_SR register which includes receiver break error
N * |        |          |RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_TRSR[5], parity error RX_EPA_F(SC_TRSR[4] and
N * |        |          |receiver buffer overflow error RX_OVER_F(SC_TRSR[0]), transmit buffer overflow error
N * |        |          |TX_OVER_F(SC_TRSR[8]), receiver retry over limit error RX_OVER_REERR(SC_TRSR[22] and
N * |        |          |transmitter retry over limit error TX_OVER_REERR(SC_TRSR[30]).
N * |        |          |Note: This field is the status flag of
N * |        |          |RX_EBR_F(SC_TRSR[6]), RX_EFR_F(SC_TRSR[5]), RX_EPA_F(SC_TRSR[4]), RX_OVER_F(SC_TRSR[0]),
N * |        |          |TX_OVER_F(SC_TRSR[8]), RX_OVER_REERR(SC_TRSR[22]) or TX_OVER_REERR(SC_TRSR[30]).
N * |        |          |So, if software wants to clear this bit, software must write 1 to each field.
N * |[3]     |TMR0_IS   |Timer0 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR0 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[4]     |TMR1_IS   |Timer1 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR1 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[5]     |TMR2_IS   |Timer2 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR2 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[6]     |BGT_IS    |Block   Guard Time Interrupt Status Flag (Read Only)
N * |        |          |This field   is used for block guard time interrupt status flag.
N * |        |          |Note1: This bit is valid when RX_BGT_EN   (SC_ALTCTL[12]) is enabled.
N * |        |          |Note2: This bit is read only, but it can be cleared by   writing "1" to it.
N * |[7]     |CD_IS     |Card Detect Interrupt Status Flag (Read Only)
N * |        |          |This field is used for card detect interrupt status flag.
N * |        |          |The card detect status is CD_INS_F (SC_SR[12]) and CD_REM_F(SC_SR[11]).
N * |        |          |Note:
N * |        |          |This field is the status flag of CD_INS_F(SC_SR[12]) or CD_REM_F(SC_TRSR[11])].
N * |        |          |So if software wants to clear this bit, software must write 1 to this field.
N * |[8]     |INIT_IS   |Initial End Interrupt Status Flag (Read Only)
N * |        |          |This field is used for activation (ACT_EN(SC_ALTCTL[3])), deactivation (DACT_EN
N * |        |          |(SC_ALTCTL[2])) and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[9]     |RTMR_IS   |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
N * |        |          |This field is used for receiver buffer time-out interrupt status flag.
N * |        |          |Note: This field is the status flag of receiver buffer time-out state.
N * |        |          |If software wants to clear this bit, software must read all receiver buffer remaining data
N * |        |          |by reading SC_RBR buffer,.
N * |[10]    |ACON_ERR_IS|Auto Convention Error Interrupt Status Flag (Read Only)
N * |        |          |This field indicates auto convention sequence error.
N * |        |          |If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * @var SC_T::TRSR
N * Offset: 0x20  SC Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_OVER_F |RX Overflow Error Status Flag (Read Only)
N * |        |          |This bit is set when RX buffer overflow.
N * |        |          |If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be
N * |        |          |set.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[1]     |RX_EMPTY_F|Receiver Buffer Empty Status Flag(Read Only)
N * |        |          |This bit indicates RX buffer empty or not.
N * |        |          |When the last byte of Rx buffer has been read by CPU, hardware sets this bit high.
N * |        |          |It will be cleared when SC receives any new data.
N * |[2]     |RX_FULL_F |Receiver Buffer Full Status Flag (Read Only)
N * |        |          |This bit indicates RX buffer full or not.
N * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N * |[4]     |RX_EPA_F  |Receiver Parity Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid
N * |        |          |"parity bit".
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will
N * |        |          |not set this flag.
N * |[5]     |RX_EFR_F  |Receiver Frame Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit"
N * |        |          |(that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will
N * |        |          |not set this flag.
N * |[6]     |RX_EBR_F  |Receiver Break Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received data input (RX) held in the "spacing state"
N * |        |          |(logic 0) is longer than a full word transmission time (that is, the total time of "start bit"
N * |        |          | + data bits + parity + stop bits).
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will
N * |        |          |not set this flag.
N * |[8]     |TX_OVER_F |TX Overflow Error Interrupt Status Flag (Read Only)
N * |        |          |If TX buffer is full, an additional write to THR(SC_THR[7:0]) will cause this bit be set to
N * |        |          |"1" by hardware.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[9]     |TX_EMPTY_F|Transmit Buffer Empty Status Flag (Read Only)
N * |        |          |This bit indicates TX buffer empty or not.
N * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware
N * |        |          |sets this bit high.
N * |        |          |It will be cleared when writing data into THR(SC_THR[7:0]) (TX buffer not empty).
N * |[10]    |TX_FULL_F |Transmit Buffer Full Status Flag (Read Only)
N * |        |          |This bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4,
N * |        |          |otherwise is cleared by hardware.
N * |[17:16] |RX_POINT_F|Receiver Buffer Pointer Status Flag (Read Only)
N * |        |          |This field indicates the RX buffer pointer status flag.
N * |        |          |When SC receives one byte from external device, RX_POINT_F(SC_SR[17:16]) increases one.
N * |        |          |When one byte of RX buffer is read by CPU, RX_POINT_F(SC_SR[17:16]) decreases one.
N * |[21]    |RX_REERR  |Receiver Retry Error (Read Only)
N * |        |          |This bit is set by hardware when RX has any error and retries transfer.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
N * |        |          |Note3: If CPU enables receiver retry function by setting RX_ERETRY_EN
N * |        |          |(SC_CTL[19]) , the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set
N * |        |          |RX_EPA_F(SC_TRSR[4])).
N * |[22]    |RX_OVER_REERR|Receiver Over Retry Error (Read Only)
N * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: If CPU enables receiver retries function by setting RX_ERETRY_EN
N * |        |          |(SC_CTL[19]), the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set
N * |        |          |RX_EPA_F(SC_TRSR[4])).
N * |[23]    |RX_ATV    |Receiver In Active Status Flag (Read Only)
N * |        |          |This bit is set by hardware when RX transfer is in active.
N * |        |          |This bit is cleared automatically when RX transfer is finished.
N * |[25:24] |TX_POINT_F|Transmit Buffer Pointer Status Flag (Read Only)
N * |        |          |This field indicates the TX buffer pointer status flag.
N * |        |          |When CPU writes data into SC_THR, TX_POINT_F increases one.
N * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F
N * |        |          |decreases one.
N * |[29]    |TX_REERR  |Transmitter Retry Error (Read Only)
N * |        |          |This bit is set by hardware when transmitter re-transmits.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
N * |[30]    |TX_OVER_REERR|Transmitter Over Retry Error (Read Only)
N * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[31]    |TX_ATV    |Transmit In Active Status Flag (Read Only)
N * |        |          |0 = This bit is cleared automatically when TX transfer is finished or the last byte
N * |        |          |transmission has completed.
N * |        |          |1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last
N * |        |          |byte has been transmitted.
N * @var SC_T::PINCSR
N * Offset: 0x24  SC Pin Control State Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |POW_EN    |SC_POW_EN Pin Signal
N * |        |          |Software can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in
N * |        |          |high or low level.
N * |        |          |Write this field to drive SC_PWR pin
N * |        |          |Refer POW_INV (SC_PINCSR[11]) description for programming SC_PWR pin voltage level.
N * |        |          |Read this field to get SC_PWR pin status.
N * |        |          |0 = SC_PWR pin status is low.
N * |        |          |1 = SC_PWR pin status is high.
N * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be
N * |        |          |changed automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[1]     |SC_RST    |SC_RST Pin Signal
N * |        |          |This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting
N * |        |          |this bit.
N * |        |          |Write this field to drive SC_RST pin.
N * |        |          |0 = Drive SC_RST pin to low.
N * |        |          |1 = Drive SC_RST pin to high.
N * |        |          |Read this field to get SC_RST pin status.
N * |        |          |0 = SC_RST pin status is low.
N * |        |          |1 = SC_RST pin status is high.
N * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be
N * |        |          |changed automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[2]     |CD_REM_F  |Card Detect Removal Status Of SC_CD Pin (Read Only)
N * |        |          |This bit is set whenever a card has been removed.
N * |        |          |0 = No effect.
N * |        |          |1 = Card removed.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: Card detect engine will start after SC_CEN (SC_CTL[0] )set.
N * |[3]     |CD_INS_F  |Card Detect Insert Status Of SC_CD Pin (Read Only)
N * |        |          |This bit is set whenever card has been inserted.
N * |        |          |0 = No effect.
N * |        |          |1 = Card insert.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: The
N * |        |          |card detect engine will start after SC_CEN (SC_CTL[0] )set.
N * |[4]     |CD_PIN_ST |Card Detect Status Of SC_CD Pin Status (Read Only)
N * |        |          |This bit is the pin status flag of SC_CD
N * |        |          |0 = The SC_CD pin state at low.
N * |        |          |1 = The SC_CD pin state at high.
N * |[6]     |CLK_KEEP  |SC Clock Enable Control
N * |        |          |0 = SC clock generation Disabled.
N * |        |          |1 = SC clock always keeps free running.
N * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be
N * |        |          |changed automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[7]     |ADAC_CD_EN|Auto Deactivation When Card Removal
N * |        |          |0 = Auto deactivation Disabled when hardware detected the card removal.
N * |        |          |1 = Auto deactivation Enabled when hardware detected the card removal.
N * |        |          |Note: When the card is removed, hardware will stop any process and then do deactivation
N * |        |          |sequence (if this bit be setting).
N * |        |          |If this process completes.
N * |        |          |Hardware will generate an initial end.
N * |        |          |interrupt to CPU.
N * |[8]     |SC_OEN_ST |SC Data Output Enable Pin Status (Read Only)
N * |        |          |This bit is the pin status of SC_DATA_OEN
N * |        |          |0 = The SC_DATA_OEN pin state at low.
N * |        |          |1 = The SC_DATA_OEN pin state at high.
N * |[9]     |SC_DATA_O |SC Data Output Pin
N * |        |          |This bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by
N * |        |          |setting this bit.
N * |        |          |0 = Drive SC_DATA_O pin to low.
N * |        |          |1 = Drive SC_DATA_O pin to high.
N * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed
N * |        |          |automatically.
N * |        |          |So don't fill this field when SC is in these modes.
N * |[10]    |CD_LEV    |Card Detect Level
N * |        |          |0 = When hardware detects the card detect pin from high to low, it indicates a card is
N * |        |          |detected.
N * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is
N * |        |          |detected.
N * |        |          |Note: Software must select card detect level before Smart Card engine is enabled
N * |[11]    |POW_INV   |SC_POW Pin Inverse
N * |        |          |This bit is used for inverse the SC_POW pin.
N * |        |          |There are four kinds of combination for SC_POW pin setting by POW_INV(SC_PINCSR[11]) and
N * |        |          |POW_EN(SC_PINCSR[0]).
N * |        |          |POW_INV (SC_PINCSR[11]) is bit 1 and POW_EN(SC_PINCSR[0]) is bit 0 for SC_POW_Pin as high or
N * |        |          |low voltage selection.
N * |        |          |00 = SC_POW_ Pin is 0.
N * |        |          |01 = SC_POW _Pin is 1.
N * |        |          |10 = SC_POW _Pin is 1.
N * |        |          |11 = SC_POW_ Pin is 0.
N * |        |          |Note: Software must select POW_INV (SC_PINCSR[11]) before Smart Card is enabled by SC_CEN
N * |        |          |(SC_CTL[0]).
N * |[16]    |SC_DATA_I_ST|SC Data Pin Status (Read Only)
N * |        |          |This bit is the pin status of SC_DATA
N * |        |          |0 = The SC_DATA pin is low.
N * |        |          |1 = The SC_DATA pin is high.
N * |[30]    |SYNC      |SYNC Flag Indicator
N * |        |          |Due to synchronization, software should check this bit when writing a new value to SC_PINCSR
N * |        |          |register.
N * |        |          |0 = Synchronizing is completion, user can write new data to SC_PINCSR register.
N * |        |          |1 = Last value is synchronizing.
N * |        |          |Note: This bit is read only.
N * @var SC_T::TMR0
N * Offset: 0x28  SC Internal Timer Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CNT0      |Timer 0 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |MODE      |Timer 0 Operation Mode Selection
N * |        |          |This field indicates the internal 24-bit timer operation selection.
N * |        |          |Refer to 5.15.5.4 for programming Timer0
N * @var SC_T::TMR1
N * Offset: 0x2C  SC Internal Timer Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT1      |Timer 1 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |MODE      |Timer 1 Operation Mode Selection
N * |        |          |This field indicates the internal 8-bit timer operation selection.
N * |        |          |Refer to 5.15.5.4 for programming Timer1
N * @var SC_T::TMR2
N * Offset: 0x30  SC Internal Timer Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT2      |Timer 2 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |MODE      |Timer 2 Operation Mode Selection
N * |        |          |This field indicates the internal 8-bit timer operation selection
N * |        |          |Refer to 5.15.5.4 for programming Timer2
N * @var SC_T::TDRA
N * Offset: 0x38  SC Timer Current Data Register A
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TDR0      |Timer0 Current Data value(Read Only)
N * |        |          |This field indicates the current count values of timer0.
N * @var SC_T::TDRB
N * Offset: 0x3C  SC Timer Current Data Register B
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TDR1      |Timer1 Current Data value(Read Only)
N * |        |          |This field indicates the current count values of timer1.
N * |[15:8]  |TDR2      |Timer2 Current Data value (Read Only)
N * |        |          |This field indicates the current count values of timer2.
N */
N
N    __I  uint32_t RBR;           /* Offset: 0x00  SC Receiving Buffer Register.                                      */
X    volatile const  uint32_t RBR;            
N    __O  uint32_t THR;           /* Offset: 0x00  SC Transmit Holding Register                                       */
X    volatile  uint32_t THR;            
N    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register                                                */
X    volatile uint32_t CTL;            
N    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register                                      */
X    volatile uint32_t ALTCTL;         
N    __IO uint32_t EGTR;          /* Offset: 0x0C  SC Extend Guard Time Register                                      */
X    volatile uint32_t EGTR;           
N    __IO uint32_t RFTMR;         /* Offset: 0x10  SC Receive buffer Time-out Register                                */
X    volatile uint32_t RFTMR;          
N    __IO uint32_t ETUCR;         /* Offset: 0x14  SC ETU Control Register                                            */
X    volatile uint32_t ETUCR;          
N    __IO uint32_t IER;           /* Offset: 0x18  SC Interrupt Enable Control Register                               */
X    volatile uint32_t IER;            
N    __IO uint32_t ISR;           /* Offset: 0x1C  SC Interrupt Status Register                                       */
X    volatile uint32_t ISR;            
N    __IO uint32_t TRSR;          /* Offset: 0x20  SC Status Register                                                 */
X    volatile uint32_t TRSR;           
N    __IO uint32_t PINCSR;        /* Offset: 0x24  SC Pin Control State Register                                      */
X    volatile uint32_t PINCSR;         
N    __IO uint32_t TMR0;          /* Offset: 0x28  SC Internal Timer Control Register 0                               */
X    volatile uint32_t TMR0;           
N    __IO uint32_t TMR1;          /* Offset: 0x2C  SC Internal Timer Control Register 1                               */
X    volatile uint32_t TMR1;           
N    __IO uint32_t TMR2;          /* Offset: 0x30  SC Internal Timer Control Register 2                               */
X    volatile uint32_t TMR2;           
N    __I  uint32_t RESERVED0;    
X    volatile const  uint32_t RESERVED0;    
N    __I  uint32_t TDRA;          /* Offset: 0x38  SC Timer Current Data Register A                                   */
X    volatile const  uint32_t TDRA;           
N    __I  uint32_t TDRB;          /* Offset: 0x3C  SC Timer Current Data Register B                                   */
X    volatile const  uint32_t TDRB;           
N
N} SC_T;
N
N
N
N/**
N    @addtogroup SC_CONST SC Bit Field Definition
N    Constant Definitions for SC Controller
N@{ */
N
N/* SC RBR Bit Field Definitions */
N#define SC_RBR_RBR_Pos                      0                                /*!< SC_T::RBR: RBR Position */
N#define SC_RBR_RBR_Msk                      (0xFFul << SC_RBR_RBR_Pos)       /*!< SC_T::RBR: RBR Mask */
N
N/* SC THR Bit Field Definitions */
N#define SC_THR_THR_Pos                      0                                /*!< SC_T::THR: THR Position */
N#define SC_THR_THR_Msk                      (0xFFul << SC_THR_THR_Pos)       /*!< SC_T::THR: THR Mask */
N
N/* SC CTL Bit Field Definitions */
N#define SC_CTL_SYNC_Pos                     30                               /*!< SC_T::CTL: SYNC Position */
N#define SC_CTL_SYNC_Msk                     (1ul << SC_CTL_SYNC_Pos)         /*!< SC_T::CTL: SYNC Mask */
N
N#define SC_CTL_CD_DEB_SEL_Pos               24                               /*!< SC_T::CTL: CD_DEB_SEL Position */
N#define SC_CTL_CD_DEB_SEL_Msk               (3ul << SC_CTL_CD_DEB_SEL_Pos)   /*!< SC_T::CTL: CD_DEB_SEL Mask */
N
N#define SC_CTL_TX_ERETRY_EN_Pos             23                               /*!< SC_T::CTL: TX_ERETRY_EN Position */
N#define SC_CTL_TX_ERETRY_EN_Msk             (1ul << SC_CTL_TX_ERETRY_EN_Pos) /*!< SC_T::CTL: TX_ERETRY_EN Mask */
N
N#define SC_CTL_TX_ERETRY_Pos                20                               /*!< SC_T::CTL: TX_ERETRY Position */
N#define SC_CTL_TX_ERETRY_Msk                (7ul << SC_CTL_TX_ERETRY_Pos)    /*!< SC_T::CTL: TX_ERETRY Mask */
N
N#define SC_CTL_RX_ERETRY_EN_Pos             19                               /*!< SC_T::CTL: RX_ERETRY_EN Position */
N#define SC_CTL_RX_ERETRY_EN_Msk             (1ul << SC_CTL_RX_ERETRY_EN_Pos) /*!< SC_T::CTL: RX_ERETRY_EN Mask */
N
N#define SC_CTL_RX_ERETRY_Pos                16                               /*!< SC_T::CTL: RX_ERETRY Position */
N#define SC_CTL_RX_ERETRY_Msk                (7ul << SC_CTL_RX_ERETRY_Pos)    /*!< SC_T::CTL: RX_ERETRY Mask */
N
N#define SC_CTL_SLEN_Pos                     15                               /*!< SC_T::CTL: SLEN Position */
N#define SC_CTL_SLEN_Msk                     (1ul << SC_CTL_SLEN_Pos)         /*!< SC_T::CTL: SLEN Mask */
N
N#define SC_CTL_TMR_SEL_Pos                  13                               /*!< SC_T::CTL: TMR_SEL Position */
N#define SC_CTL_TMR_SEL_Msk                  (3ul << SC_CTL_TMR_SEL_Pos)      /*!< SC_T::CTL: TMR_SEL Mask */
N
N#define SC_CTL_BGT_Pos                      8                                /*!< SC_T::CTL: BGT Position */
N#define SC_CTL_BGT_Msk                      (0x1Ful << SC_CTL_BGT_Pos)       /*!< SC_T::CTL: BGT Mask */
N
N#define SC_CTL_RX_FTRI_LEV_Pos              6                                /*!< SC_T::CTL: RX_FTRI_LEV Position */
N#define SC_CTL_RX_FTRI_LEV_Msk              (3ul << SC_CTL_RX_FTRI_LEV_Pos)  /*!< SC_T::CTL: RX_FTRI_LEV Mask */
N
N#define SC_CTL_CON_SEL_Pos                  4                                /*!< SC_T::CTL: CON_SEL Position */
N#define SC_CTL_CON_SEL_Msk                  (3ul << SC_CTL_CON_SEL_Pos)      /*!< SC_T::CTL: CON_SEL Mask */
N
N#define SC_CTL_AUTO_CON_EN_Pos              3                                /*!< SC_T::CTL: AUTO_CON_EN Position */
N#define SC_CTL_AUTO_CON_EN_Msk              (1ul << SC_CTL_AUTO_CON_EN_Pos)  /*!< SC_T::CTL: AUTO_CON_EN Mask */
N
N#define SC_CTL_DIS_TX_Pos                   2                                /*!< SC_T::CTL: DIS_TX Position */
N#define SC_CTL_DIS_TX_Msk                   (1ul << SC_CTL_DIS_TX_Pos)       /*!< SC_T::CTL: DIS_TX Mask */
N
N#define SC_CTL_DIS_RX_Pos                   1                                /*!< SC_T::CTL: DIS_RX Position */
N#define SC_CTL_DIS_RX_Msk                   (1ul << SC_CTL_DIS_RX_Pos)       /*!< SC_T::CTL: DIS_RX Mask */
N
N#define SC_CTL_SC_CEN_Pos                   0                                /*!< SC_T::CTL: SC_CEN Position */
N#define SC_CTL_SC_CEN_Msk                   (1ul << SC_CTL_SC_CEN_Pos)       /*!< SC_T::CTL: SC_CEN Mask */
N
N/* SC ALTCTL Bit Field Definitions */
N#define SC_ALTCTL_OUTSEL_Pos                16                               /*!< SC_T::ALTCTL: OUTSEL Position */
N#define SC_ALTCTL_OUTSEL_Msk                (1ul << SC_ALTCTL_OUTSEL_Pos)    /*!< SC_T::ALTCTL: OUTSEL Mask */
N
N#define SC_ALTCTL_TMR2_ATV_Pos              15                               /*!< SC_T::ALTCTL: TMR2_ATV Position */
N#define SC_ALTCTL_TMR2_ATV_Msk              (1ul << SC_ALTCTL_TMR2_ATV_Pos)  /*!< SC_T::ALTCTL: TMR2_ATV Mask */
N
N#define SC_ALTCTL_TMR1_ATV_Pos              14                               /*!< SC_T::ALTCTL: TMR1_ATV Position */
N#define SC_ALTCTL_TMR1_ATV_Msk              (1ul << SC_ALTCTL_TMR1_ATV_Pos)  /*!< SC_T::ALTCTL: TMR1_ATV Mask */
N
N#define SC_ALTCTL_TMR0_ATV_Pos              13                               /*!< SC_T::ALTCTL: TMR0_ATV Position */
N#define SC_ALTCTL_TMR0_ATV_Msk              (1ul << SC_ALTCTL_TMR0_ATV_Pos)  /*!< SC_T::ALTCTL: TMR0_ATV Mask */
N
N#define SC_ALTCTL_RX_BGT_EN_Pos             12                               /*!< SC_T::ALTCTL: RX_BGT_EN Position */
N#define SC_ALTCTL_RX_BGT_EN_Msk             (1ul << SC_ALTCTL_RX_BGT_EN_Pos) /*!< SC_T::ALTCTL: RX_BGT_EN Mask */
N
N#define SC_ALTCTL_INIT_SEL_Pos              8                                /*!< SC_T::ALTCTL: INIT_SEL Position */
N#define SC_ALTCTL_INIT_SEL_Msk              (3ul << SC_ALTCTL_INIT_SEL_Pos)  /*!< SC_T::ALTCTL: INIT_SEL Mask */
N
N#define SC_ALTCTL_TMR2_SEN_Pos              7                                /*!< SC_T::ALTCTL: TMR2_SEN Position */
N#define SC_ALTCTL_TMR2_SEN_Msk              (1ul << SC_ALTCTL_TMR2_SEN_Pos)  /*!< SC_T::ALTCTL: TMR2_SEN Mask */
N
N#define SC_ALTCTL_TMR1_SEN_Pos              6                                /*!< SC_T::ALTCTL: TMR1_SEN Position */
N#define SC_ALTCTL_TMR1_SEN_Msk              (1ul << SC_ALTCTL_TMR1_SEN_Pos)  /*!< SC_T::ALTCTL: TMR1_SEN Mask */
N
N#define SC_ALTCTL_TMR0_SEN_Pos              5                                /*!< SC_T::ALTCTL: TMR0_SEN Position */
N#define SC_ALTCTL_TMR0_SEN_Msk              (1ul << SC_ALTCTL_TMR0_SEN_Pos)  /*!< SC_T::ALTCTL: TMR0_SEN Mask */
N
N#define SC_ALTCTL_WARST_EN_Pos              4                                /*!< SC_T::ALTCTL: WARST_EN Position */
N#define SC_ALTCTL_WARST_EN_Msk              (1ul << SC_ALTCTL_WARST_EN_Pos)  /*!< SC_T::ALTCTL: WARST_EN Mask */
N
N#define SC_ALTCTL_ACT_EN_Pos                3                                /*!< SC_T::ALTCTL: ACT_EN Position */
N#define SC_ALTCTL_ACT_EN_Msk                (1ul << SC_ALTCTL_ACT_EN_Pos)    /*!< SC_T::ALTCTL: ACT_EN Mask */
N
N#define SC_ALTCTL_DACT_EN_Pos               2                                /*!< SC_T::ALTCTL: DACT_EN Position */
N#define SC_ALTCTL_DACT_EN_Msk               (1ul << SC_ALTCTL_DACT_EN_Pos)   /*!< SC_T::ALTCTL: DACT_EN Mask */
N
N#define SC_ALTCTL_RX_RST_Pos                1                                /*!< SC_T::ALTCTL: RX_RST Position */
N#define SC_ALTCTL_RX_RST_Msk                (1ul << SC_ALTCTL_RX_RST_Pos)    /*!< SC_T::ALTCTL: RX_RST Mask */
N
N#define SC_ALTCTL_TX_RST_Pos                0                                /*!< SC_T::ALTCTL: TX_RST Position */
N#define SC_ALTCTL_TX_RST_Msk                (1ul << SC_ALTCTL_TX_RST_Pos)    /*!< SC_T::ALTCTL: TX_RST Mask */
N
N/* SC EGTR Bit Field Definitions */
N#define SC_EGTR_EGT_Pos                     0                               /*!< SC_T::EGTR: EGT Position */
N#define SC_EGTR_EGT_Msk                     (0xFFul << SC_EGTR_EGT_Pos)     /*!< SC_T::EGTR: EGT Mask */
N
N/* SC RFTMR Bit Field Definitions */
N#define SC_RFTMR_RFTM_Pos                   0                               /*!< SC_T::RFTMR: RFTM Position */
N#define SC_RFTMR_RFTM_Msk                   (0x1FFul << SC_RFTMR_RFTM_Pos)  /*!< SC_T::RFTMR: RFTM Mask */
N
N/* SC ETUCR Bit Field Definitions */
N#define SC_ETUCR_COMPEN_EN_Pos              15                               /*!< SC_T::ETUCR: COMPEN_EN Position */
N#define SC_ETUCR_COMPEN_EN_Msk              (1ul << SC_ETUCR_COMPEN_EN_Pos)  /*!< SC_T::ETUCR: COMPEN_EN Mask */
N
N#define SC_ETUCR_ETU_RDIV_Pos               0                                   /*!< SC_T::ETUCR: ETU_RDIV Position */
N#define SC_ETUCR_ETU_RDIV_Msk               (0xFFFul << SC_ETUCR_ETU_RDIV_Pos)  /*!< SC_T::ETUCR: ETU_RDIV Mask */
N
N/* SC IER Bit Field Definitions */
N#define SC_IER_ACON_ERR_IE_Pos              10                                  /*!< SC_T::IER: ACON_ERR_IE Position */
N#define SC_IER_ACON_ERR_IE_Msk              (1ul << SC_IER_ACON_ERR_IE_Pos)     /*!< SC_T::IER: ACON_ERR_IE Mask */
N
N#define SC_IER_RTMR_IE_Pos                  9                               /*!< SC_T::IER: RTMR_IE Position */
N#define SC_IER_RTMR_IE_Msk                  (1ul << SC_IER_RTMR_IE_Pos)     /*!< SC_T::IER: RTMR_IE Mask */
N
N#define SC_IER_INIT_IE_Pos                  8                               /*!< SC_T::IER: INIT_IE Position */
N#define SC_IER_INIT_IE_Msk                  (1ul << SC_IER_INIT_IE_Pos)     /*!< SC_T::IER: INIT_IE Mask */
N
N#define SC_IER_CD_IE_Pos                    7                               /*!< SC_T::IER: CD_IE Position */
N#define SC_IER_CD_IE_Msk                    (1ul << SC_IER_CD_IE_Pos)       /*!< SC_T::IER: CD_IE Mask */
N
N#define SC_IER_BGT_IE_Pos                   6                               /*!< SC_T::IER: BGT_IE Position */
N#define SC_IER_BGT_IE_Msk                   (1ul << SC_IER_BGT_IE_Pos)      /*!< SC_T::IER: BGT_IE Mask */
N
N#define SC_IER_TMR2_IE_Pos                  5                               /*!< SC_T::IER: TMR2_IE Position */
N#define SC_IER_TMR2_IE_Msk                  (1ul << SC_IER_TMR2_IE_Pos)     /*!< SC_T::IER: TMR2_IE Mask */
N
N#define SC_IER_TMR1_IE_Pos                  4                               /*!< SC_T::IER: TMR1_IE Position */
N#define SC_IER_TMR1_IE_Msk                  (1ul << SC_IER_TMR1_IE_Pos)     /*!< SC_T::IER: TMR1_IE Mask */
N
N#define SC_IER_TMR0_IE_Pos                  3                               /*!< SC_T::IER: TMR0_IE Position */
N#define SC_IER_TMR0_IE_Msk                  (1ul << SC_IER_TMR0_IE_Pos)     /*!< SC_T::IER: TMR0_IE Mask */
N
N#define SC_IER_TERR_IE_Pos                  2                               /*!< SC_T::IER: TERR_IE Position */
N#define SC_IER_TERR_IE_Msk                  (1ul << SC_IER_TERR_IE_Pos)     /*!< SC_T::IER: TERR_IE Mask */
N
N#define SC_IER_TBE_IE_Pos                   1                               /*!< SC_T::IER: TBE_IE Position */
N#define SC_IER_TBE_IE_Msk                   (1ul << SC_IER_TBE_IE_Pos)      /*!< SC_T::IER: TBE_IE Mask */
N
N#define SC_IER_RDA_IE_Pos                   0                               /*!< SC_T::IER: RDA_IE Position */
N#define SC_IER_RDA_IE_Msk                   (1ul << SC_IER_RDA_IE_Pos)      /*!< SC_T::IER: RDA_IE Mask */
N
N/* SC ISR Bit Field Definitions */
N#define SC_ISR_ACON_ERR_IS_Pos              10                              /*!< SC_T::ISR: ACON_ERR_IS Position */
N#define SC_ISR_ACON_ERR_IS_Msk              (1ul << SC_ISR_ACON_ERR_IS_Pos) /*!< SC_T::ISR: ACON_ERR_IS Mask */
N
N#define SC_ISR_RTMR_IS_Pos                  9                               /*!< SC_T::ISR: RTMR_IS Position */
N#define SC_ISR_RTMR_IS_Msk                  (1ul << SC_ISR_RTMR_IS_Pos)     /*!< SC_T::ISR: RTMR_IS Mask */
N
N#define SC_ISR_INIT_IS_Pos                  8                               /*!< SC_T::ISR: INIT_IS Position */
N#define SC_ISR_INIT_IS_Msk                  (1ul << SC_ISR_INIT_IS_Pos)     /*!< SC_T::ISR: INIT_IS Mask */
N
N#define SC_ISR_CD_IS_Pos                    7                               /*!< SC_T::ISR: CD_IS Position */
N#define SC_ISR_CD_IS_Msk                    (1ul << SC_ISR_CD_IS_Pos)       /*!< SC_T::ISR: CD_IS Mask */
N
N#define SC_ISR_BGT_IS_Pos                   6                               /*!< SC_T::ISR: BGT_IS Position */
N#define SC_ISR_BGT_IS_Msk                   (1ul << SC_ISR_BGT_IS_Pos)      /*!< SC_T::ISR: BGT_IS Mask */
N
N#define SC_ISR_TMR2_IS_Pos                  5                               /*!< SC_T::ISR: TMR2_IS Position */
N#define SC_ISR_TMR2_IS_Msk                  (1ul << SC_ISR_TMR2_IS_Pos)     /*!< SC_T::ISR: TMR2_IS Mask */
N
N#define SC_ISR_TMR1_IS_Pos                  4                               /*!< SC_T::ISR: TMR1_IS Position */
N#define SC_ISR_TMR1_IS_Msk                  (1ul << SC_ISR_TMR1_IS_Pos)     /*!< SC_T::ISR: TMR1_IS Mask */
N
N#define SC_ISR_TMR0_IS_Pos                  3                               /*!< SC_T::ISR: TMR0_IS Position */
N#define SC_ISR_TMR0_IS_Msk                  (1ul << SC_ISR_TMR0_IS_Pos)     /*!< SC_T::ISR: TMR0_IS Mask */
N
N#define SC_ISR_TERR_IS_Pos                  2                               /*!< SC_T::ISR: TERR_IS Position */
N#define SC_ISR_TERR_IS_Msk                  (1ul << SC_ISR_TERR_IS_Pos)     /*!< SC_T::ISR: TERR_IS Mask */
N
N#define SC_ISR_TBE_IS_Pos                   1                               /*!< SC_T::ISR: TXBE_IS Position */
N#define SC_ISR_TBE_IS_Msk                   (1ul << SC_ISR_TBE_IS_Pos)      /*!< SC_T::ISR: TXBE_IS Mask */
N
N#define SC_ISR_RDA_IS_Pos                   0                               /*!< SC_T::ISR: RDA_IS Position */
N#define SC_ISR_RDA_IS_Msk                   (1ul << SC_ISR_RDA_IS_Pos)      /*!< SC_T::ISR: RDA_IS Mask */
N
N
N/* SC TRSR Bit Field Definitions */
N#define SC_TRSR_TX_ATV_Pos                  31                              /*!< SC_T::TRSR: TX_ATV Position */
N#define SC_TRSR_TX_ATV_Msk                  (1ul << SC_TRSR_TX_ATV_Pos)     /*!< SC_T::TRSR: TX_ATV Mask */
N
N#define SC_TRSR_TX_OVER_REERR_Pos           30                                  /*!< SC_T::TRSR: TX_OVER_REERR Position */
N#define SC_TRSR_TX_OVER_REERR_Msk           (1ul << SC_TRSR_TX_OVER_REERR_Pos)  /*!< SC_T::TRSR: TX_OVER_REERR Mask */
N
N#define SC_TRSR_TX_REERR_Pos                29                               /*!< SC_T::TRSR: TX_REERR Position */
N#define SC_TRSR_TX_REERR_Msk                (1ul << SC_TRSR_TX_REERR_Pos)    /*!< SC_T::TRSR: TX_REERR Mask */
N
N#define SC_TRSR_TX_POINT_F_Pos              24                               /*!< SC_T::TRSR: TX_POINT_F Position */
N#define SC_TRSR_TX_POINT_F_Msk              (7ul << SC_TRSR_TX_POINT_F_Pos)  /*!< SC_T::TRSR: TX_POINT_F Mask */
N
N#define SC_TRSR_RX_ATV_Pos                  23                               /*!< SC_T::TRSR: RX_ATV Position */
N#define SC_TRSR_RX_ATV_Msk                  (1ul << SC_TRSR_RX_ATV_Pos)      /*!< SC_T::TRSR: RX_ATV Mask */
N
N#define SC_TRSR_RX_OVER_REERR_Pos           22                                  /*!< SC_T::TRSR: RX_OVER_REERR Position */
N#define SC_TRSR_RX_OVER_REERR_Msk           (1ul << SC_TRSR_RX_OVER_REERR_Pos)  /*!< SC_T::TRSR: RX_OVER_REERR Mask */
N
N#define SC_TRSR_RX_REERR_Pos                21                                  /*!< SC_T::TRSR: RX_REERR Position */
N#define SC_TRSR_RX_REERR_Msk                (1ul << SC_TRSR_RX_REERR_Pos)       /*!< SC_T::TRSR: RX_REERR Mask */
N
N#define SC_TRSR_RX_POINT_F_Pos              16                                  /*!< SC_T::TRSR: RX_POINT_F Position */
N#define SC_TRSR_RX_POINT_F_Msk              (7ul << SC_TRSR_RX_POINT_F_Pos)     /*!< SC_T::TRSR: RX_POINT_F Mask */
N
N#define SC_TRSR_TX_FULL_F_Pos               10                                  /*!< SC_T::TRSR: TX_FULL_F Position */
N#define SC_TRSR_TX_FULL_F_Msk               (1ul << SC_TRSR_TX_FULL_F_Pos)      /*!< SC_T::TRSR: TX_FULL_F Mask */
N
N#define SC_TRSR_TX_EMPTY_F_Pos              9                                   /*!< SC_T::TRSR: TX_EMPTY_F Position */
N#define SC_TRSR_TX_EMPTY_F_Msk              (1ul << SC_TRSR_TX_EMPTY_F_Pos)     /*!< SC_T::TRSR: TX_EMPTY_F Mask */
N
N#define SC_TRSR_TX_OVER_F_Pos               8                                   /*!< SC_T::TRSR: TX_OVER_F Position */
N#define SC_TRSR_TX_OVER_F_Msk               (1ul << SC_TRSR_TX_OVER_F_Pos)      /*!< SC_T::TRSR: TX_OVER_F Mask */
N
N#define SC_TRSR_RX_EBR_F_Pos                6                                   /*!< SC_T::TRSR: RX_EBR_F Position */
N#define SC_TRSR_RX_EBR_F_Msk                (1ul << SC_TRSR_RX_EBR_F_Pos)       /*!< SC_T::TRSR: RX_EBR_F Mask */
N
N#define SC_TRSR_RX_EFR_F_Pos                5                                   /*!< SC_T::TRSR: RX_EFR_F Position */
N#define SC_TRSR_RX_EFR_F_Msk                (1ul << SC_TRSR_RX_EFR_F_Pos)       /*!< SC_T::TRSR: RX_EFR_F Mask */
N
N#define SC_TRSR_RX_EPA_F_Pos                4                                   /*!< SC_T::TRSR: RX_EPA_F Position */
N#define SC_TRSR_RX_EPA_F_Msk                (1ul << SC_TRSR_RX_EPA_F_Pos)       /*!< SC_T::TRSR: RX_EPA_F Mask */
N
N#define SC_TRSR_RX_FULL_F_Pos               2                                   /*!< SC_T::TRSR: RX_FULL_F Position */
N#define SC_TRSR_RX_FULL_F_Msk               (1ul << SC_TRSR_RX_FULL_F_Pos)      /*!< SC_T::TRSR: RX_FULL_F Mask */
N
N#define SC_TRSR_RX_EMPTY_F_Pos              1                                   /*!< SC_T::TRSR: RX_EMPTY_F Position */
N#define SC_TRSR_RX_EMPTY_F_Msk              (1ul << SC_TRSR_RX_EMPTY_F_Pos)     /*!< SC_T::TRSR: RX_EMPTY_F Mask */
N
N#define SC_TRSR_RX_OVER_F_Pos               0                                   /*!< SC_T::TRSR: RX_OVER_F Position */
N#define SC_TRSR_RX_OVER_F_Msk               (1ul << SC_TRSR_RX_OVER_F_Pos)      /*!< SC_T::TRSR: RX_OVER_F Mask */
N
N/* SC PINCSR Bit Field Definitions */
N#define SC_PINCSR_SYNC_Pos                  30                                  /*!< SC_T::PINCSR: SYNC Position */
N#define SC_PINCSR_SYNC_Msk                  (1ul << SC_PINCSR_SYNC_Pos)         /*!< SC_T::PINCSR: SYNC Mask */
N
N#define SC_PINCSR_SC_DATA_I_ST_Pos          16                                  /*!< SC_T::PINCSR: SC_DATA_I_ST Position */
N#define SC_PINCSR_SC_DATA_I_ST_Msk          (1ul << SC_PINCSR_SC_DATA_I_ST_Pos) /*!< SC_T::PINCSR: SC_DATA_I_ST Mask */
N
N#define SC_PINCSR_POW_INV_Pos               11                                  /*!< SC_T::PINCSR: POW_INV Position */
N#define SC_PINCSR_POW_INV_Msk               (1ul << SC_PINCSR_POW_INV_Pos)      /*!< SC_T::PINCSR: POW_INV Mask */
N
N#define SC_PINCSR_CD_LEV_Pos                10                                  /*!< SC_T::PINCSR: CD_LEV Position */
N#define SC_PINCSR_CD_LEV_Msk                (1ul << SC_PINCSR_CD_LEV_Pos)       /*!< SC_T::PINCSR: CD_LEV Mask */
N
N#define SC_PINCSR_SC_DATA_O_Pos             9                                   /*!< SC_T::PINCSR: SC_DATA_O Position */
N#define SC_PINCSR_SC_DATA_O_Msk             (1ul << SC_PINCSR_SC_DATA_O_Pos)    /*!< SC_T::PINCSR: SC_DATA_O Mask */
N
N#define SC_PINCSR_SC_OEN_ST_Pos             8                                   /*!< SC_T::PINCSR: SC_OEN_ST Position */
N#define SC_PINCSR_SC_OEN_ST_Msk             (1ul << SC_PINCSR_SC_OEN_ST_Pos)    /*!< SC_T::PINCSR: SC_OEN_ST Mask */
N
N#define SC_PINCSR_ADAC_CD_EN_Pos            7                                   /*!< SC_T::PINCSR: ADAC_CD_EN Position */
N#define SC_PINCSR_ADAC_CD_EN_Msk            (1ul << SC_PINCSR_ADAC_CD_EN_Pos)   /*!< SC_T::PINCSR: ADAC_CD_EN Mask */
N
N#define SC_PINCSR_CLK_KEEP_Pos              6                                   /*!< SC_T::PINCSR: CLK_KEEP Position */
N#define SC_PINCSR_CLK_KEEP_Msk              (1ul << SC_PINCSR_CLK_KEEP_Pos)     /*!< SC_T::PINCSR: CLK_KEEP Mask */
N
N#define SC_PINCSR_CD_PIN_ST_Pos             4                                   /*!< SC_T::PINCSR: CD_PIN_ST Position */
N#define SC_PINCSR_CD_PIN_ST_Msk             (1ul << SC_PINCSR_CD_PIN_ST_Pos)    /*!< SC_T::PINCSR: CD_PIN_ST Mask */
N
N#define SC_PINCSR_CD_INS_F_Pos              3                                   /*!< SC_T::PINCSR: CD_INS_F Position */
N#define SC_PINCSR_CD_INS_F_Msk              (1ul << SC_PINCSR_CD_INS_F_Pos)     /*!< SC_T::PINCSR: CD_INS_F Mask */
N
N#define SC_PINCSR_CD_REM_F_Pos              2                                   /*!< SC_T::PINCSR: CD_REM_F Position */
N#define SC_PINCSR_CD_REM_F_Msk              (1ul << SC_PINCSR_CD_REM_F_Pos)     /*!< SC_T::PINCSR: CD_REM_F Mask */
N
N#define SC_PINCSR_SC_RST_Pos                1                                   /*!< SC_T::PINCSR: SC_RST Position */
N#define SC_PINCSR_SC_RST_Msk                (1ul << SC_PINCSR_SC_RST_Pos)       /*!< SC_T::PINCSR: SC_RST Mask */
N
N#define SC_PINCSR_POW_EN_Pos                0                                   /*!< SC_T::PINCSR: POW_EN Position */
N#define SC_PINCSR_POW_EN_Msk                (1ul << SC_PINCSR_POW_EN_Pos)       /*!< SC_T::PINCSR: POW_EN Mask */
N
N/* SC TMR0 Bit Field Definitions */
N#define SC_TMR0_MODE_Pos                    24                              /*!< SC_T::TMR0: MODE Position */
N#define SC_TMR0_MODE_Msk                    (0xFul << SC_TMR0_MODE_Pos)     /*!< SC_T::TMR0: MODE Mask */
N
N#define SC_TMR0_CNT_Pos                     0                               /*!< SC_T::TMR0: CNT Position */
N#define SC_TMR0_CNT_Msk                     (0xFFFFFFul << SC_TMR0_CNT_Pos) /*!< SC_T::TMR0: CNT Mask */
N
N/* SC TMR1 Bit Field Definitions */
N#define SC_TMR1_MODE_Pos                    24                              /*!< SC_T::TMR1: MODE Position */
N#define SC_TMR1_MODE_Msk                    (0xFul << SC_TMR1_MODE_Pos)     /*!< SC_T::TMR1: MODE Mask */
N
N#define SC_TMR1_CNT_Pos                     0                               /*!< SC_T::TMR1: CNT Position */
N#define SC_TMR1_CNT_Msk                     (0xFFul << SC_TMR1_CNT_Pos)     /*!< SC_T::TMR1: CNT Mask */
N
N/* SC TMR2 Bit Field Definitions */
N#define SC_TMR2_MODE_Pos                    24                              /*!< SC_T::TMR2: MODE Position */
N#define SC_TMR2_MODE_Msk                    (0xFul << SC_TMR2_MODE_Pos)     /*!< SC_T::TMR2: MODE Mask */
N
N#define SC_TMR2_CNT_Pos                     0                               /*!< SC_T::TMR2: CNT Position */
N#define SC_TMR2_CNT_Msk                     (0xFFul << SC_TMR2_CNT_Pos)     /*!< SC_T::TMR2: CNT Mask */
N
N/* SC TDRA Bit Field Definitions */
N#define SC_TDRA_TDR0_Pos                    0                                   /*!< SC_T::TDRA: TDR0 Position */
N#define SC_TDRA_TDR0_Msk                    (0xFFFFFFul << SC_TDRA_TDR0_Pos)    /*!< SC_T::TDRA: TDR0 Mask */
N
N/* SC TDRB Bit Field Definitions */
N#define SC_TDRB_TDR2_Pos                    8                               /*!< SC_T::TDRB: TDR2 Position */
N#define SC_TDRB_TDR2_Msk                    (0xFFul << SC_TDRB_TDR2_Pos)    /*!< SC_T::TDRB: TDR2 Mask */
N
N#define SC_TDRB_TDR1_Pos                    0                               /*!< SC_T::TDRB: TDR1 Position */
N#define SC_TDRB_TDR1_Msk                    (0xFFul << SC_TDRB_TDR1_Pos)    /*!< SC_T::TDRB: TDR1 Mask */
N/*@}*/ /* end of group SC_CONST */
N/*@}*/ /* end of group SC */
N
N
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller (SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var SPI_T::CNTRL
N * Offset: 0x00  Control and Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
N * |        |          |0 = Data transfer stopped.
N * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
N * |        |          |    writing 1 to this bit indicates that the slave is ready to communicate with a master.
N * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
N * |        |          |As the transfer is finished, this bit will be cleared automatically.
N * |        |          |Software can read this bit to check if the SPI is in busy status.
N * |        |          |In FIFO mode, this bit will be controlled by hardware.
N * |        |          |Software should not modify this bit.
N * |        |          |In Slave mode, this bit always returns 1 when this register is read by software.
N * |        |          |In Master mode, this bit reflects the busy or idle status of SPI.
N * |        |          |Note:
N * |        |          |1. When FIFO mode is disabled, all configurations should be set before writing 1 to this
N * |        |          |GO_BUSY bit.
N * |        |          |2. When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data,
N * |        |          |this bit
N * |        |          |   will be cleared after the PDMA finishes the data transfer.
N * |[1]     |RX_NEG    |Receive On Negative Edge
N * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
N * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
N * |[2]     |TX_NEG    |Transmit On Negative Edge
N * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
N * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
N * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
N * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N * |        |          |TX_BIT_LEN = 0x08 ... 8 bits.
N * |        |          |TX_BIT_LEN = 0x09 ... 9 bits.
N * |        |          |......
N * |        |          |TX_BIT_LEN = 0x1F ... 31 bits.
N * |        |          |TX_BIT_LEN = 0x00 ... 32 bits.
N * |[10]    |LSB       |Send LSB First
N * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is
N * |        |          |transmitted/received first.
N * |        |          |1 = The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and
N * |        |          |the first bit received from
N * |        |          | the SPI data input pin will be put in the LSB position of the RX register (bit 0 of
N * |        |          |SPI_RX0/1).
N * |[11]    |CLKP      |Clock Polarity
N * |        |          |0 = SPI bus clock is idle low.
N * |        |          |1 = SPI bus clock is idle high.
N * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
N * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive
N * |        |          |transaction in a transfer.
N * |        |          |The definition of the suspend interval is the interval between the last clock edge of the
N * |        |          |preceding transaction word
N * |        |          |and the first clock edge of the following transaction word.
N * |        |          |The default value is 0x3.
N * |        |          |The period of the suspend interval is obtained according to the following equation.
N * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
N * |        |          |Example:
N * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle.
N * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle.
N * |        |          |......
N * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle.
N * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle.
N * |        |          |If the variable clock function is enabled and the transmit FIFO buffer is not empty, the
N * |        |          |minimum period of suspend
N * |        |          |interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.
N * |[16]    |IF        |Unit Transfer Interrupt Flag
N * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N * |        |          |1 = SPI controller has finished one unit transfer.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[17]    |IE        |Unit Transfer Interrupt Enable
N * |        |          |0 = SPI unit transfer interrupt Disabled.
N * |        |          |1 = SPI unit transfer interrupt Enabled.
N * |[18]    |SLAVE     |Slave Mode Enable
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[19]    |REORDER   |Byte Reorder Function Enable
N * |        |          |0 = Byte Reorder function Disabled.
N * |        |          |1 = Byte Reorder function Enabled.
N * |        |          |A byte suspend interval will be inserted among each byte.
N * |        |          |The period of the byte suspend interval depends on the setting of SP_CYCLE.
N * |        |          |Note:
N * |        |          |1. Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N * |        |          |2. In Slave mode with level-trigger configuration, the slave select pin must be kept at
N * |        |          |active state during the
N * |        |          |   byte suspend interval.
N * |        |          |3. The Byte Reorder function is not supported when the variable bus clock function or Dual
N * |        |          |I/O mode is enabled.
N * |[21]    |FIFO      |FIFO Mode Enable
N * |        |          |0 = FIFO mode Disabled.
N * |        |          |1 = FIFO mode Enabled.
N * |        |          |Note:
N * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
N * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1
N * |        |          |automatically after writing data
N * |        |          | to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the
N * |        |          |SPI controller is in idle.
N * |        |          | If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1
N * |        |          |and the GO_BUSY bit will be cleared to 0.
N * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods
N * |        |          |before setting this bit to 1 again.
N * |[22]    |TWOB      |2-Bit Transfer Mode Enable
N * |        |          |0 = 2-bit Transfer mode Disabled.
N * |        |          |1 = 2-bit Transfer mode Enabled.
N * |        |          |Note: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from
N * |        |          |SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.
N * |[23]    |VARCLK_EN |Variable Clock Enable (Master Only)
N * |        |          |0 = SPI clock output frequency is fixed and decided only by the value of DIVIDER.
N * |        |          |1 = SPI clock output frequency is variable.
N * |        |          |The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
N * |        |          |Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as
N * |        |          |0x10 (16-bit mode).
N * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[25].
N * |        |          |0 = Receive FIFO buffer is not full.
N * |        |          |1 = Receive FIFO buffer is full.
N * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[26].
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[27].
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * @var SPI_T::DIVIDER
N * Offset: 0x04  Clock Divider Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DIVIDER   |Clock Divider 1 Register
N * |        |          |The value in this field is the frequency divider for generating the SPI peripheral clock and
N * |        |          |the SPI bus clock of SPI master.
N * |        |          |The frequency is obtained according to the following equation.
N * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
N * |        |          |   SPI peripheral clock frequency = system clock frequency / (DIVIDER + 1) / 2
N * |        |          |else if BCn is set to 1,
N * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1)
N * |        |          |The SPI peripheral clock source is defined in the CLKSEL1 register.
N * |[23:16] |DIVIDER2  |Clock Divider 2 Register (Master Only)
N * |        |          |The value in this field is the 2nd frequency divider for generating the second clock of the
N * |        |          |variable clock function.
N * |        |          |The frequency is obtained according to the following equation:
N * |        |          |   f_clk2 = SPI peripheral clock frequency / (DIVIDER2 + 1) / 2
N * |        |          |If the VARCLK_EN bit is cleared to 0, this setting is unmeaning.
N * @var SPI_T::SSR
N * Offset: 0x08  Slave Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |SSR       |Slave Select Control Bits (Master Only)
N * |        |          |If AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1
N * |        |          |line to an active state and writing 0 sets the line back to inactive state.
N * |        |          |If the AUTOSS bit is set, writing 0 to any bit location of this field will keep the
N * |        |          |corresponding
N * |        |          |SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will
N * |        |          |select
N * |        |          |appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration
N * |        |          |of the
N * |        |          |transmit/receive, and will be driven to inactive state for the rest of the time.
N * |        |          |The active state of SPIn_SPISS0/1 is specified in SS_LVL.
N * |        |          |Note: SPIn_SPISS0 is defined as the slave select input in Slave mode.
N * |[2]     |SS_LVL    |Slave Select Active Level
N * |        |          |This bit defines the active status of slave select signal (SPIn_SPISS0/1).
N * |        |          |0 = The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge.
N * |        |          |1 = The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge.
N * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
N * |        |          |0 = If this bit is cleared, slave select signals will be asserted/de-asserted by setting
N * |        |          |/clearing
N * |        |          |    the corresponding bits of SPI_SSR[1:0].
N * |        |          |1 = If this bit is set, SPIn_SPISS0/1 signals will be generated automatically.
N * |        |          | It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by
N * |        |          |the
N * |        |          | SPI controller when transmit/receive is started, and will be de-asserted after each
N * |        |          |transmit/receive is finished.
N * |[4]     |SS_LTRIG  |Slave Select Level Trigger Enable (Slave Only)
N * |        |          |0 = Slave select signal is edge-trigger.
N * |        |          |    This is the default value.
N * |        |          |    The SS_LVL bit decides the signal is active after a falling-edge or rising-edge.
N * |        |          |1 = Slave select signal is level-trigger.
N * |        |          |    The SS_LVL bit decides the signal is active low or active high.
N * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
N * |        |          |In Slave mode, this bit indicates whether the received bit number meets the requirement or
N * |        |          |not after the current transaction done.
N * |        |          |0 = Transferred bit length of one transaction does not meet the specified requirement.
N * |        |          |1 = Transferred bit length meets the specified requirement which defined in TX_BIT_LEN.
N * |        |          |Note: This bit is READ only.
N * |        |          |As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI
N * |        |          |peripheral clock periods plus 1 system clock period.
N * |        |          |In FIFO mode, this bit has no meaning.
N * @var SPI_T::RX
N * Offset: 0x10~0x14  Data Receive Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RX        |Data Receive Register
N * |        |          |The data receive register holds the datum received from SPI data input pin.
N * |        |          |If FIFO mode is disabled, the last received data can be accessed through software by reading
N * |        |          |this register.
N * |        |          |If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not
N * |        |          |set to 1, the receive
N * |        |          |FIFO buffer can be accessed through software by reading this register. This is a read-only
N * |        |          |register.
N * @var SPI_T::TX
N * Offset: 0x20~0x24  Data Transmit Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TX        |Data Transmit Register
N * |        |          |The data transmit registers hold the data to be transmitted in the next transfer.
N * |        |          |The number of valid bits depends on the setting of transmit bit length field of the
N * |        |          |SPI_CNTRL register.
N * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next
N * |        |          |transfer.
N * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
N * |        |          |Note 1: When the SPI controller is configured as a slave device and FIFO mode is disabled,
N * |        |          |if the SPI
N * |        |          | controller attempts to transmit data to a master, the transmit data register should be
N * |        |          |updated
N * |        |          |        by software before setting the GO_BUSY bit to 1.
N * |        |          |Note 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock
N * |        |          |cycles after user writes to this register.
N * @var SPI_T::VARCLK
N * Offset: 0x34  Variable Clock Pattern Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |VARCLK    |Variable Clock Pattern
N * |        |          |This register defines the clock pattern of the SPI transfer.
N * |        |          |If the variable clock function is disabled, this setting is unmeaning.
N * @var SPI_T::DMA
N * Offset: 0x38  SPI DMA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_DMA_GO |Transmit DMA Start
N * |        |          |Setting this bit to 1 will start the transmit PDMA process.
N * |        |          |SPI controller will issue request to PDMA controller automatically.
N * |        |          |Hardware will clear this bit to 0 automatically after PDMA transfer done.
N * |        |          |If the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be
N * |        |          |set to 1 by software.
N * |        |          |The PDMA control logic of SPI controller will set it automatically whenever necessary.
N * |        |          |In Slave mode and when FIFO mode is disabled, the minimal suspend interval between two
N * |        |          |successive transactions
N * |        |          |must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or
N * |        |          |(9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode.
N * |        |          |If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above
N * |        |          |conditions is required.
N * |[1]     |RX_DMA_GO |Receive DMA Start
N * |        |          |Setting this bit to 1 will start the receive PDMA process.
N * |        |          |The SPI controller will issue request to PDMA controller automatically when the SPI receive
N * |        |          |buffer is not empty.
N * |        |          |This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.
N * |        |          |If the software uses the receive PDMA function to access the received data of SPI and does
N * |        |          |not use the transmit
N * |        |          |PDMA function, the GO_BUSY bit should be set by software.
N * |        |          |Enabling FIFO mode is recommended if the software uses more than one PDMA channel to
N * |        |          |transfer data.
N * |        |          |In Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for
N * |        |          |SPI receive PDMA
N * |        |          |function and the other PDMA channels are not in use, the minimal suspend interval between
N * |        |          |two successive
N * |        |          |transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock
N * |        |          |periods) for Edge-trigger
N * |        |          |mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger
N * |        |          |mode.
N * |[2]     |PDMA_RST  |PDMA Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0
N * |        |          |automatically.
N * @var SPI_T::CNTRL2
N * Offset: 0x3C  Control and Status Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable
N * |        |          |This is used to ignore the slave select signal in Slave mode.
N * |        |          |The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and
N * |        |          |SPIn_MOSI.
N * |        |          |0 = 4-wire bi-direction interface.
N * |        |          |1 = 3-wire bi-direction interface.
N * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.
N * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
N * |        |          |In normal operation, there is an interrupt event when the received data meet the required
N * |        |          |bits which defined in TX_BIT_LEN.
N * |        |          |If the received bits are less than the requirement and there is no more SPI clock input over
N * |        |          |the one transfer time in
N * |        |          |Slave 3-wire mode, the user can set this bit to force the current transfer done and then the
N * |        |          |user can get a transfer done interrupt event.
N * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by
N * |        |          |software.
N * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
N * |        |          |Used to enable interrupt when the transfer has started in Slave 3-wire mode.
N * |        |          |If there is no transfer done interrupt over the time period which is defined by user after
N * |        |          |the transfer start,
N * |        |          |the user can set the SLV_ABORT bit to force the transfer done.
N * |        |          |0 = Transaction start interrupt Disabled.
N * |        |          |1 = Transaction start interrupt Enabled.
N * |        |          |It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is
N * |        |          |cleared.
N * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
N * |        |          |This bit indicates if a transaction has started in Slave 3-wire mode.
N * |        |          |It is a mutual mirror bit of SPI_STATUS[11].
N * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
N * |        |          |1 = A transaction has started in Slave 3-wire mode.
N * |        |          |It will be cleared automatically when a transaction is done or by writing 1 to this bit.
N * |[12]    |DUAL_IO_DIR|Dual I/O Mode Direction Control
N * |        |          |0 = Dual Input mode.
N * |        |          |1 = Dual Output mode.
N * |[13]    |DUAL_IO_EN|Dual I/O Mode Enable
N * |        |          |0 = Dual I/O mode Disabled.
N * |        |          |1 = Dual I/O mode Enabled.
N * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option
N * |        |          |This setting is only available if the SPI controller is configured as level trigger slave
N * |        |          |device.
N * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
N * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
N * |[31]    |BCn       |SPI Peripheral Clock Backward Compatible Option
N * |        |          |0 = Backward compatible clock configuration.
N * |        |          |1 = Clock configuration is not backward compatible.
N * |        |          |Refer to the description of SPI_DIVIDER register for details.
N * @var SPI_T::FIFO_CTL
N * Offset: 0x40  SPI FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
N * |        |          |0 = No effect.
N * |        |          |1 = Clear receive FIFO buffer.
N * |        |          |The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
N * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
N * |        |          |0 = No effect.
N * |        |          |1 = Clear transmit FIFO buffer.
N * |        |          |The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
N * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
N * |        |          |0 = RX threshold interrupt Disabled.
N * |        |          |1 = RX threshold interrupt Enabled.
N * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
N * |        |          |0 = TX threshold interrupt Disabled.
N * |        |          |1 = TX threshold interrupt Enabled.
N * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable
N * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-Out Interrupt Enable
N * |        |          |0 = Time-out interrupt Disabled.
N * |        |          |1 = Time-out interrupt Enabled.
N * |[26:24] |RX_THRESHOLD|Receive FIFO Threshold
N * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
N * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
N * |[30:28] |TX_THRESHOLD|Transmit FIFO Threshold
N * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the
N * |        |          |TX_THRESHOLD
N * |        |          |setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
N * @var SPI_T::STATUS
N * Offset: 0x44  SPI Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (Read Only)
N * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting
N * |        |          |value of RX_THRESHOLD.
N * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of
N * |        |          |RX_THRESHOLD.
N * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt
N * |        |          |request.
N * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
N * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will
N * |        |          |be set to 1.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (Read Only)
N * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of
N * |        |          |TX_THRESHOLD.
N * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the
N * |        |          |setting value of TX_THRESHOLD.
N * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt
N * |        |          |request.
N * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
N * |        |          |It is used to dedicate if a transaction has started in Slave 3-wire mode.
N * |        |          |It is a mutual mirror bit of SPI_CNTRL2[11].
N * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
N * |        |          |1 = A transaction has started in Slave 3-wire mode.
N * |        |          |It will be cleared as a transaction is done or by writing 1 to this bit.
N * |[15:12] |RX_FIFO_COUNT|Receive FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[16].
N * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N * |        |          |1 = SPI controller has finished one unit transfer.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[20]    |TIMEOUT   |Time-Out Interrupt Flag
N * |        |          |0 = No receive FIFO time-out event.
N * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64
N * |        |          |SPI clock
N * |        |          |period in Master mode or over 576 SPI peripheral clock period in Slave mode.
N * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared
N * |        |          |automatically.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[25]    |RX_FULL   |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[26].
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[27].
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * |[31:28] |TX_FIFO_COUNT|Transmit FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N */
N
N    __IO uint32_t CNTRL;         /* Offset: 0x00  Control and Status Register                                        */
X    volatile uint32_t CNTRL;          
N    __IO uint32_t DIVIDER;       /* Offset: 0x04  Clock Divider Register                                             */
X    volatile uint32_t DIVIDER;        
N    __IO uint32_t SSR;           /* Offset: 0x08  Slave Select Register                                              */
X    volatile uint32_t SSR;            
N    __I  uint32_t RESERVE0;     
X    volatile const  uint32_t RESERVE0;     
N    __I  uint32_t RX[2];         /* Offset: 0x10  Data Receive Register                                              */
X    volatile const  uint32_t RX[2];          
N    __I  uint32_t RESERVE1;     
X    volatile const  uint32_t RESERVE1;     
N    __I  uint32_t RESERVE2;     
X    volatile const  uint32_t RESERVE2;     
N    __O  uint32_t TX[2];         /* Offset: 0x20  Data Transmit Register                                             */
X    volatile  uint32_t TX[2];          
N    __I  uint32_t RESERVE3;     
X    volatile const  uint32_t RESERVE3;     
N    __I  uint32_t RESERVE4;     
X    volatile const  uint32_t RESERVE4;     
N    __I  uint32_t RESERVE5;     
X    volatile const  uint32_t RESERVE5;     
N    __IO uint32_t VARCLK;        /* Offset: 0x34  Variable Clock Pattern Register                                    */
X    volatile uint32_t VARCLK;         
N    __IO uint32_t DMA;           /* Offset: 0x38  SPI DMA Control Register                                           */
X    volatile uint32_t DMA;            
N    __IO uint32_t CNTRL2;        /* Offset: 0x3C  Control and Status Register 2                                      */
X    volatile uint32_t CNTRL2;         
N    __IO uint32_t FIFO_CTL;      /* Offset: 0x40  SPI FIFO Control Register                                          */
X    volatile uint32_t FIFO_CTL;       
N    __IO uint32_t STATUS;        /* Offset: 0x44  SPI Status Register                                                */
X    volatile uint32_t STATUS;         
N    
N} SPI_T;
N
N
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
N
N#define SPI_CNTRL_TWOB_Pos         22                                     /*!< SPI_T::CNTRL: TWOB Position */
N#define SPI_CNTRL_TWOB_Msk         (1ul << SPI_CNTRL_TWOB_Pos)            /*!< SPI_T::CNTRL: TWOB Mask     */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
N#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
N
N#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI_T::DIVIDER: DIVIDER Mask */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
N#define SPI_SSR_SSR_Msk            (3ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
N
N/* SPI_DMA Bit Field Definitions */
N#define SPI_DMA_PDMA_RST_Pos   2                                     /*!< SPI_T::DMA: PDMA_RST Position */
N#define SPI_DMA_PDMA_RST_Msk   (1ul << SPI_DMA_PDMA_RST_Pos)         /*!< SPI_T::DMA: PDMA_RST Mask */
N
N#define SPI_DMA_RX_DMA_GO_Pos   1                                    /*!< SPI_T::DMA: RX_DMA_GO Position */
N#define SPI_DMA_RX_DMA_GO_Msk   (1ul << SPI_DMA_RX_DMA_GO_Pos)       /*!< SPI_T::DMA: RX_DMA_GO Mask */
N
N#define SPI_DMA_TX_DMA_GO_Pos   0                                    /*!< SPI_T::DMA: TX_DMA_GO Position */
N#define SPI_DMA_TX_DMA_GO_Msk   (1ul << SPI_DMA_TX_DMA_GO_Pos)       /*!< SPI_T::DMA: TX_DMA_GO Mask */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI_T::CNTRL2: BCn Position */
N#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI_T::CNTRL2: BCn Mask */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
N#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
N
N#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI_T::CNTRL2: DUAL_IO_EN Position */
N#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI_T::CNTRL2: DUAL_IO_EN Mask */
N
N#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI_T::CNTRL2: DUAL_IO_DIR Position */
N#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI_T::CNTRL2: DUAL_IO_DIR Mask */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI_T::CNTRL2: SLV_ABORT Position */
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI_T::CNTRL2: NOSLVSEL Position */
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
N#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
N#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI_T::FIFO_CTL: TX_CLR Position */
N#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI_T::FIFO_CTL: RX_CLR Position */
N#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI_T::STATUS: TX_FULL Position */
N#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI_T::STATUS: TX_FULL Mask */
N
N#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI_T::STATUS: TX_EMPTY Position */
N#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI_T::STATUS: TX_EMPTY Mask */
N
N#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI_T::STATUS: RX_FULL Position */
N#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI_T::STATUS: RX_FULL Mask */
N
N#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI_T::STATUS: RX_EMPTY Position */
N#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI_T::STATUS: RX_EMPTY Mask */
N
N#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI_T::STATUS: TIMEOUT Position */
N#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI_T::STATUS: TIMEOUT Mask */
N
N#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI_T::STATUS: IF Position */
N#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI_T::STATUS: IF Mask     */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
N
N#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI_T::STATUS: TX_INTSTS Position */
N#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI_T::STATUS: TX_INTSTS Mask */
N
N#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI_T::STATUS: RX_OVERRUN Position */
N#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI_T::STATUS: RX_OVERRUN Mask */
N
N#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI_T::STATUS: RX_INTSTS Position */
N#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI_T::STATUS: RX_INTSTS Mask */
N/*@}*/ /* end of group SPI_CONST */
N/*@}*/ /* end of group SPI */
N
N
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller (SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var GCR_T::PDID
N * Offset: 0x00  Part Device Identification Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDID      |Part Device Identification Number
N * |        |          |This register reflects device part number code.
N * |        |          |Software can read this register to identify which device is used.
N * @var GCR_T::RSTSRC
N * Offset: 0x04  System Reset Source Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RSTS_POR  |Power-on Reset Flag
N * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or
N * |        |          |bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
N * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
N * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the
N * |        |          |system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[1]     |RSTS_RESET|Reset Pin Reset Flag
N * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the
N * |        |          |previous reset source.
N * |        |          |0 = No reset from /RESET pin.
N * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[2]     |RSTS_WDT  |Watchdog Reset Flag
N * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the
N * |        |          |previous reset source
N * |        |          |0 = No reset from watchdog timer.
N * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
N * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To
N * |        |          |Indicate The Previous Reset Source
N * |        |          |0 = No reset from LVR.
N * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
N * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the
N * |        |          |previous reset source.
N * |        |          |0 = No reset from BOD.
N * |        |          |1 = The BOD had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |RSTS_SYS  |System Reset Flag
N * |        |          |The RSTS_SYS flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the
N * |        |          |previous reset source.
N * |        |          |0 = No reset from Cortex-M0.
N * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit
N * |        |          |SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address =
N * |        |          |0xE000ED0C) in system control registers of Cortex-M0 kernel.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[7]     |RSTS_CPU  |CPU Reset Flag
N * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset
N * |        |          |Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
N * |        |          |0 = No reset from CPU.
N * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * @var GCR_T::IPRSTC1
N * Offset: 0x08  IP Reset Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CHIP_RST  |CHIP One-Shot Reset (Write Protect)
N * |        |          |Setting this bit will reset the whole chip, including CPU kernel and all peripherals, and
N * |        |          |this bit will automatically return to 0 after the 2 clock cycles.
N * |        |          |The CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip
N * |        |          |setting from flash are also reload.
N * |        |          |For the difference between CHIP_RST and SYSRESETREQ, please refer to section 5.2.2
N * |        |          |0 = CHIP normal operation.
N * |        |          |1 = CHIP one-shot reset.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[1]     |CPU_RST   |CPU Kernel One-Shot Reset (Write Protect)
N * |        |          |Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this
N * |        |          |bit will automatically return 0 after the two clock cycles
N * |        |          |0 = CPU normal operation.
N * |        |          |1 = CPU one-shot reset.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[2]     |PDMA_RST  |PDMA Controller Reset (Write Protect)
N * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
N * |        |          |User need to set this bit to 0 to release from reset state.
N * |        |          |0 = PDMA controller normal operation.
N * |        |          |1 = PDMA controller reset.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[3]     |EBI_RST   |EBI Controller Reset (Write Protect)
N * |        |          |Setting this bit to 1 will generate a reset signal to the EBI.
N * |        |          |User need to set this bit to 0 to release from reset state.
N * |        |          |0 = EBI controller normal operation.
N * |        |          |1 = EBI controller reset.
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * @var GCR_T::IPRSTC2
N * Offset: 0x0C  IP Reset Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |GPIO_RST  |GPIO Controller Reset
N * |        |          |0 = GPIO controller normal operation.
N * |        |          |1 = GPIO controller reset.
N * |[2]     |TMR0_RST  |Timer0 Controller Reset
N * |        |          |0 = Timer0 controller normal operation.
N * |        |          |1 = Timer0 controller reset.
N * |[3]     |TMR1_RST  |Timer1 Controller Reset
N * |        |          |0 = Timer1 controller normal operation.
N * |        |          |1 = Timer1 controller reset.
N * |[4]     |TMR2_RST  |Timer2 Controller Reset
N * |        |          |0 = Timer2 controller normal operation.
N * |        |          |1 = Timer2 controller reset.
N * |[5]     |TMR3_RST  |Timer3 Controller Reset
N * |        |          |0 = Timer3 controller normal operation.
N * |        |          |1 = Timer3 controller reset.
N * |[8]     |I2C0_RST  |I2C0 Controller Reset
N * |        |          |0 = I2C0 controller normal operation.
N * |        |          |1 = I2C0 controller reset.
N * |[9]     |I2C1_RST  |I2C1 Controller Reset
N * |        |          |0 = I2C1 controller normal operation.
N * |        |          |1 = I2C1 controller reset.
N * |[12]    |SPI0_RST  |SPI0 Controller Reset
N * |        |          |0 = SPI0 controller normal operation.
N * |        |          |1 = SPI0 controller reset.
N * |[13]    |SPI1_RST  |SPI1 Controller Reset
N * |        |          |0 = SPI1 controller normal operation.
N * |        |          |1 = SPI1 controller reset.
N * |[14]    |SPI2_RST  |SPI2 Controller Reset
N * |        |          |0 = SPI2 controller normal operation.
N * |        |          |1 = SPI2 controller reset.
N * |[15]    |SPI3_RST  |SPI3 Controller Reset
N * |        |          |0 = SPI3 controller normal operation.
N * |        |          |1 = SPI3 controller reset.
N * |[16]    |UART0_RST |UART0 Controller Reset
N * |        |          |0 = UART0 controller normal operation.
N * |        |          |1 = UART0 controller reset.
N * |[17]    |UART1_RST |UART1 Controller Reset
N * |        |          |0 = UART1 controller normal operation.
N * |        |          |1 = UART1 controller reset.
N * |[18]    |UART2_RST |UART2 Controller Reset
N * |        |          |0 = UART2 controller normal operation.
N * |        |          |1 = UART2 controller reset.
N * |[20]    |PWM03_RST |PWM03 Controller Reset
N * |        |          |0 = PWM03 controller normal operation.
N * |        |          |1 = PWM03 controller reset.
N * |[21]    |PWM47_RST |PWM47 Controller Reset
N * |        |          |0 = PWM47 controller normal operation.
N * |        |          |1 = PWM47 controller reset.
N * |[22]    |ACMP_RST  |Analog Comparator Controller Reset
N * |        |          |0 = Analog Comparator controller normal operation.
N * |        |          |1 = Analog Comparator controller reset.
N * |[23]    |PS2_RST   |PS/2 Controller Reset
N * |        |          |0 = PS/2 controller normal operation.
N * |        |          |1 = PS/2 controller reset.
N * |[27]    |USBD_RST  |USB Device Controller Reset
N * |        |          |0 = USB device controller normal operation.
N * |        |          |1 = USB device controller reset.
N * |[28]    |ADC_RST   |ADC Controller Reset
N * |        |          |0 = ADC controller normal operation.
N * |        |          |1 = ADC controller reset.
N * |[29]    |I2S_RST   |I2S Controller Reset
N * |        |          |0 = I2S controller normal operation.
N * |        |          |1 = I2S controller reset.
N * @var GCR_T::IPRSTC3
N * Offset: 0x10  IP Reset Control Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC0_RST   |SC0 Controller Reset
N * |        |          |0 = SC0 controller normal operation.
N * |        |          |1 = SC0 controller reset.
N * |[1]     |SC1_RST   |SC1 Controller Reset
N * |        |          |0 = SC1 controller normal operation.
N * |        |          |1 = SC1 controller reset.
N * |[2]     |SC2_RST   |SC2 Controller Reset
N * |        |          |0 = SC2 controller normal operation.
N * |        |          |1 = SC2 controller reset.
N * @var GCR_T::BODCR
N * Offset: 0x18  Brown-out Detector Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BOD_EN    |Brown-Out Detector Enable (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register CONFIG0 bit[23]
N * |        |          |0 = Brown-out Detector function Disabled.
N * |        |          |1 = Brown-out Detector function Enabled.
N * |        |          |Note: This bit is the protected bit.
N * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register config0 bit[22:21].
N * |        |          |00 = Brown-out voltage is 2.2V.
N * |        |          |01 = Brown-out voltage is 2.7V.
N * |        |          |10 = Brown-out voltage is 3.7V.
N * |        |          |11 = Brown-out voltage is 4.4V.
N * |        |          |Note: This bit is the protected bit.
N * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[3]     |BOD_RSTEN |Brown-Out Reset Enable (Write Protect)
N * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
N * |        |          |1 = Brown-out "RESET" function Enabled.
N * |        |          |While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is
N * |        |          |enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage
N * |        |          |is lower than the threshold (BOD_OUT high).
N * |        |          |Note1: While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled
N * |        |          |(BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high.
N * |        |          |BOD interrupt will keep till to the BOD_EN set to 0.
N * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function
N * |        |          |(set BOD_EN low).
N * |        |          |Note2: The default value is set by flash controller user configuration register config0
N * |        |          |bit[20].
N * |        |          |Note3: This bit is the protected bit.
N * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[4]     |BOD_INTF  |Brown-Out Detector Interrupt Flag
N * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through
N * |        |          |the voltage of BOD_VL setting.
N * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL
N * |        |          |setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1
N * |        |          |and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |BOD_LPM   |Brown-Out Detector Low Power Mode (Write Protection)
N * |        |          |0 = BOD operated in Normal mode (default).
N * |        |          |1 = BOD Low Power mode Enabled.
N * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the
N * |        |          |current to about 1/10 but slow the BOD response.
N * |        |          |Note2: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * |[6]     |BOD_OUT   |Brown-Out Detector Output Status
N * |        |          |0 = Brown-out Detector output status is 0.
N * |        |          |It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0.
N * |        |          |1 = Brown-out Detector output status is 1.
N * |        |          |It means the detected voltage is lower than BOD_VL setting.
N * |        |          |If the BOD_EN is 0, BOD function disabled , this bit always responds to 0.
N * |[7]     |LVR_EN    |Low Voltage Reset Enable (Write Protection)
N * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit
N * |        |          |setting.
N * |        |          |LVR function is enabled by default.
N * |        |          |0 = Low Voltage Reset function Disabled.
N * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be
N * |        |          |active with 100us delay for LVR output stable (default).
N * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and
N * |        |          |"88h" to address 0x5000_0100 to disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * @var GCR_T::TEMPCR
N * Offset: 0x1C  Temperature Sensor Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |VTEMP_EN  |Temperature Sensor Enable Control
N * |        |          |This bit is used to enable/disable temperature sensor function.
N * |        |          |0 = Temperature sensor function Disabled (default).
N * |        |          |1 = Temperature sensor function Enabled.
N * |        |          |Note: After this bit is set to 1, the value of temperature can be obtained from ADC
N * |        |          |conversion result by ADC channel selecting channel 7 and alternative multiplexer channel
N * |        |          |selecting temperature sensor.
N * |        |          |Please refer to the ADC function chapter for detail ADC conversion functional description.
N * @var GCR_T::PORCR
N * Offset: 0x24  Power-on-Reset Controller Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |POR_DIS_CODE|Power-On-Reset Enable Control (Write Protect)
N * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function,
N * |        |          |but noise on the power may cause the POR active again.
N * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by
N * |        |          |writing 0x5AA5 to this field.
N * |        |          |The POR function will be active again when this field is set to another value or chip is
N * |        |          |reset by other reset source, including:
N * |        |          |/RESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset
N * |        |          |function
N * |        |          |Note: This bit is the protected bit.
N * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N * @var GCR_T::GPA_MFP
N * Offset: 0x30  GPIOA Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPA_MFP0  |PA.0 Pin Function Selection
N * |        |          |Bit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.
N * |        |          |(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ADC0 function is selected.
N * |        |          |(1, 1) = SC0_PWR function is selected.  
N * |[1]     |GPA_MFP1  |PA.1 Pin Function Selection
N * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1] determine the PA.1 function.
N * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD12 function is selected.          
N * |[2]     |GPA_MFP2  |PA.2 Pin Function Selection
N * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2] determine the PA.2 function.
N * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_CLK function is selected.
N * |        |          |(1, 1, 0, 1) = AD11 function is selected.         
N * |[3]     |GPA_MFP3  |PA.3 Pin Function Selection   
N * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3] determine the PA.3 function.
N * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_DAT function is selected.
N * |        |          |(1, 1, 0, 1) = AD10 function is selected.
N * |[4]     |GPA_MFP4  |PA.4 Pin Function Selection     
N * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4] determine the PA.4 function.
N * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
N * |        |          |(1, 1, 0, 1) = AD9 function is selected.     
N * |[5]     |GPA_MFP5  |PA.5 Pin Function Selection    
N * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]), PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.
N * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD8 function is selected.     
N * |[6]     |GPA_MFP6  |PA.6 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.
N * |        |          |(EBI_EN, PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ADC6 function is selected.
N * |        |          |(0, 1, 1) = SC1_CLK function is selected.
N * |        |          |(1, 0, 1) = AD7 function is selected.     
N * |[7]     |GPA_MFP7  |PA.7 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7] determine the PA.7 function.
N * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
N * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
N * |        |          |(0, 1, 0, 1) = SC1_DAT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.     
N * |[8]     |GPA_MFP8  |PA.8 Pin Function Selection
N * |        |          |Bit GPA_MFP[8] determines the PA.8 function.
N * |        |          |0 = GPIO function is selected to the pin PA.8.
N * |        |          |1 = I2C0_SDA function is selected to the pin PA.8.
N * |[10]    |GPA_MFP9  |PA.9 Pin Function Selection
N * |        |          |Bit GPA_MFP[9] determines the PA.9 function.
N * |        |          |0 = GPIO function is selected to the pin PA.9.
N * |        |          |1 = I2C0_SCL function is selected to the pin PA.9.
N * |[10]    |GPA_MFP10 |PA.10 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPA_MFP[10] determine the PA.10 function.
N * |        |          |(EBI_EN, GPA_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = I2C1_SDA function is selected.
N * |        |          |(1, 1) = nWR(EBI) function is selected.     
N * |[11]    |GPA_MFP11 |PA.11 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPA_MFP[11] determine the PA.11 function.
N * |        |          |(EBI_EN, GPA_MFP11) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = I2C1_SCL function is selected.
N * |        |          |(1, 1) = nRD(EBI) function is selected.     
N * |[12]    |GPA_MFP12 |PA.12 Pin Function Selection
N * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and GPA_MFP[12] determine the PA.12 function.
N * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_DAT function is selected.
N * |        |          |(1, 1, 0, 1) = AD13 function is selected.       
N * |[13]    |GPA_MFP13 |PA.13 Pin Function Selection     
N * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and GPA_MFP[13] determine the PA.13 function.
N * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_CLK function is selected.
N * |        |          |(1, 1, 0, 1) = AD14 function is selected.        
N * |[14]    |GPA_MFP14 |PA.14 Pin Function Selection
N * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and GPA_MFP[14] determine the PA.14 function.
N * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD15 function is selected.        
N * |[15]    |GPA_MFP15 |PA.15 Pin Function Selection     
N * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15 function.
N * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = PWM3 function is selected.
N * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
N * |        |          |(1, 0, 1) = SC2_PWR function is selected.         
N * |[16:31] |GPA_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPB_MFP
N * Offset: 0x34  GPIOB Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPB_MFP0  |PB.0 Pin Function Selection     
N * |        |          |Bit GPB_MFP[0] determines the PB.0 function.
N * |        |          |0 = GPIO function is selected to the pin PB.0.
N * |        |          |1 = UART0_RXD function is selected to the pin PB.0.       
N * |[1]     |GPB_MFP1  |PB.1 Pin Function Selection
N * |        |          |Bit GPB_MFP[1] determines the PB.1 function.
N * |        |          |0 = GPIO function is selected to the pin PB.1.
N * |        |          |1 = UART0_TXD function is selected to the pin PB.1.     
N * |[2]     |GPB_MFP2  |PB.2 Pin Function Selection
N * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
N * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(1, 1, 0, 1) = nWRL(EBI) function is selected.     
N * |[3]     |GPB_MFP3  |PB.3 Pin Function Selection
N * |        |          |Bits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(1, 1, 0, 0, 1) = nWRH(EBI) function is selected.              
N * |[4]     |GPB_MFP4  |PB.4 Pin Function Selection
N * |        |          |Bit GPB_MFP[4] determines the PB.4 function.
N * |        |          |0 = GPIO function is selected to the pin PB.4.
N * |        |          |1 = UART1_RXD function is selected to the pin PB.4.     
N * |[5]     |GPB_MFP5  |PB 5 Pin Function Selection
N * |        |          |Bit GPB_MFP[5] determines the PB.5 function.
N * |        |          |0 = GPIO function is selected to the pin PB.5.
N * |        |          |1 = UART1_TXD function is selected to the pin PB.5.     
N * |[6]     |GPB_MFP6  |PB.6 Pin Function Selection 
N * |        |          |Bit EBI_EN (ALT_MFP[11]) and GPB_MFP[6] determines the PB.6 function.
N * |        |          |(EBI_EN, GPB_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = UART1_nRTS function is selected .
N * |        |          |(1, 1) = ALE(EBI) function is selected.
N * |[7]     |GPB_MFP7  |PB.7 Pin Function Selection
N * |        |          |Bit EBI_EN (ALT_MFP[11]) and GPB_MFP[7] determines the PB.7 function.
N * |        |          |(EBI_EN, GPB_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = UART1_nCTS function is selected.
N * |        |          |(1, 1) = nCS(EBI) function is selected.         
N * |[8]     |GPB_MFP8  |PB.8 Pin Function Selection
N * |        |          |Bit GPB_MFP[8] determines the PB.8 function.
N * |        |          |0 = GPIO function is selected to the pin PB.8.
N * |        |          |1 = TM0 function is selected to the pin PB.8.        
N * |[9]     |GPB_MFP9  |PB.9 Pin Function Selection
N * |        |          |Bits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.
N * |        |          |(PB9_S11, GPB_MFP9) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM1 function is selected.
N * |        |          |(1, 1) = SPI1_SS1 function is selected.         
N * |[10]    |GPB_MFP10 |PB.10 Pin Function Selection
N * |        |          |Bits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.
N * |        |          |(PB10_S01, GPB_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM2 function is selected.
N * |        |          |(1, 1) = SPI0_SS1 function is selected.     
N * |[11]    |GPB_MFP11 |PB.11 Pin Function Selection
N * |        |          |Bits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.
N * |        |          |(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM3 function is selected.     
N * |        |          |(1, 1) = PWM4 function is selected. 
N * |[12]    |GPB_MFP12 |PB.12 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PB12_CLKO (ALT_MFP[10]) and GPB_MFP[12] determine the PB.12 function.
N * |        |          |(EBI_EN, PB12_CLKO, GPB_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_O function is selected.
N * |        |          |(0, 1, 1) = CLKO (Clock Driver output) function is selected.     
N * |        |          |(1, 0, 1) = AD0 function is selected.   
N * |[13]    |GPB_MFP13 |PB.13 Pin Function Selection
N * |        |          |Bit EBI_EN (ALT_MFP[11]) and GPB_MFP[13] determines the PB.13 function.
N * |        |          |(EBI_EN, GPB_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ACMP1_O function is selected.
N * |        |          |(1, 1) = AD1 function is selected.     
N * |[14]    |GPB_MFP14 |PB.14 Pin Function Selection
N * |        |          |Bits PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14 function.
N * |        |          |(PB14_S31, GPB_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = INT0 function is selected.
N * |        |          |(1, 1) = SPI3_SS1 function is selected.
N * |[15]    |GPB_MFP15 |PB.15 Pin Function Selection
N * |        |          |Bits PB15_T0EX (ALT_MFP[24]) and GPB_MFP[15] determine the PB.15 function.
N * |        |          |(PB15_T0EX, GPB_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = INT1 function is selected.
N * |        |          |(1, 1) = TM0_EXT function is selected.  
N * |[16:31] |GPB_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOB[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOB[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPC_MFP
N * Offset: 0x38  GPIOC Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPC_MFP0  |PC.0 Pin Function Selection
N * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
N * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_SS0 function is selected.
N * |        |          |(1, 1) = I2S_LRCLK function is selected.          
N * |[1]     |GPC_MFP1  |PC.1 Pin Function Selection
N * |        |          |Bits PC1_I2SBCLK (ALT_MFP[6]) and GPC_MFP[1] determine the PC.1 function.
N * |        |          |(PC1_I2SBCLK, GPC_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_CLK function is selected.
N * |        |          |(1, 1) = I2S_BCLK function is selected.     
N * |[2]     |GPC_MFP2  |PC.2 Pin Function Selection
N * |        |          |Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
N * |        |          |(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MISO0 function is selected.
N * |        |          |(1, 1) = I2S_DI function is selected.
N * |[3]     |GPC_MFP3  |PC.3 Pin Function Selection
N * |        |          |Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
N * |        |          |(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
N * |        |          |(1, 1) = I2S_DO function is selected.     
N * |[4]     |GPC_MFP4  |PC.4 Pin Function Selection
N * |        |          |Bit GPC_MFP[9] determines the PC.4 function.
N * |        |          |0 = GPIO function is selected to the pin PC.4.
N * |        |          |1 = SPI0_MISO1 function is selected to the pin PC.4.     
N * |[5]     |GPC_MFP5  |PC.5 Pin Function Selection
N * |        |          |Bit GPC_MFP[5] determines the PC.5 function.
N * |        |          |0 = GPIO function is selected to the pin PC.5.
N * |        |          |1 = SPI0_MOSI1 function is selected to the pin PC.5.     
N * |[6]     |GPC_MFP6  |PC.6 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.
N * |        |          |(EBI_EN, PC6_SC0CD, GPC_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_P function is selected.
N * |        |          |(0, 1, 1) = SC0_CD function is selected.
N * |        |          |(1, 0, 1) = AD4 function is selected.     
N * |[7]     |GPC_MFP7  |PC.7 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.
N * |        |          |(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_N function is selected.
N * |        |          |(0, 1, 1) = SC1_CD function is selected.
N * |        |          |(1, 0, 1) = AD5 function is selected.      
N * |[8]     |GPC_MFP8  |PC.8 Pin Function Selection
N * |        |          |Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]), GPC_MFP[8] determine the PC.8 function.
N * |        |          |(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0 ,1) = SPI1_SS0 function is selected.
N * |        |          |(1, 1, 1) = MCLK(EBI) function is selected.     
N * |[9]     |GPC_MFP9  |PC.9 Pin Function Selection
N * |        |          |Bit GPC_MFP[9] determines the PC.9 function.
N * |        |          |0 = GPIO function is selected to the pin PC.9.
N * |        |          |1 = SPI1_CLK function is selected to the pin PC.9.          
N * |[10]    |GPC_MFP10 |PC.10 Pin Function Selection
N * |        |          |Bit GPC_MFP[10] determines the PC.10 function.
N * |        |          |0 = GPIO function is selected to the pin PC.10.
N * |        |          |1 = SPI1_MISO0 function is selected to the pin PC.10.    
N * |[11]    |GPC_MFP11 |PC.11 Pin Function Selection
N * |        |          |Bit GPC_MFP[11] determines the PC.11 function.
N * |        |          |0 = GPIO function is selected to the pin PC.11.
N * |        |          |1 = SPI1_MOSI0 function is selected to the pin PC.11.        
N * |[12]    |GPC_MFP12 |PC.12 Pin Function Selection
N * |        |          |Bit GPC_MFP[12] determines the PC.12 function.
N * |        |          |0 = GPIO function is selected to the pin PC.12.
N * |        |          |1 = SPI1_MISO1 function is selected to the pin PC.12.      
N * |[13]    |GPC_MFP13 |PC.13 Pin Function Selection
N * |        |          |Bit GPC_MFP[13] determines the PC.13 function.
N * |        |          |0 = GPIO function is selected to the pin PC.13.
N * |        |          |1 = SPI1_MOSI1 function is selected to the pin PC.13.     
N * |[14]    |GPC_MFP14 |PC.14 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPC_MFP[14] determine the PC.14 function.
N * |        |          |(EBI_EN, GPC_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ACMP1_P function is selected.
N * |        |          |(1, 1) = AD2 function is selected.       
N * |[15]    |GPC_MFP15 |PC.15 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPC_MFP[15] determine the PC.15 function.
N * |        |          |(EBI_EN, GPC_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ACMP1_N function is selected.
N * |        |          |(1, 1) = AD3 function is selected.        
N * |[16:31] |GPC_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOC[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOC[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPD_MFP
N * Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPD_MFP0  |PD.0 Pin Function Selection
N * |        |          |Bit GPD_MFP[0] determines the PD.0 function.
N * |        |          |0 = GPIO function is selected to the pin PD.0.
N * |        |          |1 = SPI2_SS0 function is selected to the pin PD.0.     
N * |[1]     |GPD_MFP1  |PD.1 Pin Function Selection
N * |        |          |Bit GPD_MFP[1] determines the PD.1 function.
N * |        |          |0 = GPIO function is selected to the pin PD.1.
N * |        |          |1 = SPI2_CLK function is selected to the pin PD.1.
N * |[2]     |GPD_MFP2  |PD.2 Pin Function Selection
N * |        |          |Bit GPD_MFP[2] determines the PD.2 function.
N * |        |          |0 = GPIO function is selected to the pin PD.2.
N * |        |          |1 = SPI2_MISO0 function is selected to the pin PD.2.     
N * |[3]     |GPD_MFP3  |PD.3 Pin Function Selection
N * |        |          |Bit GPD_MFP[3] determines the PD.3 function.
N * |        |          |0 = GPIO function is selected to the pin PD.3.
N * |        |          |1 = SPI2_MOSI0 function is selected to the pin PD.3.     
N * |[4]     |GPD_MFP4  |PD.4 Pin Function Selection
N * |        |          |Bit GPD_MFP[4] determines the PD.4 function.
N * |        |          |0 = GPIO function is selected to the pin PD.4.
N * |        |          |1 = SPI2_MISO1 function is selected to the pin PD.4.     
N * |[5]     |GPD_MFP5  |PD.5 Pin Function Selection
N * |        |          |Bit GPD_MFP[9] determines the PD.5 function.
N * |        |          |0 = GPIO function is selected to the pin PD.5.
N * |        |          |1 = SPI2_MOSI1 function is selected to the pin PD.5.      
N * |[8]     |GPD_MFP8  |PD.8 Pin Function Selection
N * |        |          |Bit GPD_MFP[8] determines the PD.8 function.
N * |        |          |0 = GPIO function is selected to the pin PD.8.
N * |        |          |1 = SPI3_SS0 function is selected to the pin PD.8.     
N * |[9]     |GPD_MFP9  |PD.9 Pin Function Selection
N * |        |          |Bit GPD_MFP[9] determines the PD.9 function.
N * |        |          |0 = GPIO is function is selected to the pin PD.9.
N * |        |          |1 = SPI3_CLK function is selected to the pin PD.9.     
N * |[10]    |GPD_MFP10 |PD.10 Pin Function Selection
N * |        |          |Bit GPD_MFP[10] determines the PD.10 function.
N * |        |          |0 = GPIO function is selected to the pin PD.10.
N * |        |          |1 = SPI3_MISO0 function is selected to the pin PD.10.     
N * |[11]    |GPD_MFP11 |PD.11 Pin Function Selection
N * |        |          |Bit GPD_MFP[11] determines the PD.11 function.
N * |        |          |0 = GPIO function is selected to the pin PD.11.
N * |        |          |1 = SPI3_MOSI0 function is selected to the pin PD.11.     
N * |[12]    |GPD_MFP12 |PD.12 Pin Function Selection
N * |        |          |Bit GPD_MFP[12] determines the PD.12 function.
N * |        |          |0 = GPIO function is selected to the pin PD.12.
N * |        |          |1 = SPI3_MISO1 function is selected to the pin PD.12.     
N * |[13]    |GPD_MFP13 |PD.13 Pin Function Selection
N * |        |          |Bit GPD_MFP[13] determines the PD.13 function.
N * |        |          |0 = GPIO function is selected to the pin PD.13.
N * |        |          |1 = SPI3_MOSI1 function is selected to the pin PD.13.     
N * |[14]    |GPD_MFP14 |PD.14 Pin Function Selection
N * |        |          |Bit GPD_MFP[14] determines the PD.14 function.
N * |        |          |0 = GPIO function is selected.
N * |        |          |1 = UART2_RXD function is selected.  
N * |[15]    |GPD_MFP15 |PD.15 Pin Function Selection
N * |        |          |Bit GPD_MFP[15] determines the PD.15 function.
N * |        |          |0 = GPIO function is selected.
N * |        |          |1 = UART2_TXD function is selected.  
N * |[16:31] |GPD_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPE_MFP
N * Offset: 0x40  GPIOE Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPE_MFP0  |PE.0 Pin Function Selection
N * |        |          |Bit GPE_MFP[0] determines the PE.0 function.
N * |        |          |0 = GPIO function is selected to the pin PE.0.
N * |        |          |1 = PWM6 function is selected to the pin PE.0.     
N * |[1]     |GPE_MFP1  |PE.1 Pin Function Selection
N * |        |          |Bit GPE_MFP[1] determines the PE.1 function.
N * |        |          |0 = GPIO function is selected to the pin PE.1.
N * |        |          |1 = PWM7 function is selected to the pin PE.1.     
N * |[5]     |GPE_MFP5  |PE.5 Pin Function Selection
N * |        |          |Bits PE5_T1EX (ALT_MFP[25]) and GPE_MFP5 determine the PE.5 function.
N * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = PWM5 function is selected.
N * |        |          |(1, 1) = TM1_EXT function is selected.  
N * |[16:31] |GPE_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPF_MFP
N * Offset: 0x44  GPIOF Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPF_MFP0  |PF.0 Pin Function Selection
N * |        |          |Bit GPF_MFP[0] determines the PF.0 function
N * |        |          |0 = GPIO function is selected to the pin PF.0.
N * |        |          |1 = XT1_OUT function is selected to the pin PF.0.
N * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (Config0[27]).     
N * |[1]     |GPF_MFP1  |PF.1 Pin Function Selection
N * |        |          |Bit GPF_MFP[1] determines the PF.1 function.
N * |        |          |0 = GPIO function is selected to the pin PF.1.
N * |        |          |1 = XT1_IN function is selected to the pin PF.1.
N * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (Config0[27]).     
N * |[2]     |GPF_MFP2  |PF.2 Pin Function Selection
N * |        |          |Bit GPF_MFP[2] determines the PF.2 function.
N * |        |          |0 = GPIO function is selected to the pin PF.2.
N * |        |          |1 = PS2_DAT function is selected to the pin PF.2.     
N * |[3]     |GPF_MFP3  |PF.3 Pin Function Selection
N * |        |          |Bit GPF_MFP[3] determines the PF.3 function.
N * |        |          |0 = GPIO function is selected to the pin PF.3.
N * |        |          |1 = PS2_CLK function is selected to the pin PF.3.     
N * |[16:19] |GPF_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOF[3:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOF[3:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::ALT_MFP
N * Offset: 0x50  Alternative Multiple Function Pin Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PB10_S01  |PB.10 Pin Alternative Function Selection
N * |        |          |Bits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.
N * |        |          |(PB10_S01, GPB_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM2 function is selected.
N * |        |          |(1, 1) = SPI0_SS1 function is selected.       
N * |[1]     |PB9_S11   |PB.9 Pin Alternative Function Selection
N * |        |          |Bits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.
N * |        |          |(PB9_S11, GPB_MFP9) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM1 function is selected.
N * |        |          |(1, 1) = SPI1_SS1 function is selected.           
N * |[2]     |PA7_S21   |PA.7 Pin Alternative Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7] determine the PA.7 function.
N * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
N * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
N * |        |          |(0, 1, 0, 1) = SC1_DAT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.                  
N * |[3]     |PB14_S31  |PB.14 Pin Alternative Function Selection
N * |        |          |Bits PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14 function.
N * |        |          |(PB14_S31, GPB_MFP14) value and function mapping is as following list
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = INT0 function is selected.
N * |        |          |(1, 1) = SPI3_SS1 function is selected.  
N * |[4]     |PB11_PWM4 |PB.11 Pin Alternative Function Selection     
N * |        |          |Bits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.
N * |        |          |(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM3 function is selected.     
N * |        |          |(1, 1) = PWM4 function is selected.      
N * |[5]     |PC0_I2SLRCLK|PC.0 Pin Alternative Function Selection
N * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
N * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_SS0 function is selected.
N * |        |          |(1, 1) = I2S_LRLCK function is selected.         
N * |[6]     |PC1_I2SBCLK|PC.1 Pin Alternative Function Selection
N * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
N * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_SS0 function is selected.
N * |        |          |(1, 1) = I2S_LRCK function is selected.         
N * |[7]     |PC2_I2SDI |PC.2 Pin Alternative Function Selection
N * |        |          |Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
N * |        |          |(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MISO0 function is selected.
N * |        |          |(1, 1) = I2S_DI function is selected.     
N * |[8]     |PC3_I2SDO |PC.3 Pin Alternative Function Selection
N * |        |          |Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
N * |        |          |(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
N * |        |          |(1, 1) = I2S_DO function is selected. 
N * |[9]     |PA15_I2SMCLK|PA.15 Pin Alternative Function Selection
N * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15 function.
N * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = PWM3 function is selected.
N * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
N * |        |          |(1, 0, 1) = SC2_PWR function is selected.  
N * |[10]    |PB12_CLKO |PB.12 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PB12_CLKO (ALT_MFP[10]) and GPB_MFP[12] determine the PB.12 function.
N * |        |          |(EBI_EN, PB12_CLKO, GPB_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_O function is selected.
N * |        |          |(0, 1, 1) = CLKO (Clock Driver output) function is selected.     
N * |        |          |(1, 0, 1) = AD0 function is selected.          
N * |[11]    |EBI_EN    |EBI Pin Function Selection
N * |        |          |EBI_EN is use to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), it need additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI function(AD[15:8], MCLK).
N * |[12]    |EBI_MCLK_EN|PC.8 Pin Alternative Function Selection
N * |        |          |Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]), GPC_MFP[8] determine the PC.8 function.
N * |        |          |(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0 ,1) = SPI1_SS0 function is selected.
N * |        |          |(1, 1, 1) = MCLK(EBI) function is selected.
N * |[13]    |EBI_nWRL_EN|PB.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]) PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
N * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(1, 1, 0, 1) = nWRL(EBI) function is selected. 
N * |[14]    |EBI_nWRH_EN|PB.3 Pin Alternative Function Selection
N * |        |          |Bits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(1, 1, 0, 0, 1) = nWRH(EBI) function is selected.   
N * |[16]    |EBI_HB_EN[0]|PA.5 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]), PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.
N * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD8 function is selected.    
N * |[17]    |EBI_HB_EN[1]|PA.4 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4] determine the PA.4 function.
N * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
N * |        |          |(1, 1, 0, 1) = AD9 function is selected.        
N * |[18]    |EBI_HB_EN[2]|PA.3 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3] determine the PA.3 function.
N * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_DAT function is selected.
N * |        |          |(1, 1, 0, 1) = AD10 function is selected.
N * |[19]    |EBI_HB_EN[3]|PA.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2] determine the PA.2 function.
N * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_CLK function is selected.
N * |        |          |(1, 1, 0, 1) = AD11 function is selected.   
N * |[20]    |EBI_HB_EN[4]|PA.1 Pin Alternative Function Selection
N * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1] determine the PA.1 function.
N * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD12 function is selected.   
N * |[21]    |EBI_HB_EN[5]|PA.12 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and GPA_MFP[12] determine the PA.12 function.
N * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_DAT function is selected.
N * |        |          |(1, 1, 0, 1) = AD13 function is selected.
N * |[22]    |EBI_HB_EN[6]|PA.13 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and GPA_MFP[13] determine the PA.13 function.
N * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_CLK function is selected.
N * |        |          |(1, 1, 0, 1) = AD14 function is selected. 
N * |[23]    |EBI_HB_EN[7]|PA.14 Pin Alternative Function Selection     
N * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and GPA_MFP[14] determine the PA.14 function.
N * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD15 function is selected.       
N * |[24]    |PB15_T0EX |PB.15 Pin Alternative Function Selection  
N * |        |          |Bits PB15_T0EX (ALT_MFP[24]) and GPB_MFP[15] determine the PB.15 function.
N * |        |          |(PB15_T0EX, GPB_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = INT1 function is selected.
N * |        |          |(1, 1) = TM0_EXT function is selected. 
N * |[25]    |PE5_T1EX  |PE.5 Pin Alternative Function Selection
N * |        |          |Bits PE5_T1EX (ALT_MFP[25]) and GPE_MFP5 determine the PE.5 function.
N * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = PWM5 function is selected.
N * |        |          |(1, 1) = TM1_EXT function is selected.   
N * |[26]    |PB2_T2EX  |PB.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
N * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(1, 1, 0, 1) = nWRL(EBI) function is selected.           
N * |[27]    |PB3_T3EX  |PB.3 Pin Alternative Function Selection
N * |        |          |Bits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(1, 1, 0, 0, 1) = nWRH(EBI) function is selected.
N * @var GCR_T::ALT_MFP1
N * Offset: 0x58  Alternative Multiple Function Pin Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PA2_SC0CLK|PA.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2] determine the PA.2 function.
N * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_CLK function is selected.
N * |        |          |(1, 1, 0, 1) = AD11 function is selected.               
N * |[1]     |PA3_SC0DAT|PA.3 Pin Alternative Function Selection 
N * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3] determine the PA.3 function.
N * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_DAT function is selected.
N * |        |          |(1, 1, 0, 1) = AD10 function is selected.   
N * |[2]     |PA0_SC0PWR|PA.0 Pin Alternative Function Selection
N * |        |          |Bit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.
N * |        |          |(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ADC0 function is selected.
N * |        |          |(1, 1) = SC0_PWR function is selected.  
N * |[3]     |PA1_SC0RST|PA.1 Pin Alternative Function Selection     
N * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1] determine the PA.1 function.
N * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD12 function is selected.       
N * |[4]     |PC6_SC0CD |PC.6 Pin Alternative Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.
N * |        |          |(EBI_EN, PC6_SC0CD, GPC_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_P function is selected.
N * |        |          |(0, 1, 1) = SC0_CD function is selected.
N * |        |          |(1, 0, 1) = AD4 function is selected.        
N * |[5]     |PA6_SC1CLK|PA.6 Pin Alternative Function Selection     
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.
N * |        |          |(EBI_EN, PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ADC6 function is selected.
N * |        |          |(0, 1, 1) = SC1_CLK function is selected.
N * |        |          |(1, 0, 1) = AD7 function is selected.          
N * |[6]     |PA7_SC1DAT|PA.7 Pin Alternative Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7] determine the PA.7 function.
N * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
N * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
N * |        |          |(0, 1, 0, 1) = SC1_DAT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.          
N * |[7]     |PA4_SC1PWR|PA.4 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4] determine the PA.4 function.
N * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
N * |        |          |(1, 1, 0, 1) = AD9 function is selected.     
N * |[8]     |PA5_SC1RST|PA.5 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]), PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.
N * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD8 function is selected.     
N * |[9]     |PC7_SC1CD |PC.7 Pin Alternative Function Selection     
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.
N * |        |          |(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_N function is selected.
N * |        |          |(0, 1, 1) = SC1_CD function is selected.
N * |        |          |(1, 0, 1) = AD5 function is selected.   
N * |[10]    |PA13_SC2CLK|PA.13 Pin Alternative Function Selection 
N * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and GPA_MFP[13] determine the PA.13 function.
N * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_CLK function is selected.
N * |        |          |(1, 1, 0, 1) = AD14 function is selected.         
N * |[11]    |PA12_SC2DAT|PA.12 Pin Alternative Function Selection 
N * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and GPA_MFP[12] determine the PA.12 function.
N * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_DAT function is selected.
N * |        |          |(1, 1, 0, 1) = AD13 function is selected.           
N * |[12]    |PA15_SC2PWR|PA.15 Pin Alternative Function Selection
N * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15 function.
N * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = PWM3 function is selected.
N * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
N * |        |          |(1, 0, 1) = SC2_PWR function is selected.             
N * |[13]    |PA14_SC2RST|PA.14 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and GPA_MFP[14] determine the PA.14 function.
N * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD15 function is selected.             
N * |[14]    |PB3_SC2CD |PB.3 Pin Alternative Function Selection
N * |        |          |Bits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(1, 1, 0, 0, 1) = nWRH(EBI) function is selected.
N * @var GCR_T::ALT_MFP2
N * Offset: 0x5C  Alternative Multiple Function Pin Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |Reserved  |Reserved
N * |        |          |Reserved
N * @var GCR_T::IRCTRIMCTL
N * Offset: 0x80  IRC Trim Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |TRIM_SEL  |Trim Frequency Selection
N * |        |          |This field indicates the target frequency of internal 22.1184 MHz high speed oscillator will
N * |        |          |trim to precise 22.1184MHz or 24MHz automatically.
N * |        |          |If no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is
N * |        |          |disabled.
N * |        |          |During auto trim operation, if clock error detected because of CLKERR_STOP_EN is set to 1 or
N * |        |          |trim retry limitation counts reached, this field will be cleared to 00 automatically.
N * |        |          |00 = HIRC auto trim function Disabled.
N * |        |          |01 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
N * |        |          |10 = HIRC auto trim function Enabled and HIRC trimmed to 24 MHz.
N * |        |          |11 = Reserved.
N * |[5:4]   |TRIM_LOOP |Trim Calculation Loop
N * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clocks in.
N * |        |          |For example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on
N * |        |          |the average frequency difference in 4 32.768 kHz clock.
N * |        |          |00 = Trim value calculation is based on average difference in 4 clocks.
N * |        |          |01 = Trim value calculation is based on average difference in 8 clocks.
N * |        |          |10 = Trim value calculation is based on average difference in 16 clocks.
N * |        |          |11 = Trim value calculation is based on average difference in 32 clocks.
N * |[7:6]   |TRIM_RETRY_CNT|Trim Value Update Limitation Count
N * |        |          |The field defines that how many times of HIRC trim value is updated by auto trim circuit
N * |        |          |before the HIRC frequency locked.
N * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
N * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still
N * |        |          |doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.
N * |        |          |00 = Trim retry count limitation is 64.
N * |        |          |01 = Trim retry count limitation is 128.
N * |        |          |10 = Trim retry count limitation is 256.
N * |        |          |11 = Trim retry count limitation is 512.
N * |[8]     |CLKERR_STOP_EN|Clock Error Stop Enable
N * |        |          |When this bit is set to 0, the trim operation is keep going if clock is inaccuracy.
N * |        |          |When this bit is set to 1, the trim operation is stopped if clock is inaccuracy.
N * @var GCR_T::IRCTRIMIEN
N * Offset: 0x84  IRC Trim Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TRIM_FAIL_IEN|Trim Failure Interrupt Enable
N * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation
N * |        |          |count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL
N * |        |          |(IRCTRIMCTL[1:0]).
N * |        |          |If this bit is high and TRIM_FAIL_INT (IRCTRIMINT[1]) is set during auto trim operation.
N * |        |          |An interrupt will be triggered to notify that HIRC trim value update limitation count was
N * |        |          |reached.
N * |        |          |0 = TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Disabled.
N * |        |          |1 = TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Enabled.
N * |[2]     |CLKERR_IEN|Clock Error Interrupt Enable
N * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim
N * |        |          |operation.
N * |        |          |If this bit is set to1, and CLKERR_INT (IRCTRIMINT[2]) is set during auto trim operation.
N * |        |          |An interrupt will be triggered to notify the clock frequency is inaccuracy.
N * |        |          |0 = CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Disabled.
N * |        |          |1 = CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Enabled.
N * @var GCR_T::IRCTRIMINT
N * Offset: 0x88  IRC Trim Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FREQ_LOCK |HIRC Frequency Lock Status
N * |        |          |This bit indicates the internal 22.1184 MHz high speed oscillator frequency is locked.
N * |        |          |This is a status bit and doesn't trigger any interrupt.
N * |[1]     |TRIM_FAIL_INT|Trim Failure Interrupt Status
N * |        |          |This bit indicates that internal 22.1184 MHz high speed oscillator trim value update
N * |        |          |limitation count reached and the internal 22.1184 MHz high speed oscillator clock frequency
N * |        |          |still doesn't be locked.
N * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL [1:0]) will
N * |        |          |be cleared to 00 by hardware automatically.
N * |        |          |If this bit is set and TRIM_FAIL_IEN (IRCTRIMIEN[1]) is high, an interrupt will be triggered
N * |        |          |to notify that HIRC trim value update limitation count was reached.
N * |        |          |Write 1 to clear this to 0.
N * |        |          |0 = Trim value update limitation count did not reach.
N * |        |          |1 = Trim value update limitation count reached and internal 22.1184 MHz high speed
N * |        |          |oscillator frequency was still not locked.
N * |[2]     |CLKERR_INT|Clock Error Interrupt Status
N * |        |          |When the frequency of external 32.768 kHz low speed crystal or internal 22.1184 MHz high
N * |        |          |speed oscillator is shift larger to unreasonable value, this bit will be set and to be an
N * |        |          |indicate that clock frequency is inaccuracy
N * |        |          |Once this bit is set to 1, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL [1:0])
N * |        |          |will be cleared to 00 by hardware automatically if CLKERR_STOP_EN (IRCTRIMCTL [8]) is set to
N * |        |          |1.
N * |        |          |If this bit is set and CLKERR_IEN (IRCTRIMIEN [2]) is high, an interrupt will be triggered
N * |        |          |to notify the clock frequency is inaccuracy.
N * |        |          |Write 1 to clear this to 0.
N * |        |          |0 = Clock frequency is accurate.
N * |        |          |1 = Clock frequency is inaccurate.
N * @var GCR_T::REGWRPROT
N * Offset: 0x100  Register Write Protection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |REGPROTDIS|Register Write-Protection Disable Index (Read Only)
N * |        |          |0 = Write-protection is enabled for writing protected registers.
N * |        |          |Any write to the protected register is ignored.
N * |        |          |1 = Write-protection is disabled for writing protected registers.
N * |        |          |The Protected registers are:
N * |        |          |IPRSTC1: address 0x5000_0008
N * |        |          |BODCR: address 0x5000_0018
N * |        |          |PORCR: address 0x5000_0024
N * |        |          |PWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear)
N * |        |          |APBCLK bit[0]: address 0x5000_0208 (bit[0] is watchdog clock enable)
N * |        |          |CLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)
N * |        |          |CLKSEL1 bit[1:0]: address 0x5000_0214 (for watchdog clock source selection)
N * |        |          |NMI_SEL bit[8]: address 0x5000_0380 (for NMI_EN clock source selection)
N * |        |          |ISPCON: address 0x5000_C000 (Flash ISP Control register)
N * |        |          |ISPTRG: address 0x5000_C010 (ISP Trigger Control register)
N * |        |          |WTCR: address 0x4000_4000
N * |        |          |FATCON: address 0x5000_C018
N * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the
N * |        |          |description.
N * |[7:0]   |REGWRPROT |Register Write-Protection Code (Write Only)
N * |        |          |Some registers have write-protection function.
N * |        |          |Writing these registers have to disable the protected function by writing the sequence value
N * |        |          |"59h", "16h", "88h" to this field.
N * |        |          |After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection
N * |        |          |registers can be normal write.
N */
N
N    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register                         */
X    volatile const  uint32_t PDID;           
N    __IO uint32_t RSTSRC;        /* Offset: 0x04  System Reset Source Register                                       */
X    volatile uint32_t RSTSRC;         
N    __IO uint32_t IPRSTC1;       /* Offset: 0x08  IP Reset Control Register 1                                        */
X    volatile uint32_t IPRSTC1;        
N    __IO uint32_t IPRSTC2;       /* Offset: 0x0C  IP Reset Control Register 2                                        */
X    volatile uint32_t IPRSTC2;        
N    __IO uint32_t IPRSTC3;       /* Offset: 0x10  IP Reset Control Register 3                                        */
X    volatile uint32_t IPRSTC3;        
N    __I  uint32_t RESERVE0;
X    volatile const  uint32_t RESERVE0;
N    __IO uint32_t BODCR;         /* Offset: 0x18  Brown-out Detector Control Register                                */
X    volatile uint32_t BODCR;          
N    __IO uint32_t TEMPCR;        /* Offset: 0x1C  Temperature Sensor Control Register                                */
X    volatile uint32_t TEMPCR;         
N    __I  uint32_t RESERVE1;
X    volatile const  uint32_t RESERVE1;
N    __IO uint32_t PORCR;         /* Offset: 0x24  Power-on-Reset Controller Register                                 */
X    volatile uint32_t PORCR;          
N    __I  uint32_t RESERVE2[2];
X    volatile const  uint32_t RESERVE2[2];
N    __IO uint32_t GPA_MFP;       /* Offset: 0x30  GPIOA Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPA_MFP;        
N    __IO uint32_t GPB_MFP;       /* Offset: 0x34  GPIOB Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPB_MFP;        
N    __IO uint32_t GPC_MFP;       /* Offset: 0x38  GPIOC Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPC_MFP;        
N    __IO uint32_t GPD_MFP;       /* Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPD_MFP;        
N    __IO uint32_t GPE_MFP;       /* Offset: 0x40  GPIOE Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPE_MFP;        
N    __IO uint32_t GPF_MFP;       /* Offset: 0x44  GPIOF Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPF_MFP;        
N    __I  uint32_t RESERVE3[2];
X    volatile const  uint32_t RESERVE3[2];
N    __IO uint32_t ALT_MFP;       /* Offset: 0x50  Alternative Multiple Function Pin Control Register                 */
X    volatile uint32_t ALT_MFP;        
N    __I  uint32_t RESERVE4;
X    volatile const  uint32_t RESERVE4;
N    __IO uint32_t ALT_MFP1;      /* Offset: 0x58  Alternative Multiple Function Pin Control Register 1               */
X    volatile uint32_t ALT_MFP1;       
N    __IO uint32_t ALT_MFP2;      /* Offset: 0x5C  Alternative Multiple Function Pin Control Register 2               */
X    volatile uint32_t ALT_MFP2;       
N    __I  uint32_t RESERVE5[8];
X    volatile const  uint32_t RESERVE5[8];
N    __IO uint32_t IRCTRIMCTL;    /* Offset: 0x80  IRC Trim Control Register                                          */
X    volatile uint32_t IRCTRIMCTL;     
N    __IO uint32_t IRCTRIMIEN;    /* Offset: 0x84  IRC Trim Interrupt Enable Register                                 */
X    volatile uint32_t IRCTRIMIEN;     
N    __IO uint32_t IRCTRIMINT;    /* Offset: 0x88  IRC Trim Interrupt Status Register                                 */
X    volatile uint32_t IRCTRIMINT;     
N    __I  uint32_t RESERVE6[29];   
X    volatile const  uint32_t RESERVE6[29];   
N    __IO uint32_t REGWRPROT;     /* Offset: 0x100  Register Write Protection Register                                */
X    volatile uint32_t REGWRPROT;      
N
N} GCR_T;
N
N
N
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR_T::RSTSRC: RSTS_CPU Position */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
N
N#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR_T::RSTSRC: RSTS_SYS Position */
N#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR_T::RSTSRC: RSTS_SYS Mask */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR_T::RSTSRC: RSTS_BOD Position */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
N
N#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR_T::RSTSRC: RSTS_LVR Position */
N#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR_T::RSTSRC: RSTS_WDT Position */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR_T::RSTSRC: RSTS_RESET Position */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR_T::RSTSRC: RSTS_POR Position */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR_T::RSTSRC: RSTS_POR Mask */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_EBI_RST_Pos                 3                                   /*!< GCR_T::IPRSTC1: EBI_RST Position */
N#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)    /*!< GCR_T::IPRSTC1: EBI_RST Mask */
N
N#define SYS_IPRSTC1_PDMA_RST_Pos                2                                   /*!< GCR_T::IPRSTC1: PDMA_RST Position */
N#define SYS_IPRSTC1_PDMA_RST_Msk                (1ul << SYS_IPRSTC1_PDMA_RST_Pos)   /*!< GCR_T::IPRSTC1: PDMA_RST Mask */
N
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR_T::IPRSTC1: CPU_RST Position */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR_T::IPRSTC1: CPU_RST Mask */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR_T::IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_I2S_RST_Pos                 29                                  /*!< GCR_T::IPRSTC2: I2S_RST Position */
N#define SYS_IPRSTC2_I2S_RST_Msk                 (1ul << SYS_IPRSTC2_I2S_RST_Pos)    /*!< GCR_T::IPRSTC2: I2S_RST Mask */
N
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR_T::IPRSTC2: ADC_RST Position */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR_T::IPRSTC2: ADC_RST Mask */
N
N#define SYS_IPRSTC2_USBD_RST_Pos                27                                  /*!< GCR_T::IPRSTC2: USBD_RST Position */
N#define SYS_IPRSTC2_USBD_RST_Msk                (1ul << SYS_IPRSTC2_USBD_RST_Pos)   /*!< GCR_T::IPRSTC2: USBD_RST Mask */
N
N#define SYS_IPRSTC2_PS2_RST_Pos                 23                                  /*!< GCR_T::IPRSTC2: PS2_RST Position */
N#define SYS_IPRSTC2_PS2_RST_Msk                 (1ul << SYS_IPRSTC2_PS2_RST_Pos)    /*!< GCR_T::IPRSTC2: PS2_RST Mask */
N
N#define SYS_IPRSTC2_ACMP_RST_Pos                22                                  /*!< GCR_T::IPRSTC2: ACMP_RST Position */
N#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)   /*!< GCR_T::IPRSTC2: ACMP_RST Mask */
N
N#define SYS_IPRSTC2_PWM47_RST_Pos               21                                  /*!< GCR_T::IPRSTC2: PWM47_RST Position */
N#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)  /*!< GCR_T::IPRSTC2: PWM47_RST Mask */
N
N#define SYS_IPRSTC2_PWM03_RST_Pos               20                                  /*!< GCR_T::IPRSTC2: PWM03_RST Position */
N#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)  /*!< GCR_T::IPRSTC2: PWM03_RST Mask */
N
N#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR_T::IPRSTC2: UART2_RST Position */
N#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR_T::IPRSTC2: UART2_RST Mask */
N
N#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR_T::IPRSTC2: UART1_RST Position */
N#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR_T::IPRSTC2: UART1_RST Mask */
N
N#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR_T::IPRSTC2: UART0_RST Position */
N#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR_T::IPRSTC2: UART0_RST Mask */
N
N#define SYS_IPRSTC2_SPI3_RST_Pos                15                                  /*!< GCR_T::IPRSTC2: SPI3_RST Position */
N#define SYS_IPRSTC2_SPI3_RST_Msk                (1ul << SYS_IPRSTC2_SPI3_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI3_RST Mask */
N
N#define SYS_IPRSTC2_SPI2_RST_Pos                14                                  /*!< GCR_T::IPRSTC2: SPI2_RST Position */
N#define SYS_IPRSTC2_SPI2_RST_Msk                (1ul << SYS_IPRSTC2_SPI2_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI2_RST Mask */
N
N#define SYS_IPRSTC2_SPI1_RST_Pos                13                                  /*!< GCR_T::IPRSTC2: SPI1_RST Position */
N#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI1_RST Mask */
N
N#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR_T::IPRSTC2: SPI0_RST Position */
N#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
N
N#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR_T::IPRSTC2: I2C1_RST Position */
N#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
N
N#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR_T::IPRSTC2: I2C0_RST Position */
N#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
N
N#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR_T::IPRSTC2: TMR3_RST Position */
N#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
N
N#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR_T::IPRSTC2: TMR2_RST Position */
N#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR_T::IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR_T::IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR_T::IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
N
N/* GCR IPRSTC3 Bit Field Definitions */
N#define SYS_IPRSTC3_SC2_RST_Pos                 2                                   /*!< GCR_T::IPRSTC3: SC2_RST Position */
N#define SYS_IPRSTC3_SC2_RST_Msk                 (1ul << SYS_IPRSTC3_SC2_RST_Pos)    /*!< GCR_T::IPRSTC3: SC2_RST Mask */
N
N#define SYS_IPRSTC3_SC1_RST_Pos                 1                                   /*!< GCR_T::IPRSTC3: SC1_RST Position */
N#define SYS_IPRSTC3_SC1_RST_Msk                 (1ul << SYS_IPRSTC3_SC1_RST_Pos)    /*!< GCR_T::IPRSTC3: SC1_RST Mask */
N
N#define SYS_IPRSTC3_SC0_RST_Pos                 0                                   /*!< GCR_T::IPRSTC3: SC0_RST Position */
N#define SYS_IPRSTC3_SC0_RST_Msk                 (1ul << SYS_IPRSTC3_SC0_RST_Pos)    /*!< GCR_T::IPRSTC3: SC0_RST Mask */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR_T::BODCR: LVR_EN Position */
N#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR_T::BODCR: LVR_EN Mask */
N
N#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR_T::BODCR: BOD_OUT Position */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR_T::BODCR: BOD_OUT Mask */
N
N#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR_T::BODCR: BOD_LPM Position */
N#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR_T::BODCR: BOD_LPM Mask */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR_T::BODCR: BOD_INTF Position */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR_T::BODCR: BOD_INTF Mask */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR_T::BODCR: BOD_RSTEN Position */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR_T::BODCR: BOD_RSTEN Mask */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR_T::BODCR: BOD_VL Position */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR_T::BODCR: BOD_VL Mask */
N
N#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR_T::BODCR: BOD_EN Position */
N#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR_T::BODCR: BOD_EN Mask */
N
N/* GCR TEMPCR Bit Field Definitions */
N#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                   /*!< GCR_T::TEMPCR: VTEMP_EN Position */
N#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)    /*!< GCR_T::TEMPCR: VTEMP_EN Mask */
N
N/* GCR PORCR Bit Field Definitions */
N#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR_T::PORCR: POR_DIS_CODE Position */
N#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR_T::PORCR: POR_DIS_CODE Mask */
N
N/* GCR GPAMFP Bit Field Definitions */
N#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR_T::GPA_MFP: GPA_TYPE Position */
N#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR_T::GPA_MFP: GPA_TYPE Mask */
N
N#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR_T::GPA_MFP: GPA_MFP Position */
N#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR_T::GPA_MFP: GPA_MFP Mask */
N
N
N/* GCR GPBMFP Bit Field Definitions */
N#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR_T::GPB_MFP: GPB_TYPE Position */
N#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR_T::GPB_MFP: GPB_TYPE Mask */
N
N#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR_T::GPB_MFP: GPB_MFP Position */
N#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR_T::GPB_MFP: GPB_MFP Mask */
N
N/* GCR GPCMFP Bit Field Definitions */
N#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR_T::GPC_MFP: GPC_TYPE Position */
N#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR_T::GPC_MFP: GPC_TYPE Mask */
N
N#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR_T::GPC_MFP: GPC_MFP Position */
N#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR_T::GPC_MFP: GPC_MFP Mask */
N
N/* GCR GPDMFP Bit Field Definitions */
N#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR_T::GPD_MFP: GPD_TYPE Position */
N#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR_T::GPD_MFP: GPD_TYPE Mask */
N
N#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR_T::GPD_MFP: GPD_MFP Position */
N#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR_T::GPD_MFP: GPD_MFP Mask */
N
N/* GCR GPEMFP Bit Field Definitions */
N#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR_T::GPE_MFP: GPE_TYPE Position */
N#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR_T::GPE_MFP: GPE_TYPE Mask */
N
N#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR_T::GPE_MFP: GPE_MFP5 Position */
N#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP5 Mask */
N
N#define SYS_GPE_MFP_GPE_MFP1_Pos                 1                                          /*!< GCR_T::GPE_MFP: GPE_MFP1 Position */
N#define SYS_GPE_MFP_GPE_MFP1_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP1_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP1 Mask */
N
N#define SYS_GPE_MFP_GPE_MFP0_Pos                 0                                          /*!< GCR_T::GPE_MFP: GPE_MFP0 Position */
N#define SYS_GPE_MFP_GPE_MFP0_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP0_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP0 Mask */
N
N/* GCR GPFMFP Bit Field Definitions */
N#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR_T::GPF_MFP: GPF_TYPE Position */
N#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0xFul << SYS_GPF_MFP_GPF_TYPE_Pos)        /*!< GCR_T::GPF_MFP: GPF_TYPE Mask */
N
N#define SYS_GPF_MFP_GPF_MFP3_Pos                 3                                          /*!< GCR_T::GPF_MFP: GPF_MFP3 Position */
N#define SYS_GPF_MFP_GPF_MFP3_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP3_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP3 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP2_Pos                 2                                          /*!< GCR_T::GPF_MFP: GPF_MFP2 Position */
N#define SYS_GPF_MFP_GPF_MFP2_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP2_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP2 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP1_Pos                 1                                          /*!< GCR_T::GPF_MFP: GPF_MFP1 Position */
N#define SYS_GPF_MFP_GPF_MFP1_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP1_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP1 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP0_Pos                 0                                          /*!< GCR_T::GPF_MFP: GPF_MFP0 Position */
N#define SYS_GPF_MFP_GPF_MFP0_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP0_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP0 Mask */
N
N/* GCR ALTMFP Bit Field Definitions */
N#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR_T::ALT_MFP: PB3_T3EX Position */
N#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR_T::ALT_MFP: PB2_T2EX Position */
N#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR_T::ALT_MFP: PE5_T1EX Position */
N#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR_T::ALT_MFP: PE5_T1EX Mask */
N
N#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR_T::ALT_MFP: PB15_T0EX Position */
N#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR_T::ALT_MFP: PB15_T0EX Mask */
N
N#define SYS_ALT_MFP_EBI_HB_EN_Pos                16                                         /*!< GCR_T::ALT_MFP: EBI_HB_EN Position */
N#define SYS_ALT_MFP_EBI_HB_EN_Msk                (0xFFul << SYS_ALT_MFP_EBI_HB_EN_Pos)      /*!< GCR_T::ALT_MFP: EBI_HB_EN Mask */
N
N#define SYS_ALT_MFP_EBI_nWRH_EN_Pos              14                                         /*!< GCR_T::ALT_MFP: EBI_nWRH_EN Position */
N#define SYS_ALT_MFP_EBI_nWRH_EN_Msk              (1ul << SYS_ALT_MFP_EBI_nWRH_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_nWRH_EN Mask */
N
N#define SYS_ALT_MFP_EBI_nWRL_EN_Pos              13                                         /*!< GCR_T::ALT_MFP: EBI_nWRL_EN Position */
N#define SYS_ALT_MFP_EBI_nWRL_EN_Msk              (1ul << SYS_ALT_MFP_EBI_nWRL_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_nWRL_EN Mask */
N
N#define SYS_ALT_MFP_EBI_MCLK_EN_Pos              12                                         /*!< GCR_T::ALT_MFP: EBI_MCLK_EN Position */
N#define SYS_ALT_MFP_EBI_MCLK_EN_Msk              (1ul << SYS_ALT_MFP_EBI_MCLK_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_MCLK_EN Mask */
N
N#define SYS_ALT_MFP_EBI_EN_Pos                   11                                         /*!< GCR_T::ALT_MFP: EBI_EN Position */
N#define SYS_ALT_MFP_EBI_EN_Msk                   (1ul << SYS_ALT_MFP_EBI_EN_Pos)            /*!< GCR_T::ALT_MFP: EBI_EN Mask */
N
N#define SYS_ALT_MFP_PB12_CLKO_Pos                10                                         /*!< GCR_T::ALT_MFP: PB12_CLKO Position */
N#define SYS_ALT_MFP_PB12_CLKO_Msk                (1ul << SYS_ALT_MFP_PB12_CLKO_Pos)         /*!< GCR_T::ALT_MFP: PB12_CLKO Mask */
N
N#define SYS_ALT_MFP_PA15_I2SMCLK_Pos             9                                          /*!< GCR_T::ALT_MFP: PA15_I2SMCLK Position */
N#define SYS_ALT_MFP_PA15_I2SMCLK_Msk             (1ul << SYS_ALT_MFP_PA15_I2SMCLK_Pos)      /*!< GCR_T::ALT_MFP: PA15_I2SMCLK Mask */
N
N#define SYS_ALT_MFP_PC3_I2SDO_Pos                8                                          /*!< GCR_T::ALT_MFP: PC3_I2SDO Position */
N#define SYS_ALT_MFP_PC3_I2SDO_Msk                (1ul << SYS_ALT_MFP_PC3_I2SDO_Pos)         /*!< GCR_T::ALT_MFP: PC3_I2SDO Mask */
N
N#define SYS_ALT_MFP_PC2_I2SDI_Pos                7                                          /*!< GCR_T::ALT_MFP: PC2_I2SDI Position */
N#define SYS_ALT_MFP_PC2_I2SDI_Msk                (1ul << SYS_ALT_MFP_PC2_I2SDI_Pos)         /*!< GCR_T::ALT_MFP: PC2_I2SDI Mask */
N
N#define SYS_ALT_MFP_PC1_I2SBCLK_Pos              6                                          /*!< GCR_T::ALT_MFP: PC1_I2SBCLK Position */
N#define SYS_ALT_MFP_PC1_I2SBCLK_Msk              (1ul << SYS_ALT_MFP_PC1_I2SBCLK_Pos)       /*!< GCR_T::ALT_MFP: PC1_I2SBCLK Mask */
N
N#define SYS_ALT_MFP_PC0_I2SLRCLK_Pos             5                                          /*!< GCR_T::ALT_MFP: PC0_I2SLRCLK Position */
N#define SYS_ALT_MFP_PC0_I2SLRCLK_Msk             (1ul << SYS_ALT_MFP_PC0_I2SLRCLK_Pos)      /*!< GCR_T::ALT_MFP: PC0_I2SLRCLK Mask */
N
N#define SYS_ALT_MFP_PB11_PWM4_Pos                4                                          /*!< GCR_T::ALT_MFP: PB11_PWM4 Position */
N#define SYS_ALT_MFP_PB11_PWM4_Msk                (1ul << SYS_ALT_MFP_PB11_PWM4_Pos)         /*!< GCR_T::ALT_MFP: PB11_PWM4 Mask */
N
N#define SYS_ALT_MFP_PB14_S31_Pos                 3                                          /*!< GCR_T::ALT_MFP: PB14_S31 Position */
N#define SYS_ALT_MFP_PB14_S31_Msk                 (1ul << SYS_ALT_MFP_PB14_S31_Pos)          /*!< GCR_T::ALT_MFP: PB14_S31 Mask */
N
N#define SYS_ALT_MFP_PA7_S21_Pos                  2                                          /*!< GCR_T::ALT_MFP: PA7_S21 Position */
N#define SYS_ALT_MFP_PA7_S21_Msk                  (1ul << SYS_ALT_MFP_PA7_S21_Pos)           /*!< GCR_T::ALT_MFP: PA7_S21 Mask */
N
N#define SYS_ALT_MFP_PB9_S11_Pos                  1                                          /*!< GCR_T::ALT_MFP: PB9_S11 Position */
N#define SYS_ALT_MFP_PB9_S11_Msk                  (1ul << SYS_ALT_MFP_PB9_S11_Pos)           /*!< GCR_T::ALT_MFP: PB9_S11 Mask */
N
N#define SYS_ALT_MFP_PB10_S01_Pos                 0                                          /*!< GCR_T::ALT_MFP: PB10_S01 Position */
N#define SYS_ALT_MFP_PB10_S01_Msk                 (1ul << SYS_ALT_MFP_PB10_S01_Pos)          /*!< GCR_T::ALT_MFP: PB10_S01 Mask */
N
N/* GCR ALTMFP1 Bit Field Definitions */
N#define SYS_ALT_MFP1_PB3_SC2CD_Pos              14                                          /*!< GCR_T::ALT_MFP1: PB3_SC2CD Position */
N#define SYS_ALT_MFP1_PB3_SC2CD_Msk              (1ul << SYS_ALT_MFP1_PB3_SC2CD_Pos)         /*!< GCR_T::ALT_MFP1: PB3_SC2CD Mask */
N
N#define SYS_ALT_MFP1_PA14_SC2RST_Pos            13                                          /*!< GCR_T::ALT_MFP1: PA14_SC2RST Position */
N#define SYS_ALT_MFP1_PA14_SC2RST_Msk            (1ul << SYS_ALT_MFP1_PA14_SC2RST_Pos)       /*!< GCR_T::ALT_MFP1: PA14_SC2RST Mask */
N
N#define SYS_ALT_MFP1_PA15_SC2PWR_Pos            12                                          /*!< GCR_T::ALT_MFP1: PA15_SC2PWR Position */
N#define SYS_ALT_MFP1_PA15_SC2PWR_Msk            (1ul << SYS_ALT_MFP1_PA15_SC2PWR_Pos)       /*!< GCR_T::ALT_MFP1: PA15_SC2PWR Mask */
N
N#define SYS_ALT_MFP1_PA12_SC2DAT_Pos            11                                          /*!< GCR_T::ALT_MFP1: PA12_SC2DAT Position */
N#define SYS_ALT_MFP1_PA12_SC2DAT_Msk            (1ul << SYS_ALT_MFP1_PA12_SC2DAT_Pos)       /*!< GCR_T::ALT_MFP1: PA12_SC2DAT Mask */
N
N#define SYS_ALT_MFP1_PA13_SC2CLK_Pos            10                                          /*!< GCR_T::ALT_MFP1: PA13_SC2CLK Position */
N#define SYS_ALT_MFP1_PA13_SC2CLK_Msk            (1ul << SYS_ALT_MFP1_PA13_SC2CLK_Pos)       /*!< GCR_T::ALT_MFP1: PA13_SC2CLK Mask */
N
N#define SYS_ALT_MFP1_PC7_SC1CD_Pos              9                                           /*!< GCR_T::ALT_MFP1: PC7_SC1CD Position */
N#define SYS_ALT_MFP1_PC7_SC1CD_Msk              (1ul << SYS_ALT_MFP1_PC7_SC1CD_Pos)         /*!< GCR_T::ALT_MFP1: PC7_SC1CD Mask */
N
N#define SYS_ALT_MFP1_PA5_SC1RST_Pos             8                                           /*!< GCR_T::ALT_MFP1: PA5_SC1RST Position */
N#define SYS_ALT_MFP1_PA5_SC1RST_Msk             (1ul << SYS_ALT_MFP1_PA5_SC1RST_Pos)        /*!< GCR_T::ALT_MFP1: PA5_SC1RST Mask */
N
N#define SYS_ALT_MFP1_PA4_SC1PWR_Pos             7                                           /*!< GCR_T::ALT_MFP1: PA4_SC1PWR Position */
N#define SYS_ALT_MFP1_PA4_SC1PWR_Msk             (1ul << SYS_ALT_MFP1_PA4_SC1PWR_Pos)        /*!< GCR_T::ALT_MFP1: PA4_SC1PWR Mask */
N
N#define SYS_ALT_MFP1_PA7_SC1DAT_Pos             6                                           /*!< GCR_T::ALT_MFP1: PA7_SC1DAT Position */
N#define SYS_ALT_MFP1_PA7_SC1DAT_Msk             (1ul << SYS_ALT_MFP1_PA7_SC1DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA7_SC1DAT Mask */
N
N#define SYS_ALT_MFP1_PA6_SC1CLK_Pos             5                                           /*!< GCR_T::ALT_MFP1: PA6_SC1CLK Position */
N#define SYS_ALT_MFP1_PA6_SC1CLK_Msk             (1ul << SYS_ALT_MFP1_PA6_SC1CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA6_SC1CLK Mask */
N
N#define SYS_ALT_MFP1_PC6_SC0CD_Pos              4                                           /*!< GCR_T::ALT_MFP1: PC6_SC0CD Position */
N#define SYS_ALT_MFP1_PC6_SC0CD_Msk              (1ul << SYS_ALT_MFP1_PC6_SC0CD_Pos)         /*!< GCR_T::ALT_MFP1: PC6_SC0CD Mask */
N
N#define SYS_ALT_MFP1_PA1_SC0RST_Pos             3                                           /*!< GCR_T::ALT_MFP1: PA1_SC0RST Position */
N#define SYS_ALT_MFP1_PA1_SC0RST_Msk             (1ul << SYS_ALT_MFP1_PA1_SC0RST_Pos)        /*!< GCR_T::ALT_MFP1: PA1_SC0RST Mask */
N
N#define SYS_ALT_MFP1_PA0_SC0PWR_Pos             2                                           /*!< GCR_T::ALT_MFP1: PA0_SC0PWR Position */
N#define SYS_ALT_MFP1_PA0_SC0PWR_Msk             (1ul << SYS_ALT_MFP1_PA0_SC0PWR_Pos)        /*!< GCR_T::ALT_MFP1: PA0_SC0PWR Mask */
N
N#define SYS_ALT_MFP1_PA3_SC0DAT_Pos             1                                           /*!< GCR_T::ALT_MFP1: PA3_SC0DAT Position */
N#define SYS_ALT_MFP1_PA3_SC0DAT_Msk             (1ul << SYS_ALT_MFP1_PA3_SC0DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA3_SC0DAT Mask */
N
N#define SYS_ALT_MFP1_PA2_SC0CLK_Pos             0                                           /*!< GCR_T::ALT_MFP1: PA2_SC0CLK Position */
N#define SYS_ALT_MFP1_PA2_SC0CLK_Msk             (1ul << SYS_ALT_MFP1_PA2_SC0CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA2_SC0CLK Mask */
N
N/* GCR IRCTRIMCTL Bit Field Definitions */
N#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos       8                                           /*!< GCR_T::IRCTRIMCTL: CLKERR_STOP_EN Position */
N#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Msk       (1ul << SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos)  /*!< GCR_T::IRCTRIMCTL: CLKERR_STOP_EN Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos       6                                           /*!< GCR_T::IRCTRIMCTL: TRIM_RETRY_CNT Position */
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Msk       (3ul << SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos)  /*!< GCR_T::IRCTRIMCTL: TRIM_RETRY_CNT Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos            4                                           /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Position */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk            (3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)       /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_SEL_Pos             0                                           /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Position */
N#define SYS_IRCTRIMCTL_TRIM_SEL_Msk             (3ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)        /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Mask */
N
N/* GCR IRCTRIMIEN Bit Field Definitions */
N#define SYS_IRCTRIMIEN_CLKERR_IEN_Pos           2                                           /*!< GCR_T::IRCTRIMIEN: CLKERR_IEN Position */
N#define SYS_IRCTRIMIEN_CLKERR_IEN_Msk           (1ul << SYS_IRCTRIMIEN_CLKERR_IEN_Pos)      /*!< GCR_T::IRCTRIMIEN: CLKERR_IEN Mask */
N
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos        1                                           /*!< GCR_T::IRCTRIMIEN: TRIM_FAIL_IEN Position */
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk        (1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)   /*!< GCR_T::IRCTRIMIEN: TRIM_FAIL_IEN Mask */
N
N/* GCR IRCTRIMINT Bit Field Definitions */
N#define SYS_IRCTRIMINT_CLKERR_INT_Pos           2                                           /*!< GCR_T::IRCTRIMINT: CLKERR_INT Position */
N#define SYS_IRCTRIMINT_CLKERR_INT_Msk           (1ul << SYS_IRCTRIMINT_CLKERR_INT_Pos)      /*!< GCR_T::IRCTRIMINT: CLKERR_INT Mask */
N
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos        1                                           /*!< GCR_T::IRCTRIMINT: TRIM_FAIL_INT Position */
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk        (1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)   /*!< GCR_T::IRCTRIMINT: TRIM_FAIL_INT Mask */
N
N#define SYS_IRCTRIMINT_FREQ_LOCK_Pos            0                                           /*!< GCR_T::IRCTRIMINT: FREQ_LOCK Position */
N#define SYS_IRCTRIMINT_FREQ_LOCK_Msk            (1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)       /*!< GCR_T::IRCTRIMINT: FREQ_LOCK Mask */
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR_T::REGWRPROT: REGWRPROT Position */
N#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
N
N#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
N#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
N
N
N
Ntypedef struct
N{
N
N    /**
N     * @var GCR_INT_T::IRQSRC[32]
N     * Offset: 0x00-0x7C  IRQn(n=0~31) Interrupt Source Identity Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |INT_SRC   |Interrupt Source Identity
N     * |        |          |IRQ_SRC[0].0 - BOD INT
N     * |        |          |IRQ_SRC[1].0 - WDT INT
N     * |        |          |IRQ_SRC[1].1 - WWDT INT
N     * |        |          |IRQ_SRC[2].0 - EINT0, external interrupt 0 from PB.14
N     * |        |          |IRQ_SRC[3].0 - EINT1, external interrupt 1 from PB.15
N     * |        |          |IRQ_SRC[4].0 - GPA INT
N     * |        |          |IRQ_SRC[4].1 - GPB INT
N     * |        |          |IRQ_SRC[5].0 - GPC INT
N     * |        |          |IRQ_SRC[5].1 - GPD INT
N     * |        |          |IRQ_SRC[5].2 - GPE INT
N     * |        |          |IRQ_SRC[5].3 - GPF INT
N     * |        |          |IRQ_SRC[6].0 - PWM0 INT
N     * |        |          |IRQ_SRC[6].1 - PWM1 INT
N     * |        |          |IRQ_SRC[6].2 - PWM2 INT
N     * |        |          |IRQ_SRC[6].3 - PWM3 INT
N     * |        |          |IRQ_SRC[7].0 - PWM4 INT
N     * |        |          |IRQ_SRC[7].1 - PWM5 INT
N     * |        |          |IRQ_SRC[7].2 - PWM6 INT
N     * |        |          |IRQ_SRC[7].3 - PWM7 INT
N     * |        |          |IRQ_SRC[8].0 - TMR0 INT
N     * |        |          |IRQ_SRC[9].0 - TMR1 INT
N     * |        |          |IRQ_SRC[10].0 - TMR2 INT
N     * |        |          |IRQ_SRC[11].0 - TMR3 INT
N     * |        |          |IRQ_SRC[12].0 - UART0 INT
N     * |        |          |IRQ_SRC[12].1 - UART2 INT
N     * |        |          |IRQ_SRC[13].0 - UART1 INT
N     * |        |          |IRQ_SRC[14].0 - SPI0 INT
N     * |        |          |IRQ_SRC[15].0 - SPI1 INT
N     * |        |          |IRQ_SRC[16].0 - SPI2 INT
N     * |        |          |IRQ_SRC[17].0 - SPI3 INT
N     * |        |          |IRQ_SRC[18].0 - I2C0 INT
N     * |        |          |IRQ_SRC[19].0 - I2C1 INT
N     * |        |          |IRQ_SRC[22].0 - SC0 INT
N     * |        |          |IRQ_SRC[22].1 - SC1 INT
N     * |        |          |IRQ_SRC[22].2 - SC2 INT
N     * |        |          |IRQ_SRC[23].0 - USB INT
N     * |        |          |IRQ_SRC[24].0 - PS2 INT
N     * |        |          |IRQ_SRC[25].0 - ACMP INT
N     * |        |          |IRQ_SRC[26].0 - PDMA INT
N     * |        |          |IRQ_SRC[27].0 - I2S INT
N     * |        |          |IRQ_SRC[28].0 - Power Down Wake up INT
N     * |        |          |IRQ_SRC[29].0 - ADC INT
N     * |        |          |IRQ_SRC[30].0 - IRC INT
N     * |        |          |IRQ_SRC[31].0 - RTC INT
N     * @var GCR_INT_T::NMISEL
N     * Offset: 0x80  NMI Interrupt Source Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |NMI_SEL   |NMI interrupt source selection
N     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of IRQ0~IRQ31 by setting NMI_SEL with IRQ number.
N     * |        |          |The default NMI interrupt is assigned as IRQ0 interrupt if NMI is enabled by setting NMI_SEL[8].
N     * |[8]     |NMI_EN    |NMI interrupt enable (Write Protect)
N     * |        |          |0 = IRQ0~31 assigned to NMI interrupt Disabled. (NMI still can be software triggered by setting its pending flag.)
N     * |        |          |1 = IRQ0~31 assigned to NMI interrupt Enabled.
N     * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N     * @var GCR_INT_T::MCUIRQ
N     * Offset: 0x84  MCU Interrupt Request Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |MCU_IRQ   |MCU IRQ Source Register
N     * |        |          |The MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0.
N     * |        |          |When the MCU_IRQ[n] is 0:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Generate an interrupt to Cortex_M0 NVIC[n].
N     * |        |          |When the MCU_IRQ[n] is 1 (means an interrupt is assert):
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear the interrupt and MCU_IRQ[n].
N     */
N
N    __I  uint32_t IRQSRC[32];   /* Offset: 0x00-0x7C  IRQn(n=0~31) Interrupt Source Identity Register               */
X    volatile const  uint32_t IRQSRC[32];    
N    __IO uint32_t NMISEL;       /* Offset: 0x80  NMI Interrupt Source Select Control Register                       */
X    volatile uint32_t NMISEL;        
N    __IO uint32_t MCUIRQ;       /* Offset: 0x84  MCU Interrupt Request Source Register                              */
X    volatile uint32_t MCUIRQ;        
N    
N} GCR_INT_T;
N
N
N
N/* INT IRQSRC Bit Field Definitions */
N#define INT_IRQSRC_INT_SRC_Pos                  0                                   /*!< GCR_INT_T::IRQSRC: INT_SRC Position */
N#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)
N
N/* INT NMI_SEL Bit Field Definitions */
N#define INT_NMI_SEL_NMI_EN_Pos                  8                                   /*!< GCR_INT_T::NMISEL: NMI_EN Position */
N#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)     /*!< GCR_INT_T::NMISEL: NMI_EN Mask */
N
N#define INT_NMI_SEL_NMI_SEL_Pos                 0                                   /*!< GCR_INT_T::NMISEL: NMI_SEL Position */
N#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos) /*!< GCR_INT_T::NMISEL: NMI_SEL Mask */
N/*@}*/ /* end of group SYS_CONST */
N/*@}*/ /* end of group SYS */
N
N
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller (TIMER)
N    Memory Mapped Structure for TMR Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var TIMER_T::TCSR
N * Offset: 0x00  Timer Control and Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PRESCALE  |Prescale Counter
N * |        |          |Timer input clock source is divided by (PRESCALE+1) before it is fed to the Timer up
N * |        |          |counter.
N * |        |          |If this field is 0 (PRESCALE = 0), then there is no scaling.
N * |[16]    |TDR_EN    |Data Load Enable Control
N * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit
N * |        |          |up-timer value as the timer is counting.
N * |        |          |0 = Timer Data Register update Disabled.
N * |        |          |1 = Timer Data Register update Enabled while Timer counter is active.
N * |[23]    |WAKE_EN   |Wake Up Function Enable Control
N * |        |          |0 = Wake-up trigger event Disabled.
N * |        |          |1 = Wake-up trigger event Enabled.
N * |[24]    |CTB       |Counter Mode Enable Control
N * |        |          |This bit is for external counting pin function enabled.
N * |        |          |When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer
N * |        |          |clock source.
N * |        |          |Please refer to 5.17.5.6 for detail description.
N * |        |          |0 = External counter mode Disabled.
N * |        |          |1 = External counter mode Enabled.
N * |[25]    |CACT      |Timer Active Status (Read Only)
N * |        |          |This bit indicates the 24-bit up counter status.
N * |        |          |0 = 24-bit up counter is not active.
N * |        |          |1 = 24-bit up counter is active.
N * |[26]    |CRST      |Timer Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1.
N * |[28:27] |MODE      |Timer Operating Mode
N * |        |          |00 = The Timer controller is operated in One-shot mode.
N * |        |          |01 = The Timer controller is operated in Periodic mode.
N * |        |          |10 = The Timer controller is operated in Toggle-output mode.
N * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
N * |[29]    |IE        |Interrupt Enable Control
N * |        |          |0 = Timer Interrupt function Disabled.
N * |        |          |1 = Timer Interrupt function Enabled.
N * |        |          |If this bit is enabled, when the timer interrupt flag (TISR[0] TIF) is set to 1, the timer
N * |        |          |interrupt signal is generated and inform to CPU.
N * |[30]    |CEN       |Timer Enable Control
N * |        |          |0 = Stops/Suspends counting.
N * |        |          |1 = Starts counting.
N * |        |          |Note1: In stop status, and then set CEN to 1 will enable the 24-bit up counter to keep
N * |        |          |counting from the last stop counting value.
N * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TCSR [28:27] = 00) when the
N * |        |          |timer interrupt flag (TISR[0] TIF) is generated.
N * |[31]    |DBGACK_TMR|ICE Debug Mode Acknowledge Disable (Write Protect)
N * |        |          |0 = ICE debug mode acknowledgment effects TIMER counting.
N * |        |          |TIMER counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgment Disabled.
N * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
N * @var TIMER_T::TCMPR
N * Offset: 0x04  Timer Compare Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TCMP      |Timer Compared Value
N * |        |          |TCMP is a 24-bit compared value register.
N * |        |          |When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to
N * |        |          |1.
N * |        |          |Time-out period = (Period of Timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP).
N * |        |          |Note1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.
N * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep
N * |        |          |counting continuously even if user writes a new value into TCMP field.
N * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting and
N * |        |          |using newest TCMP value to be the timer compared value if user writes a new value into TCMP
N * |        |          |field.
N * @var TIMER_T::TISR
N * Offset: 0x08  Timer Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Timer Interrupt Flag
N * |        |          |This bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.
N * |        |          |0 = No effect.
N * |        |          |1 = TDR value matches the TCMP value.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[1]     |TWF       |Timer Wake-Up Flag
N * |        |          |This bit indicates the interrupt wake-up flag status of Timer.
N * |        |          |0 = Timer does not cause CPU wake-up.
N * |        |          |1 = CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var TIMER_T::TDR
N * Offset: 0x0C  Timer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TDR       |Timer Data Register
N * |        |          |If TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor
N * |        |          |24-bit up counter value.
N * @var TIMER_T::TCAP
N * Offset: 0x10  Timer Capture Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TCAP      |Timer Capture Data Register
N * |        |          |When TEXIF flag is set to 1, the current TDR value will be auto-loaded into this TCAP filed
N * |        |          |immediately.
N * @var TIMER_T::TEXCON
N * Offset: 0x14  Timer External Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_PHASE  |Timer External Count Pin Phase Detect Selection
N * |        |          |This bit indicates the detection phase of TMx pin.
N * |        |          |0 = A falling edge of TMx pin will be counted.
N * |        |          |1 = A rising edge of TMx pin will be counted.
N * |[2:1]   |TEX_EDGE  |Timer External Capture Pin Edge Detect Selection
N * |        |          |00 = A 1 to 0 transition on TMx_EXT pin will be detected.
N * |        |          |01 = A 0 to 1 transition on TMx_EXT pin will be detected.
N * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected.
N * |        |          |11 = Reserved.
N * |[3]     |TEXEN     |Timer External Pin Function Enable
N * |        |          |This bit enables the RSTCAPSEL function on the TxEX pin.
N * |        |          |0 = RSTCAPSEL function of TxEX pin will be ignored.
N * |        |          |1 = RSTCAPSEL function of TxEX pin is active.
N * |[4]     |RSTCAPSEL |Timer External Reset Counter / Timer External Capture Mode Selection
N * |        |          |0 = Transition on TMx_EXT
N * |        |          |pin is using to save the TDR value into TCAP value if TEXIF flag is set to 1.
N * |        |          |1 = Transition on TMx_EXT pin is using to reset the 24-bit up counter.
N * |[5]     |TEXIEN    |Timer External Capture Interrupt Enable Control
N * |        |          |0 = TMx_EXT pin detection Interrupt Disabled.
N * |        |          |1 = TMx_EXT pin detection Interrupt Enabled.
N * |        |          |If TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU
N * |        |          |while TEXIF flag is set to 1.
N * |[6]     |TEXDB     |Timer External Capture Input Pin De-Bounce Enable Control
N * |        |          |0 = TMx_EXT pin de-bounce Disabled.
N * |        |          |1 = TMx_EXT pin de-bounce Enabled.
N * |        |          |If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce
N * |        |          |circuit.
N * |[7]     |TCDB      |Timer External Counter Input Pin De-Bounce Enable Control
N * |        |          |0 = TMx pin de-bounce Disabled.
N * |        |          |1 = TMx pin de-bounce Enabled.
N * |        |          |If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
N * @var TIMER_T::TEXISR
N * Offset: 0x18  Timer External Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TEXIF     |Timer External Capture Interrupt Flag
N * |        |          |This bit indicates the external capture interrupt flag status.
N * |        |          |When TEXEN enabled, TMx_EXT pin selected as external capture function, and a transition on
N * |        |          |TMx_EXT pin matched the TEX_EDGE setting, this flag will set to 1 by hardware.
N * |        |          |1 = TMx_EXT
N * |        |          |pin interrupt occurred.
N * |        |          |0 = TMx_EXT
N * |        |          |pin interrupt did not occur.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N */
N
N    __IO uint32_t TCSR;          /* Offset: 0x00  Timer Control and Status Register                                  */
X    volatile uint32_t TCSR;           
N    __IO uint32_t TCMPR;         /* Offset: 0x04  Timer Compare Register                                             */
X    volatile uint32_t TCMPR;          
N    __IO uint32_t TISR;          /* Offset: 0x08  Timer Interrupt Status Register                                    */
X    volatile uint32_t TISR;           
N    __I  uint32_t TDR;           /* Offset: 0x0C  Timer Data Register                                                */
X    volatile const  uint32_t TDR;            
N    __I  uint32_t TCAP;          /* Offset: 0x10  Timer Capture Data Register                                        */
X    volatile const  uint32_t TCAP;           
N    __IO uint32_t TEXCON;        /* Offset: 0x14  Timer External Control Register                                    */
X    volatile uint32_t TEXCON;         
N    __IO uint32_t TEXISR;        /* Offset: 0x18  Timer External Interrupt Status Register                           */
X    volatile uint32_t TEXISR;         
N
N} TIMER_T;
N
N
N
N/**
N    @addtogroup TIMER_CONST TMR Bit Field Definition
N    Constant Definitions for TMR Controller
N@{ */
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
N
N#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
N
N#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
N
N#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
N
N#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
N
N#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
N
N#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
N
N#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
N
N#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
N
N#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
N
N#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
N
N#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
N/*@}*/ /* end of group TIMER_CONST */
N/*@}*/ /* end of group TIMER */
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller (UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var UART_T::DATA
N * Offset: 0x00  UART Transmit Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |          |Transmit Holding Register
N * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB first).
N * @var UART_T::THR
N * Offset: 0x00  UART Transmit Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |          |Transmit Holding Register
N * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB first).
N * @var UART_T::RBR
N * Offset: 0x00  UART Receive Buffer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
N * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB first).
N * @var UART_T::IER
N * Offset: 0x04  UART Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable Control
N * |        |          |0 = RDA_INT Masked off.
N * |        |          |1 = RDA_INT Enabled.
N * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable Control
N * |        |          |0 = THRE_INT Masked off.
N * |        |          |1 = THRE_INT Enabled.
N * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable Control
N * |        |          |0 = RLS_INT Masked off.
N * |        |          |1 = RLS_INT Enabled
N * |[3]     |MODEM_IEN |Modem Status Interrupt Enable Control (Not Available In UART2 Channel)
N * |        |          |0 = MODEM_INT Masked off.
N * |        |          |1 = MODEM_INT Enabled.
N * |[4]     |TOUT_IEN  |RX Time-Out Interrupt Enable Control
N * |        |          |0 = TOUT_INT Masked off.
N * |        |          |1 = TOUT_INT Enabled.
N * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable Control
N * |        |          |0 = BUF_ERR_INT Masked off.
N * |        |          |1 = BUF_ERR_INT Enabled.
N * |[6]     |WAKE_EN   |UART Wake-Up Function Enable (Not Available In UART2 Channel)
N * |        |          |0 = UART wake-up function Disabled.
N * |        |          |1 = UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS
N * |        |          |change will wake-up chip from Power-down mode.
N * |[8]     |LIN_IEN   |LIN Bus Interrupt Enable
N * |        |          |0 = Lin bus interrupt Disabled.
N * |        |          |1 = Lin bus interrupt Enabled.
N * |        |          |Note: This field is used for LIN function mode.
N * |[11]    |TIME_OUT_EN|Time-Out Counter Enable
N * |        |          |0 = Time-out counter Disabled.
N * |        |          |1 = Time-out counter Enabled.
N * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable (Not Available In UART2 Channel)
N * |        |          |0 = RTS auto flow control Disabled.
N * |        |          |1 = RTS auto flow control Enabled.
N * |        |          |When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV
N * |        |          |(UA_FCR [19:16]), the UART will de-assert RTS signal.
N * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable (Not Available In UART2 Channel)
N * |        |          |0 = CTS auto flow control Disabled.
N * |        |          |1 = CTS auto flow control Enabled.
N * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input
N * |        |          |assert (UART will not send data to device until CTS is asserted).
N * |[14]    |DMA_TX_EN |TX DMA Enable (Not Available In UART2 Channel)
N * |        |          |This bit can enable or disable TX DMA service.
N * |        |          |0 = TX DMA Disabled.
N * |        |          |1 = TX DMA Enabled.
N * |[15]    |DMA_RX_EN |RX DMA Enable (Not Available In UART2 Channel)
N * |        |          |This bit can enable or disable RX DMA service.
N * |        |          |0 = RX DMA Disabled.
N * |        |          |1 = RX DMA Enabled.
N * @var UART_T::FCR
N * Offset: 0x08  UART FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RFR       |RX Field Software Reset
N * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are
N * |        |          |cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the RX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[2]     |TFR       |TX Field Software Reset
N * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are
N * |        |          |cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[7:4]   |RFITL     |RX FIFO Interrupt (INT_RDA) Trigger Level
N * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if
N * |        |          |UA_IER [RDA_IEN] enabled, and an interrupt will be generated).
N * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N * |        |          |0100 = RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed).
N * |        |          |0101 = RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed).
N * |        |          |0110 = RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed).
N * |        |          |Other = Reserved.
N * |[8]     |RX_DIS    |Receiver Disable Register
N * |        |          |The receiver is disabled or not (set 1 to disable receiver)
N * |        |          |0 = Receiver Enabled.
N * |        |          |1 = Receiver Disabled.
N * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode.
N * |        |          |It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.
N * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)
N * |        |          |0000 = RTS Trigger Level is 1 byte.
N * |        |          |0001 = RTS Trigger Level is 4 bytes.
N * |        |          |0010 = RTS Trigger Level is 8 bytes.
N * |        |          |0011 = RTS Trigger Level is 14 bytes.
N * |        |          |0100 = RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed).
N * |        |          |0101 = RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed).
N * |        |          |0110 = RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed).
N * |        |          |Other = Reserved.
N * |        |          |Note: This field is used for RTS auto-flow control.
N * @var UART_T::LCR
N * Offset: 0x0C  UART Line Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WLS       |Word Length Selection
N * |        |          |00 = Word length is 5-bit.
N * |        |          |01 = Word length is 6-bit.
N * |        |          |10 = Word length is 7-bit
N * |        |          |11 = Word length is 8-bit
N * |[2]     |NSB       |Number Of "STOP Bit"
N * |        |          |0 = One " STOP bit" is generated in the transmitted data.
N * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
N * |        |          |When select 6-,7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
N * |[3]     |PBE       |Parity Bit Enable
N * |        |          |0 = No parity bit.
N * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
N * |[4]     |EPE       |Even Parity Enable
N * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N * |        |          |This bit has effect only when PBE (UA_LCR[3]) is set.
N * |[5]     |SPE       |Stick Parity Enable
N * |        |          |0 = Stick parity Disabled.
N * |        |          |1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and
N * |        |          |checked as logic 0.
N * |        |          |If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and
N * |        |          |checked as 1.
N * |[6]     |BCB       |Break Control Bit
N * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State
N * |        |          |(logic 0).
N * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
N * @var UART_T::MCR
N * Offset: 0x10  UART Modem Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RTS       |RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)
N * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin
N * |        |          |output with LEV_RTS bit configuration.
N * |        |          |0 = RTS signal is active.
N * |        |          |1 = RTS signal is inactive.
N * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in
N * |        |          |UART function mode.
N * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is
N * |        |          |enabled in RS-485 function mode.
N * |[9]     |LEV_RTS   |RTS Pin Active Level (Not Available In UART2 Channel)
N * |        |          |This bit defines the active level state of RTS pin output.
N * |        |          |0 = RTS pin output is high level active.
N * |        |          |1 = RTS pin output is low level active.
N * |[13]    |RTS_ST    |RTS Pin State (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit mirror from RTS pin output of voltage logic status.
N * |        |          |0 = RTS pin output is low level voltage logic state.
N * |        |          |1 = RTS pin output is high level voltage logic state.
N * @var UART_T::MSR
N * Offset: 0x14  UART Modem Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DCTSF     |Detect CTS State Change Flag (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to
N * |        |          |CPU when MODEM_IEN (UA_IER [3]) is set to 1.
N * |        |          |0 = CTS input has not change state.
N * |        |          |1 = CTS input has change state.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[4]     |CTS_ST    |CTS Pin Status (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit mirror from CTS pin input of voltage logic status.
N * |        |          |0 = CTS pin input is low level voltage logic state.
N * |        |          |1 = CTS pin input is high level voltage logic state.
N * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS
N * |        |          |multi-function port is selected
N * |[8]     |LEV_CTS   |CTS Pin Active Level
N * |        |          |This bit defines the active level state of CTS pin input.
N * |        |          |0 = CTS pin input is high level active.
N * |        |          |1 = CTS pin input is low level active.
N * @var UART_T::FSR
N * Offset: 0x18  UART FIFO Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_OVER_IF|RX Overflow Error IF (Read Only)
N * |        |          |This bit is set when RX FIFO overflow.
N * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16
N * |        |          |bytes of UART0/UART1/UART2, this bit will be set.
N * |        |          |0 = RX FIFO is not overflow.
N * |        |          |1 = RX FIFO is overflow.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag (Read Only)
N * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='1').
N * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
N * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set
N * |        |          |to 1 to enable Address detection mode.
N * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N * |[4]     |PEF       |Parity Error Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", 
N * |        |          |and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No parity error is generated.
N * |        |          |1 = Parity error is generated.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[5]     |FEF       |Framing Error Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit"
N * |        |          |(that is, the stop bit following the last data bit or parity bit is detected as logic 0),
N * |        |          |and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No framing error is generated.
N * |        |          |1 = Framing error is generated.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[6]     |BIF       |Break Interrupt Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" 
N * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of
N * |        |          |"start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this
N * |        |          |bit.
N * |        |          |0 = No Break interrupt is generated.
N * |        |          |1 = Break interrupt is generated.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[13:8]  |RX_POINTER|RX FIFO Pointer (Read Only)
N * |        |          |This field indicates the RX FIFO Buffer Pointer.
N * |        |          |When UART receives one byte from external device, then RX_POINTER increases one.
N * |        |          |When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.
N * |        |          |The Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2).
N * |        |          |When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and
N * |        |          |RX_POINTER will show 0.
N * |        |          |As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will
N * |        |          |show 63/15/15 (UART0/UART1/UART2).
N * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
N * |        |          |This bit initiate RX FIFO empty or not.
N * |        |          |0 = RX FIFO is not empty.
N * |        |          |1 = RX FIFO is empty.
N * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
N * |        |          |It will be cleared when UART receives any new data.
N * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
N * |        |          |This bit initiates RX FIFO is full or not.
N * |        |          |0 = RX FIFO is not full.
N * |        |          |1 = RX FIFO is full.
N * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to
N * |        |          |64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.
N * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)
N * |        |          |This field indicates the TX FIFO Buffer Pointer.
N * |        |          |When CPU writes one byte into UA_THR, then TX_POINTER increases one.
N * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER
N * |        |          |decreases one.
N * |        |          |The Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2).
N * |        |          |When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and
N * |        |          |TX_POINTER will show 0.
N * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is
N * |        |          |cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).
N * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
N * |        |          |This bit indicates TX FIFO empty or not.
N * |        |          |0 = TX FIFO is not empty.
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register,
N * |        |          |hardware sets this bit high.
N * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
N * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
N * |        |          |This bit indicates TX FIFO full or not.
N * |        |          |0 = TX FIFO is not full.
N * |        |          |1 = TX FIFO is full.
N * |        |          |This bit is set when the number of usage in TX FIFO Buffer is equal to
N * |        |          |64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.
N * |[24]    |TX_OVER_IF|TX Overflow Error Interrupt Flag (Read Only)
N * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to
N * |        |          |logic 1.
N * |        |          |0 = TX FIFO is not overflow.
N * |        |          |1 = TX FIFO is overflow.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
N * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte
N * |        |          |has been transmitted.
N * |        |          |0 = TX FIFO is not empty.
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte
N * |        |          |transmission has not completed.
N * @var UART_T::ISR
N * Offset: 0x1C  UART Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
N * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be
N * |        |          |set.
N * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
N * |        |          |0 = No RDA interrupt flag is generated.
N * |        |          |1 = RDA interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX
N * |        |          |FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).
N * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
N * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
N * |        |          |0 = No THRE interrupt flag is generated.
N * |        |          |1 = THRE interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not
N * |        |          |empty).
N * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at
N * |        |          |least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
N * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated.
N * |        |          |1 = RLS interrupt flag is generated.
N * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received
N * |        |          |address byte character (bit9 = '1') bit.
N * |        |          |At the same time, the bit of UA_FSR[RS485_ADD_DETF] is also set.
N * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5])
N * |        |          |and PEF(UA_FSR[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of
N * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are
N * |        |          |cleared.
N * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
N * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated.
N * |        |          |1 = Modem interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on
N * |        |          |DCTSF(UA_MSR[0]).
N * |[4]     |TOUT_IF   |Time-Out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and
N * |        |          |the time-out counter equal to TOIC.
N * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated.
N * |        |          |1 = Time-out interrupt flag is generated.
N * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it
N * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF
N * |        |          |(UA_FSR[0]) is set).
N * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
N * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is
N * |        |          |generated.
N * |        |          |1 = Buffer error interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and
N * |        |          |RX_OVER_IF(UA_FSR[0]) are cleared
N * |[7]     |LIN_IF    |LIN Bus Flag (Read Only)
N * |        |          |This bit is set when LIN slave header detect (LINS_HDET_F (UA_LIN_SR[0] =1)), LIN break
N * |        |          |detect (LIN_BKDET_F(UA_LIN_SR[9]=1)), bit error detect (BIT_ERR_F(UA_LIN_SR[9]=1), LIN slave
N * |        |          |ID parity error (LINS_IDPERR_F(UA_LIN_SR[2] = 1) or LIN slave header error detect
N * |        |          |(LINS_HERR_F (UA_LIN_SR[1])).
N * |        |          |If LIN_ IEN (UA_IER [8]) is enabled the LIN interrupt will be generated.
N * |        |          |0 = None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
N * |        |          |1 = At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is
N * |        |          |generated.
N * |        |          |Note: This bit is read only.
N * |        |          |This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]),
N * |        |          |BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are
N * |        |          |cleared.
N * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
N * |        |          |0 = No RDA interrupt is generated.
N * |        |          |1 = RDA interrupt is generated.
N * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
N * |        |          |0 = No THRE interrupt is generated.
N * |        |          |1 = THRE interrupt is generated.
N * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated.
N * |        |          |1 = RLS interrupt is generated
N * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1
N * |        |          |0 = No Modem interrupt is generated.
N * |        |          |1 = Modem interrupt is generated.
N * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
N * |        |          |0 = No Tout interrupt is generated.
N * |        |          |1 = Tout interrupt is generated.
N * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated.
N * |        |          |1 = Buffer error interrupt is generated.
N * |[15]    |LIN_INT   |LIN Bus Interrupt Indicator (Read Only)
N * |        |          |This bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.
N * |        |          |0 = No LIN Bus interrupt is generated.
N * |        |          |1 = The LIN Bus interrupt is generated.
N * |[18]    |HW_RLS_IF |In DMA Mode, Receive Line Status Flag (Read Only)
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at
N * |        |          |least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set).
N * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated.
N * |        |          |1 = RLS interrupt flag is generated.
N * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received
N * |        |          |address byte character (bit9 = '1') bit.
N * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of
N * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of
N * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are
N * |        |          |cleared.
N * |[19]    |HW_MODEM_IF|In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set when the CTS pin has state change (DCTSF (US_MSR[0] =1)).
N * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated.
N * |        |          |1 = Modem interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by
N * |        |          |writing 1 on DCTSF (US_MSR[0]).
N * |[20]    |HW_TOUT_IF|In DMA Mode, Time-Out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and
N * |        |          |the time-out counter equal to TOIC (UA_TOR[7:0]).
N * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated.
N * |        |          |1 = Time-out interrupt flag is generated.
N * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
N * |[21]    |HW_BUF_ERR_IF|In DMA Mode, Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF
N * |        |          |(UA_FSR[0]) is set).
N * |        |          |When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct.
N * |        |          |If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.
N * |        |          |Note: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are
N * |        |          |cleared.
N * |[26]    |HW_RLS_INT|In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated in DMA mode.
N * |        |          |1 = RLS interrupt is generated in DMA mode.
N * |[27]    |HW_MODEM_INT|In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.
N * |        |          |0 = No Modem interrupt is generated in DMA mode.
N * |        |          |1 = Modem interrupt is generated in DMA mode.
N * |[28]    |HW_TOUT_INT|In DMA Mode, Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.
N * |        |          |0 = No Tout interrupt is generated in DMA mode.
N * |        |          |1 = Tout interrupt is generated in DMA mode.
N * |[29]    |HW_BUF_ERR_INT|In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated in DMA mode.
N * |        |          |1 = Buffer error interrupt is generated in DMA mode.
N * @var UART_T::TOR
N * Offset: 0x20  UART Time-out Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
N * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever
N * |        |          |the RX FIFO receives a new data word.
N * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC
N * |        |          |(UA_TOR[7:0])), a receiver time-out interrupt (INT_TOUT) is generated if TOUT_IEN (UA_IER
N * |        |          |[4]) enabled.
N * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_INT(UA_IER[9]).
N * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is
N * |        |          |being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
N * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated
N * |        |          |after four characters are not received when 1 stop bit and no parity check is set for UART
N * |        |          |transfer.
N * |[15:8]  |DLY       |TX Delay Time Value
N * |        |          |This field is used to programming the transfer delay time between the last stop bit and next
N * |        |          |start bit.
N * @var UART_T::BAUD
N * Offset: 0x24  UART Baud Rate Divisor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |BRD       |Baud Rate Divider
N * |        |          |The field indicates the baud rate divider
N * |[27:24] |DIVIDER_X |Divider X
N * |        |          |The baud rate divider M = X+1.
N * |[28]    |DIV_X_ONE |Divider X Equal To 1
N * |        |          |0 = Divider M = X
N * |        |          |1 = Divider M = 1
N * |[29]    |DIV_X_EN  |Divider X Enable
N * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
N * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
N * |        |          |0 = Divider X Disabled (the equation of M = 16).
N * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
N * |        |          |Refer to Table 5-21 for more information.
N * |        |          |Note: In IrDA mode, this bit must disable.
N * @var UART_T::IRCR
N * Offset: 0x28  UART IrDA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TX_SELECT |TX_SELECT
N * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
N * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
N * |        |          |0 = None inverse transmitting signal.
N * |        |          |1 = Inverse transmitting output signal.
N * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
N * |        |          |0 = None inverse receiving input signal.
N * |        |          |1 = Inverse receiving input signal.
N * @var UART_T::ALT_CSR
N * Offset: 0x2C  UART Alternate Control/Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: This break field length is UA_LIN_BKFL + 1
N * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
N * |[6]     |LIN_RX_EN |LIN RX Enable
N * |        |          |0 = LIN RX mode Disabled.
N * |        |          |1 = LIN RX mode Enabled.
N * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable
N * |        |          |0 = LIN TX Break mode Disabled.
N * |        |          |1 = LIN TX Break mode Enabled.
N * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared
N * |        |          |automatically.
N * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM)
N * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
N * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
N * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
N * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD)
N * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
N * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
N * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable
N * |        |          |This bit is used to enable RS-485 Address Detection mode.
N * |        |          |0 = Address detection mode Disabled.
N * |        |          |1 = Address detection mode Enabled.
N * |        |          |Note: This bit is used for RS-485 any operation mode.
N * |[31:24] |ADDR_MATCH|Address Match Value Register
N * |        |          |This field contains the RS-485 address match values.
N * |        |          |Note: This field is used for RS-485 auto address detection mode.
N * @var UART_T::FUN_SEL
N * Offset: 0x30  UART Function Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |FUN_SEL   |Function Select Enable
N * |        |          |00 = UART function Enabled.
N * |        |          |01 = LIN function Enabled.
N * |        |          |10 = IrDA function Enabled.
N * |        |          |11 = RS-485 function Enabled.
N * @var UART_T::LIN_CTL
N * Offset: 0x34  UART LIN Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LINS_EN   |LIN Slave Mode Enable Control
N * |        |          |0 = LIN slave mode Disabled.
N * |        |          |1 = LIN slave mode Enabled.
N * |[1]     |LINS_HDET_EN|LIN Slave Header Detection Enable Control
N * |        |          |0 = LIN slave header detection Disabled.
N * |        |          |1 = LIN slave header detection Enabled.
N * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), LINS_HDET_F
N * |        |          |(UA_LIN_SR [0]) flag will be asserted.
N * |        |          |If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N * |[2]     |LINS_ARS_EN|LIN Slave Automatic Resynchronization Mode Enable Control
N * |        |          |0 = LIN automatic resynchronization Disabled.
N * |        |          |1 = LIN automatic resynchronization Enabled.
N * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be
N * |        |          |mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).
N * |        |          |(Slave mode with automatic resynchronization).
N * |[3]     |LINS_DUM_EN|LIN Slave Divider Update Method Enable Control
N * |        |          |0 = UA_BAUD updated is written by software (if no automatic resynchronization update occurs
N * |        |          |at the same time).
N * |        |          |1 = UA_BAUD is updated at the next received character. User must set the bit before checksum
N * |        |          |reception.
N * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
N * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
N * |        |          |(Slave mode with automatic resynchronization).
N * |[4]     |LIN_MUTE_EN|LIN Mute Mode Enable Control
N * |        |          |0 = LIN mute mode Disabled.
N * |        |          |1 = LIN mute mode Enabled.
N * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are
N * |        |          |explained in (LIN slave mode).
N * |[8]     |LIN_SHD   |LIN TX Send Header Enable Control
N * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", 
N * |        |          |it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).
N * |        |          |0 = Send LIN TX header Disabled.
N * |        |          |1 = Send LIN TX header Enabled.
N * |        |          |Note1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write
N * |        |          |it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).
N * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" 
N * |        |          |selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished,
N * |        |          |this bit will be cleared automatically.
N * |[9]     |LIN_IDPEN |LIN ID Parity Enable Control
N * |        |          |0 = LIN frame ID parity Disabled.
N * |        |          |1 = LIN frame ID parity Enabled.
N * |        |          |Note1: This bit can be used for LIN master to sending header field (LIN_SHD (UA_LIN_CTL[8]))
N * |        |          |= 1 and LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10) or be used for enable LIN slave received
N * |        |          |frame ID parity checked.
N * |        |          |Note2: This bit is only use when the operation header transmitter is in LIN_HEAD_SEL
N * |        |          |(UA_LIN_CTL[23:22]) = 10
N * |[10]    |LIN_BKDET_EN|LIN Break Detection Enable Control
N * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter
N * |        |          |character, the LIN_BKDET_F (UA_LIN_SR[8]) flag is set in UA_LIN_SR register at the end of
N * |        |          |break field.
N * |        |          |If the LIN_IEN (UA_IER [8])=1, an interrupt will be generated.
N * |        |          |0 = LIN break detection Disabled.
N * |        |          |1 = LIN break detection Enabled.
N * |[11]    |LIN_RX_DIS|LIN Receiver Disable Control
N * |        |          |If the receiver is enabled (LIN_RX_DIS (UA_LIN_CTL[11] ) = 0), all received byte data will
N * |        |          |be accepted and stored in the RX-FIFO, and if the receiver is disabled (LIN_RX_DIS
N * |        |          |(UA_LIN_CTL[11] = 1), all received byte data will be ignore.
N * |        |          |0 = LIN receiver Enabled.
N * |        |          |1 = LIN receiver Disabled.
N * |        |          |Note: This bit is only valid when operating in LIN function mode (FUN_SEL (UA_FUN_SEL[1:0])
N * |        |          |= 01)
N * |[12]    |BIT_ERR_EN|Bit Error Detect Enable Control
N * |        |          |0 = Bit error detection function Disabled.
N * |        |          |1 = Bit error detection Enabled.
N * |        |          |Note: In LIN function mode, when occur bit error, the BIT_ERR_F (UA_LIN_SR[9]) flag will be
N * |        |          |asserted.
N * |        |          |If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N * |[19:16] |LIN_BKFL  |LIN Break Field Length
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting
N * |        |          |LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].
N * |        |          |Note2: This break field length is LIN_BKFL + 1.
N * |        |          |Note3:
N * |        |          |According to LIN spec, the reset value is 12 (break field length = 13).
N * |[21:20] |LIN_BS_LEN|LIN Break/Sync Delimiter Length
N * |        |          |00 = The LIN break/sync delimiter length is 1 bit time.
N * |        |          |10 = The LIN break/sync delimiter length is 2 bit time.
N * |        |          |10 = The LIN break/sync delimiter length is 3 bit time.
N * |        |          |11 = The LIN break/sync delimiter length is 4 bit time.
N * |        |          |Note: This bit used for LIN master to sending header field.
N * |[23:22] |LIN_HEAD_SEL|LIN Header Select
N * |        |          |00 = The LIN header includes "break field".
N * |        |          |01 = The LIN header includes "break field" and "sync field".
N * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
N * |        |          |11 = Reserved.
N * |        |          |Note: This bit is used to master mode for LIN to send header field (LIN_SHD (UA_LIN_CTL [8])
N * |        |          |= 1) or used to slave to indicates exit from mute mode condition (LIN_MUTE_EN (UA_LIN_CTL[4]
N * |        |          |= 1).
N * |[31:24] |LIN_PID   |LIN PID Register
N * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity
N * |        |          |can be generated by software or hardware depends on LIN_IDPEN (UA_LIN_CTL[9]) = 1.
N * |        |          |If the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will
N * |        |          |calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and
N * |        |          |parity in this field.
N * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
N * |        |          |Note2: This field can be used for LIN master mode or slave mode.
N * @var UART_T::LIN_SR
N * Offset: 0x38  UART LIN Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LINS_HDET_F|LIN Slave Header Detection Flag (Read Only)
N * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared
N * |        |          |by writing 1 to it.
N * |        |          |0 = LIN header not detected.
N * |        |          |1 = LIN header detected (break + sync + frame ID).
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and
N * |        |          |enable LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
N * |        |          |Note3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete
N * |        |          |header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct
N * |        |          |or not.
N * |[1]     |LINS_HERR_F|LIN Slave Header Error Flag (Read Only)
N * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be
N * |        |          |cleared by writing 1 to it.
N * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", 
N * |        |          |"sync field data is not 0x55 in Non-Automatic Resynchronization mode", 
N * |        |          |"sync field deviation error with Automatic Resynchronization mode",
N * |        |          |"sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
N * |        |          |0 = LIN header error not detected.
N * |        |          |1 = LIN header error detected.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (LINS_EN (UA_LIN_CTL
N * |        |          |[0]) = 1) and enables LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
N * |[2]     |LINS_IDPERR_F|LIN Slave ID Parity Error Flag (Read Only)
N * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
N * |        |          |0 = No active.
N * |        |          |1 = Receipted frame ID parity is not correct.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0])= 1) and
N * |        |          |enable LIN frame ID parity check function LIN_IDPEN (UA_LIN_CTL [9]).
N * |[3]     |LINS_SYNC_F|LIN Slave Sync Field
N * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization
N * |        |          |mode.
N * |        |          |When the receiver header have some error been detect, user must reset the internal circuit
N * |        |          |to re-search new frame header by writing 1 to this bit.
N * |        |          |0 = The current character is not at LIN sync state.
N * |        |          |1 = The current character is at LIN sync state.
N * |        |          |Note1: This bit is only valid when in LIN Slave mode (LINS_EN(UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new
N * |        |          |frame header.
N * |[8]     |LIN_BKDET_F|LIN Break Detection Flag (Read Only)
N * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it
N * |        |          |through software.
N * |        |          |0 = LIN break not detected.
N * |        |          |1 = LIN break detected.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (LIN_BKDET_EN
N * |        |          |(UA_LIN_CTL[10]) =1).
N * |[9]     |BIT_ERR_F |Bit Error Detect Status Flag (Read Only)
N * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state
N * |        |          |not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.
N * |        |          |When occur bit error, if the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when enable bit error detection function (BIT_ERR_EN
N * |        |          |(UA_LIN_CTL [12]) = 1).
N */
N
N    union
N    {
N        __IO uint32_t DATA;          /* Offset: 0x00  UART Data Register                                                 */
X        volatile uint32_t DATA;           
N        __IO uint32_t THR;           /* Offset: 0x00  UART Transmit Holding Register                                     */
X        volatile uint32_t THR;            
N        __IO uint32_t RBR;           /* Offset: 0x00  UART Receive Buffer Register                                       */
X        volatile uint32_t RBR;            
N    };
N    __IO uint32_t IER;           /* Offset: 0x04  UART Interrupt Enable Register                                     */
X    volatile uint32_t IER;            
N    __IO uint32_t FCR;           /* Offset: 0x08  UART FIFO Control Register                                         */
X    volatile uint32_t FCR;            
N    __IO uint32_t LCR;           /* Offset: 0x0C  UART Line Control Register                                         */
X    volatile uint32_t LCR;            
N    __IO uint32_t MCR;           /* Offset: 0x10  UART Modem Control Register                                        */
X    volatile uint32_t MCR;            
N    __IO uint32_t MSR;           /* Offset: 0x14  UART Modem Status Register                                         */
X    volatile uint32_t MSR;            
N    __IO uint32_t FSR;           /* Offset: 0x18  UART FIFO Status Register                                          */
X    volatile uint32_t FSR;            
N    __IO uint32_t ISR;           /* Offset: 0x1C  UART Interrupt Status Register                                     */
X    volatile uint32_t ISR;            
N    __IO uint32_t TOR;           /* Offset: 0x20  UART Time-out Register                                             */
X    volatile uint32_t TOR;            
N    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
X    volatile uint32_t BAUD;           
N    __IO uint32_t IRCR;          /* Offset: 0x28  UART IrDA Control Register                                         */
X    volatile uint32_t IRCR;           
N    __IO uint32_t ALT_CSR;       /* Offset: 0x2C  UART Alternate Control/Status Register                             */
X    volatile uint32_t ALT_CSR;        
N    __IO uint32_t FUN_SEL;       /* Offset: 0x30  UART Function Select Register                                      */
X    volatile uint32_t FUN_SEL;        
N    __IO uint32_t LIN_CTL;       /* Offset: 0x34  UART LIN Control Register                                          */
X    volatile uint32_t LIN_CTL;        
N    __IO uint32_t LIN_SR;        /* Offset: 0x38  UART LIN Status Register                                           */
X    volatile uint32_t LIN_SR;         
N    
N
N} UART_T;
N
N
N
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0                                          /*!< UART_T::THR: THR Position  */
N#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART_T::THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0                                          /*!< UART_T::RBR: RBR Position  */
N#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART_T::RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_DMA_RX_EN_Pos      15                                      /*!< UART_T::IER: RX DMA Enable Position  */
N#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)         /*!< UART_T::IER: RX DMA Enable Mask      */
N
N#define UART_IER_DMA_TX_EN_Pos      14                                      /*!< UART_T::IER: TX DMA Enable Position  */
N#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)         /*!< UART_T::IER: TX DMA Enable Mask      */
N
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Position       */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
N 
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Position       */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Position       */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_LIN_IEN_Pos        8                                       /*!< UART_T::IER: LIN_IEN Position           */
N#define UART_IER_LIN_IEN_Msk        (1ul << UART_IER_LIN_IEN_Pos)           /*!< UART_T::IER: LIN_IEN Mask               */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART_T::IER: WAKE_EN Position           */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART_T::IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Position       */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_TOUT_IEN_Pos        4                                      /*!< UART_T::IER: TOUT_IEN Position           */
N#define UART_IER_TOUT_IEN_Msk        (1ul << UART_IER_TOUT_IEN_Pos)         /*!< UART_T::IER: TOUT_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Position         */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Position           */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Position          */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_HW_BUF_ERR_INT_Pos 29                                      /*!< UART_T::ISR: HW BUF_ERR_INT Position    */
N#define UART_ISR_HW_BUF_ERR_INT_Msk (1ul << UART_ISR_HW_BUF_ERR_INT_Pos)    /*!< UART_T::ISR: HW BUF_ERR_INT Mask        */
N
N#define UART_ISR_HW_TOUT_INT_Pos    28                                      /*!< UART_T::ISR: HW TOUT_INT Position       */
N#define UART_ISR_HW_TOUT_INT_Msk    (1ul << UART_ISR_HW_TOUT_INT_Pos)       /*!< UART_T::ISR: HW TOUT_INT Mask           */
N
N#define UART_ISR_HW_MODEM_INT_Pos   27                                      /*!< UART_T::ISR: HW MODEM_INT Position      */
N#define UART_ISR_HW_MODEM_INT_Msk   (1ul << UART_ISR_HW_MODEM_INT_Pos)      /*!< UART_T::ISR: HW MODEM_INT Mask          */
N
N#define UART_ISR_HW_RLS_INT_Pos     26                                      /*!< UART_T::ISR: HW RLS_INT Position        */
N#define UART_ISR_HW_RLS_INT_Msk     (1ul << UART_ISR_HW_RLS_INT_Pos)        /*!< UART_T::ISR: HW RLS_INT Position        */
N
N#define UART_ISR_HW_BUF_ERR_IF_Pos  21                                      /*!< UART_T::ISR: HW BUF_ERR_IF Position     */
N#define UART_ISR_HW_BUF_ERR_IF_Msk  (1ul << UART_ISR_HW_BUF_ERR_IF_Pos)     /*!< UART_T::ISR: HW BUF_ERR_IF Mask         */
N
N#define UART_ISR_HW_TOUT_IF_Pos     20                                      /*!< UART_T::ISR: HW TOUT_IF Position        */
N#define UART_ISR_HW_TOUT_IF_Msk     (1ul << UART_ISR_HW_TOUT_IFF_Pos)       /*!< UART_T::ISR: HW TOUT_IF Mask            */
N
N#define UART_ISR_HW_MODEM_IF_Pos    19                                      /*!< UART_T::ISR: HW MODEM_IF Position       */
N#define UART_ISR_HW_MODEM_IF_Msk    (1ul << UART_ISR_HW_MODEM_IF_Pos)       /*!< UART_T::ISR: HW MODEM_IF Mask           */
N
N#define UART_ISR_HW_RLS_IF_Pos      18                                      /*!< UART_T::ISR: HW RLS_IF Position         */
N#define UART_ISR_HW_RLS_IF_Msk      (1ul << UART_ISR_HW_RLS_IF_Pos)         /*!< UART_T::ISR: HW RLS_IF Mark             */
N
N#define UART_ISR_LIN_INT_Pos        15                                      /*!< UART_T::ISR: LIN_INT Position           */
N#define UART_ISR_LIN_INT_Msk        (1ul << UART_ISR_LIN_INT_Pos)           /*!< UART_T::ISR: LIN_INT Mask               */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_IF_Pos         7                                       /*!< UART_T::ISR: LIN RX_IF Position         */
N#define UART_ISR_LIN_IF_Msk         (1ul << UART_ISR_LIN_IF_Pos)            /*!< UART_T::ISR: LIN RX_IF Mask             */
N
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART_T::TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART_T::TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART_T::TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART_T::BAUD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART_T::BAUD: DIV_X_EN Mask             */
N                                                                                     
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART_T::BAUD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART_T::BAUD: DIV_X_ONE Mask            */
N                                                                                     
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART_T::BAUD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART_T::BAUD: DIVIDER_X Mask            */
N                                                                                     
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART_T::BAUD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART_T::BAUD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART_T::IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART_T::IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART_T::IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART_T::IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART_T::IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART_T::IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
N
N/* UART LIN_CTL Bit Field Definitions */
N#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART_T::LIN_CTL: LIN_PID Position       */
N#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART_T::LIN_CTL: LIN_PID Mask           */
N
N#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Position       */
N#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Mask           */
N
N#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART_T::LIN_CTL: LIN_BS_LEN Position       */
N#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART_T::LIN_CTL: LIN_BS_LEN Mask           */
N
N#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART_T::LIN_CTL: LIN_BKFL Position       */
N#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART_T::LIN_CTL: LIN_BKFL Mask           */
N
N#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART_T::LIN_CTL: BIT_ERR_EN Position       */
N#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART_T::LIN_CTL: BIT_ERR_EN Mask           */
N
N#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART_T::LIN_CTL: LIN_RX_DIS Position       */
N#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART_T::LIN_CTL: LIN_RX_DIS Mask           */
N
N#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART_T::LIN_CTL: LIN_BKDET_EN Position       */
N#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART_T::LIN_CTL: LIN_BKDET_EN Mask           */
N
N#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART_T::LIN_CTL: LIN_IDPEN Position       */
N#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART_T::LIN_CTL: LIN_IDPEN Mask           */
N
N#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART_T::LIN_CTL: LIN_SHD Position       */
N#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART_T::LIN_CTL: LIN_SHD Mask           */
N
N#define UART_LIN_CTL_LIN_MUTE_EN_Pos    4                                          /*!< UART_T::LIN_CTL: LIN_MUTE_EN Position       */
N#define UART_LIN_CTL_LIN_MUTE_EN_Msk    (1ul << UART_LIN_CTL_LIN_MUTE_EN_Pos)      /*!< UART_T::LIN_CTL: LIN_MUTE_EN Mask           */
N
N#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART_T::LIN_CTL: LINS_DUM_EN Position       */
N#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_DUM_EN Mask           */
N
N#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART_T::LIN_CTL: LINS_ARS_EN Position       */
N#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_ARS_EN Mask           */
N
N#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART_T::LIN_CTL: LINS_HDET_EN Position       */
N#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART_T::LIN_CTL: LINS_HDET_EN Mask           */
N
N#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART_T::LIN_CTL: LINS_EN Position       */
N#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART_T::LIN_CTL: LINS_EN Mask           */
N
N/* UART LIN_SR Bit Field Definitions */
N#define UART_LIN_SR_BIT_ERR_F_Pos       9                                           /*!< UART_T::LIN_SR: BIT_ERR_F Position         */
N#define UART_LIN_SR_BIT_ERR_F_Msk       (1ul << UART_LIN_SR_BIT_ERR_F_Pos)          /*!< UART_T::LIN_SR: BIT_ERR_F Mask             */
N
N#define UART_LIN_SR_LINS_BKDET_F_Pos    8                                           /*!< UART_T::LIN_SR: LINS_BKDET_F Position      */
N#define UART_LIN_SR_LINS_BKDET_F_Msk    (1ul << UART_LIN_SR_LINS_BKDET_F_Pos)       /*!< UART_T::LIN_SR: LINS_BKDET_F Mask          */
N
N#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART_T::LIN_SR: LINS_SYNC_F Position       */
N#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART_T::LIN_SR: LINS_SYNC_F Mask           */
N
N#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART_T::LIN_SR: LINS_IDPERR_F Position     */
N#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART_T::LIN_SR: LINS_IDPERR_F Mask         */
N
N#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART_T::LIN_SR: LINS_HERR_F Position       */
N#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART_T::LIN_SR: LINS_HERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART_T::LIN_SR: LINS_HDET_F Position       */
N#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART_T::LIN_SR: LINS_HDET_F Mask           */
N/*@}*/ /* end of group UART_CONST */
N/*@}*/ /* end of group UART */
N
N
N
N/*---------------------- Universal Serial Bus Device Controller -------------------------*/
N/**
N    @addtogroup USBD Universal Serial Bus Device Controller (USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var USBD_EP_T::BUFSEG
N * Offset: 0x20/0x30/0x40/0x50/0x60/0x70  Endpoint 0~5 Buffer Segmentation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
N * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting
N * |        |          |address The effective starting address of the endpoint is
N * |        |          |USB_SRAM address + { BUFSEG[8:3], 3'b000}
N * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
N * |        |          |Refer to the section 5.4.4.7 for the endpoint SRAM structure and its description.
N * @var USBD_EP_T::MXPLD
N * Offset: 0x24/0x34/0x44/0x54/0x64/0x74  Endpoint 0~5 Maximal Payload Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |MXPLD     |Maximal Payload
N * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length
N * |        |          |which is received from the host (OUT token).
N * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or
N * |        |          |received in OUT token.
N * |        |          |(1) When the register is written by CPU,
N * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and
N * |        |          |indicate the data buffer is ready.
N * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the
N * |        |          |value of MXPLD is the maximal data length comes from host.
N * |        |          |(2) When the register is read by CPU,
N * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
N * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
N * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after
N * |        |          |IN/OUT token arrived.
N * @var USBD_EP_T::CFG
N * Offset: 0x28/0x38/0x48/0x58/0x68/0x78  Endpoint 0~5 Configuration Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |EP_NUM    |Endpoint Number
N * |        |          |These bits are used to define the endpoint number of the current endpoint.
N * |[4]     |ISOCH     |Isochronous Endpoint
N * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
N * |        |          |0 = No Isochronous endpoint.
N * |        |          |1 = Isochronous endpoint.
N * |[6:5]   |STATE     |Endpoint STATE
N * |        |          |00 = Endpoint is Disabled.
N * |        |          |01 = Out endpoint.
N * |        |          |10 = IN endpoint.
N * |        |          |11 = Undefined.
N * |[7]     |DSQ_SYNC  |Data Sequence Synchronization
N * |        |          |0 = DATA0 PID.
N * |        |          |1 = DATA1 PID.
N * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction.
N * |        |          |Hardware will toggle automatically in IN token base on the bit.
N * |[9]     |CSTALL    |Clear STALL Response
N * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
N * |        |          |1 = Clear the device to response STALL handshake in setup stage.
N * @var USBD_EP_T::CFGP
N * Offset: 0x2C/0x3C/0x4C/0x5C/0x6C/0x7C  Endpoint 0~5 Set Stall and Clear In/Out Ready Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CLRRDY    |Clear Ready
N * |        |          |When the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit
N * |        |          |or receive data.
N * |        |          |If the user wants to turn off this transaction before the transaction start, users can set
N * |        |          |this bit to 1 to turn it off and it will be cleared to 0 automatically.
N * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
N * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
N * |        |          |This bit is write 1 only and is always 0 when it is read back.
N * |[1]     |SSTALL    |Set STALL
N * |        |          |0 = Disable the device to response STALL.
N * |        |          |1 = Set the device to respond STALL automatically.
N */
N
N    __IO uint32_t BUFSEG;        /* Offset: 0x20/0x30/0x40/0x50/0x60/0x70  Endpoint 0~5 Buffer Segmentation Register */
X    volatile uint32_t BUFSEG;         
N    __IO uint32_t MXPLD;         /* Offset: 0x24/0x34/0x44/0x54/0x64/0x74  Endpoint 0~5 Maximal Payload Register     */
X    volatile uint32_t MXPLD;          
N    __IO uint32_t CFG;           /* Offset: 0x28/0x38/0x48/0x58/0x68/0x78  Endpoint 0~5 Configuration Register       */
X    volatile uint32_t CFG;            
N    __IO uint32_t CFGP;          /* Offset: 0x2C/0x3C/0x4C/0x5C/0x6C/0x7C  Endpoint 0~5 Set Stall and Clear In/Out Ready Control Register */
X    volatile uint32_t CFGP;           
N
N} USBD_EP_T;
N
N
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var USBD_T::INTEN
N * Offset: 0x00  USB Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUS_IE    |Bus Event Interrupt Enable
N * |        |          |0 = BUS event interrupt Disabled.
N * |        |          |1 = BUS event interrupt Enabled.
N * |[1]     |USB_IE    |USB Event Interrupt Enable
N * |        |          |0 = USB event interrupt Disabled.
N * |        |          |1 = USB event interrupt Enabled.
N * |[2]     |FLDET_IE  |Floating Detection Interrupt Enable
N * |        |          |0 = Floating detection Interrupt Disabled.
N * |        |          |1 = Floating detection Interrupt Enabled.
N * |[3]     |WAKEUP_IE |USB Wake-Up Interrupt Enable
N * |        |          |0 = Wake-up Interrupt Disabled.
N * |        |          |1 = Wake-up Interrupt Enabled.
N * |[8]     |WAKEUP_EN |Wake-Up Function Enable
N * |        |          |0 = USB wake-up function Disabled.
N * |        |          |1 = USB wake-up function Enabled.
N * |[15]    |INNAK_EN  |Active NAK Function And Its Status In IN Token
N * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be
N * |        |          |    updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
N * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event
N * |        |          |    will be asserted, when the device responds NAK after receiving IN token.
N * @var USBD_T::INTSTS
N * Offset: 0x04  USB Interrupt Event Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUS_STS   |BUS Interrupt Status
N * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
N * |        |          |0 = No BUS event occurred.
N * |        |          |1 = Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred,
N * |        |          |cleared by write 1 to USB_INTSTS[0].
N * |[1]     |USB_STS   |USB Event Interrupt Status
N * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the
N * |        |          |bus.
N * |        |          |0 = No USB event occurred.
N * |        |          |1 = USB event occurred, check EPSTS0~7 to know which kind of USB event occurred.
N * |        |          |Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31]).
N * |[2]     |FLDET_STS |Floating Detection Interrupt Status
N * |        |          |0 = There is not attached/detached event in the USB.
N * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to
N * |        |          |USB_INTSTS[2].
N * |[3]     |WAKEUP_STS|Wake-Up Interrupt Status
N * |        |          |0 = No Wake-up event occurred.
N * |        |          |1 = Wake-up event occurred, cleared by write 1 to USB_INTSTS[3].
N * |[16]    |EPEVT0    |Endpoint 0's USB Event Status
N * |        |          |0 = No event occurred on endpoint 0.
N * |        |          |1 = USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event
N * |        |          |was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1].
N * |[17]    |EPEVT1    |Endpoint 1's USB Event Status
N * |        |          |0 = No event occurred on endpoint 1.
N * |        |          |1 = USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event
N * |        |          |was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1].
N * |[18]    |EPEVT2    |Endpoint 2's USB Event Status
N * |        |          |0 = No event occurred on endpoint 2.
N * |        |          |1 = USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event
N * |        |          |was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1].
N * |[19]    |EPEVT3    |Endpoint 3's USB Event Status
N * |        |          |0 = No event occurred on endpoint 3.
N * |        |          |1 = USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event
N * |        |          |was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1].
N * |[20]    |EPEVT4    |Endpoint 4's USB Event Status
N * |        |          |0 = No event occurred on endpoint 4.
N * |        |          |1 = USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event
N * |        |          |was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1].
N * |[21]    |EPEVT5    |Endpoint 5's USB Event Status
N * |        |          |0 = No event occurred on endpoint 5.
N * |        |          |1 = USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event
N * |        |          |was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1].
N * |[31]    |SETUP     |Setup Event Status
N * |        |          |0 = No Setup event.
N * |        |          |1 = SETUP event occurred, cleared by write 1 to USB_INTSTS[31].
N * @var USBD_T::FADDR
N * Offset: 0x08  USB Device Function Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[6:0]   |FADDR     |USB Device Function Address
N * @var USBD_T::EPSTS
N * Offset: 0x0C  USB Endpoint Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7]     |OVERRUN   |Overrun
N * |        |          |It indicates that the received data is over the maximum payload number or not.
N * |        |          |0 = No overrun.
N * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8
N * |        |          |Bytes.
N * |[10:8]  |EPSTS0    |Endpoint 0 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[13:11] |EPSTS1    |Endpoint 1 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[16:14] |EPSTS2    |Endpoint 2 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[19:17] |EPSTS3    |Endpoint 3 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[22:20] |EPSTS4    |Endpoint 4 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[25:23] |EPSTS5    |Endpoint 5 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * @var USBD_T::ATTR
N * Offset: 0x10  USB Bus Status and Attribution Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |USBRST    |USB Reset Status
N * |        |          |0 = Bus no reset.
N * |        |          |1 = Bus reset when SE0 (single-ended 0) is presented more than 2.5us.
N * |        |          |Note: This bit is read only.
N * |[1]     |SUSPEND   |Suspend Status
N * |        |          |0 = Bus no suspend.
N * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
N * |        |          |Note: This bit is read only.
N * |[2]     |RESUME    |Resume Status
N * |        |          |0 = No bus resume.
N * |        |          |1 = Resume from suspend.
N * |        |          |Note: This bit is read only.
N * |[3]     |TIMEOUT   |Time-Out Status
N * |        |          |0 = No time-out.
N * |        |          |1 = No Bus response more than 18 bits time.
N * |        |          |Note: This bit is read only.
N * |[4]     |PHY_EN    |PHY Transceiver Function Enable
N * |        |          |0 = PHY transceiver function Disabled.
N * |        |          |1 = PHY transceiver function Enabled.
N * |[5]     |RWAKEUP   |Remote Wake-Up
N * |        |          |0 = Release the USB bus from K state.
N * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up.
N * |[7]     |USB_EN    |USB Controller Enable
N * |        |          |0 = USB Controller Disabled.
N * |        |          |1 = USB Controller Enabled.
N * |[8]     |DPPU_EN   |Pull-Up Resistor On USB_D+ Enable
N * |        |          |0 = Pull-up resistor in USB_D+ pin Disabled.
N * |        |          |1 = Pull-up resistor in USB_D+ pin Enabled.
N * |[9]     |PWRDN     |Power-Down PHY Transceiver, Low Active
N * |        |          |0 = Power-down related circuit of PHY transceiver.
N * |        |          |1 = Turn-on related circuit of PHY transceiver.
N * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
N * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
N * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
N * @var USBD_T::FLDET
N * Offset: 0x14  USB Floating Detection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FLDET     |Device Floating Detected
N * |        |          |0 = Controller is not attached into the USB host.
N * |        |          |1 =Controller is attached into the BUS.
N * @var USBD_T::STBUFSEG
N * Offset: 0x18  Setup Token Buffer Segmentation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:3]   |STBUFSEG  |Setup Token Buffer Segmentation
N * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM
N * |        |          |starting address The effective starting address is
N * |        |          |USB_SRAM address + {STBUFSEG[8:3], 3'b000}
N * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
N * |        |          |Note: It is used for SETUP token only.
N * @var USBD_T::DRVSE0
N * Offset: 0x90  USB Drive SE0 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DRVSE0    |Drive Single Ended Zero In USB Bus
N * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
N * |        |          |0 = None.
N * |        |          |1 = Force USB PHY transceiver to drive SE0.
N */
N
N    __IO uint32_t INTEN;         /* Offset: 0x00  USB Interrupt Enable Register                                      */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSTS;        /* Offset: 0x04  USB Interrupt Event Status Register                                */
X    volatile uint32_t INTSTS;         
N    __IO uint32_t FADDR;         /* Offset: 0x08  USB Device Function Address Register                               */
X    volatile uint32_t FADDR;          
N    __I  uint32_t EPSTS;         /* Offset: 0x0C  USB Endpoint Status Register                                       */
X    volatile const  uint32_t EPSTS;          
N    __IO uint32_t ATTR;          /* Offset: 0x10  USB Bus Status and Attribution Register                            */
X    volatile uint32_t ATTR;           
N    __I  uint32_t FLDET;         /* Offset: 0x14  USB Floating Detection Register                                    */
X    volatile const  uint32_t FLDET;          
N    __IO uint32_t STBUFSEG;      /* Offset: 0x18  Setup Token Buffer Segmentation Register                           */
X    volatile uint32_t STBUFSEG;       
N    __I  uint32_t RESERVE0;   
X    volatile const  uint32_t RESERVE0;   
N    USBD_EP_T     EP[6];         /* Offset: 0x20  Endpoint Related Configuration Registers                           */
N    __I  uint32_t RESERVE1[4];  
X    volatile const  uint32_t RESERVE1[4];  
N    __IO uint32_t DRVSE0;        /* Offset: 0x90  USB Drive SE0 Control Register                                     */
X    volatile uint32_t DRVSE0;         
N
N} USBD_T;
N
N
N
N
N/**
N    @addtogroup USBD_CONST USBD Bit Field Definition
N    Constant Definitions for USBD Controller
N@{ */
N
N/* USBD INTEN Bit Field Definitions */
N#define USBD_INTEN_INNAK_EN_Pos    15                                    /*!< USBD_T::INTEN: INNAK_EN Position */
N#define USBD_INTEN_INNAK_EN_Msk    (1ul << USBD_INTEN_INNAK_EN_Pos)      /*!< USBD_T::INTEN: INNAK_EN Mask */
N
N#define USBD_INTEN_WAKEUP_EN_Pos   8                                     /*!< USBD_T::INTEN: RWAKEUP Position */
N#define USBD_INTEN_WAKEUP_EN_Msk   (1ul << USBD_INTEN_WAKEUP_EN_Pos)     /*!< USBD_T::INTEN: RWAKEUP Mask */
N
N#define USBD_INTEN_WAKEUP_IE_Pos   3                                     /*!< USBD_T::INTEN: WAKEUP_IE Position */
N#define USBD_INTEN_WAKEUP_IE_Msk   (1ul << USBD_INTEN_WAKEUP_IE_Pos)     /*!< USBD_T::INTEN: WAKEUP_IE Mask */
N
N#define USBD_INTEN_FLDET_IE_Pos    2                                     /*!< USBD_T::INTEN: FLDET_IE Position */
N#define USBD_INTEN_FLDET_IE_Msk    (1ul << USBD_INTEN_FLDET_IE_Pos)      /*!< USBD_T::INTEN: FLDET_IE Mask */
N
N#define USBD_INTEN_USB_IE_Pos      1                                     /*!< USBD_T::INTEN: USB_IE Position */
N#define USBD_INTEN_USB_IE_Msk      (1ul << USBD_INTEN_USB_IE_Pos)        /*!< USBD_T::INTEN: USB_IE Mask */
N
N#define USBD_INTEN_BUS_IE_Pos      0                                     /*!< USBD_T::INTEN: BUS_IE Position */
N#define USBD_INTEN_BUS_IE_Msk      (1ul << USBD_INTEN_BUS_IE_Pos)        /*!< USBD_T::INTEN: BUS_IE Mask */
N
N/* USBD INTSTS Bit Field Definitions */                                          
N#define USBD_INTSTS_SETUP_Pos        31                                  /*!< USBD_T::INTSTS: SETUP Position */
N#define USBD_INTSTS_SETUP_Msk        (1ul << USBD_INTSTS_SETUP_Pos)      /*!< USBD_T::INTSTS: SETUP Mask */
N
N#define USBD_INTSTS_EPEVT_Pos        16                                  /*!< USBD_T::INTSTS: EPEVT Position */
N#define USBD_INTSTS_EPEVT_Msk        (0x3Ful << USBD_INTSTS_EPEVT_Pos)   /*!< USBD_T::INTSTS: EPEVT Mask */
N
N#define USBD_INTSTS_WAKEUP_STS_Pos   3                                   /*!< USBD_T::INTSTS: WAKEUP_STS Position */
N#define USBD_INTSTS_WAKEUP_STS_Msk   (1ul << USBD_INTSTS_WAKEUP_STS_Pos) /*!< USBD_T::INTSTS: WAKEUP_STS Mask */
N
N#define USBD_INTSTS_FLDET_STS_Pos    2                                   /*!< USBD_T::INTSTS: FLDET_STS Position */
N#define USBD_INTSTS_FLDET_STS_Msk    (1ul << USBD_INTSTS_FLDET_STS_Pos)  /*!< USBD_T::INTSTS: FLDET_STS Mask */
N
N#define USBD_INTSTS_USB_STS_Pos      1                                   /*!< USBD_T::INTSTS: USB_STS Position */
N#define USBD_INTSTS_USB_STS_Msk      (1ul << USBD_INTSTS_USB_STS_Pos)    /*!< USBD_T::INTSTS: USB_STS Mask */
N
N#define USBD_INTSTS_BUS_STS_Pos      0                                   /*!< USBD_T::INTSTS: BUS_STS Position */
N#define USBD_INTSTS_BUS_STS_Msk      (1ul << USBD_INTSTS_BUS_STS_Pos)    /*!< USBD_T::INTSTS: BUS_STS Mask */
N
N/* USBD FADDR Bit Field Definitions */                                           
N#define USBD_FADDR_FADDR_Pos     0                                       /*!< USBD_T::FADDR: FADDR Position */
N#define USBD_FADDR_FADDR_Msk     (0x7Ful << USBD_FADDR_FADDR_Pos)        /*!< USBD_T::FADDR: FADDR Mask */
N
N/* USBD EPSTS Bit Field Definitions */                                           
N#define USBD_EPSTS_EPSTS5_Pos    23                                      /*!< USBD_T::EPSTS: EPSTS5 Position */
N#define USBD_EPSTS_EPSTS5_Msk    (7ul << USBD_EPSTS_EPSTS5_Pos)          /*!< USBD_T::EPSTS: EPSTS5 Mask */
N
N#define USBD_EPSTS_EPSTS4_Pos    20                                      /*!< USBD_T::EPSTS: EPSTS4 Position */
N#define USBD_EPSTS_EPSTS4_Msk    (7ul << USBD_EPSTS_EPSTS4_Pos)          /*!< USBD_T::EPSTS: EPSTS5 Mask */
N
N#define USBD_EPSTS_EPSTS3_Pos    17                                      /*!< USBD_T::EPSTS: EPSTS3 Position */
N#define USBD_EPSTS_EPSTS3_Msk    (7ul << USBD_EPSTS_EPSTS3_Pos)          /*!< USBD_T::EPSTS: EPSTS3 Mask */
N
N#define USBD_EPSTS_EPSTS2_Pos    14                                      /*!< USBD_T::EPSTS: EPSTS2 Position */
N#define USBD_EPSTS_EPSTS2_Msk    (7ul << USBD_EPSTS_EPSTS2_Pos)          /*!< USBD_T::EPSTS: EPSTS2 Mask */
N
N#define USBD_EPSTS_EPSTS1_Pos    11                                      /*!< USBD_T::EPSTS: EPSTS1 Position */
N#define USBD_EPSTS_EPSTS1_Msk    (7ul << USBD_EPSTS_EPSTS1_Pos)          /*!< USBD_T::EPSTS: EPSTS1 Mask */
N
N#define USBD_EPSTS_EPSTS0_Pos    8                                       /*!< USBD_T::EPSTS: EPSTS0 Position */
N#define USBD_EPSTS_EPSTS0_Msk    (7ul << USBD_EPSTS_EPSTS0_Pos)          /*!< USBD_T::EPSTS: EPSTS0 Mask */
N
N#define USBD_EPSTS_OVERRUN_Pos   7                                       /*!< USBD_T::EPSTS: OVERRUN Position */
N#define USBD_EPSTS_OVERRUN_Msk   (1ul << USBD_EPSTS_OVERRUN_Pos)         /*!< USBD_T::EPSTS: OVERRUN Mask */
N
N/* USBD ATTR Bit Field Definitions */                                            
N#define USBD_ATTR_BYTEM_Pos      10                                      /*!< USBD_T::ATTR: BYTEM Position */
N#define USBD_ATTR_BYTEM_Msk      (1ul << USBD_ATTR_BYTEM_Pos)            /*!< USBD_T::ATTR: BYTEM Mask */
N
N#define USBD_ATTR_PWRDN_Pos      9                                       /*!< USBD_T::ATTR: PWRDN Position */
N#define USBD_ATTR_PWRDN_Msk      (1ul << USBD_ATTR_PWRDN_Pos)            /*!< USBD_T::ATTR: PWRDN Mask */
N
N#define USBD_ATTR_DPPU_EN_Pos    8                                       /*!< USBD_T::ATTR: DPPU_EN Position */
N#define USBD_ATTR_DPPU_EN_Msk    (1ul << USBD_ATTR_DPPU_EN_Pos)          /*!< USBD_T::ATTR: DPPU_EN Mask */
N
N#define USBD_ATTR_USB_EN_Pos     7                                       /*!< USBD_T::ATTR: USB_EN Position */
N#define USBD_ATTR_USB_EN_Msk     (1ul << USBD_ATTR_USB_EN_Pos)           /*!< USBD_T::ATTR: USB_EN Mask */
N
N#define USBD_ATTR_RWAKEUP_Pos    5                                       /*!< USBD_T::ATTR: RWAKEUP Position */
N#define USBD_ATTR_RWAKEUP_Msk    (1ul << USBD_ATTR_RWAKEUP_Pos)          /*!< USBD_T::ATTR: RWAKEUP Mask */
N
N#define USBD_ATTR_PHY_EN_Pos     4                                       /*!< USBD_T::ATTR: PHY_EN Position */
N#define USBD_ATTR_PHY_EN_Msk     (1ul << USBD_ATTR_PHY_EN_Pos)           /*!< USBD_T::ATTR: PHY_EN Mask */
N
N#define USBD_ATTR_TIMEOUT_Pos    3                                       /*!< USBD_T::ATTR: TIMEOUT Position */
N#define USBD_ATTR_TIMEOUT_Msk    (1ul << USBD_ATTR_TIMEOUT_Pos)          /*!< USBD_T::ATTR: TIMEOUT Mask */
N
N#define USBD_ATTR_RESUME_Pos     2                                       /*!< USBD_T::ATTR: RESUME Position */
N#define USBD_ATTR_RESUME_Msk     (1ul << USBD_ATTR_RESUME_Pos)           /*!< USBD_T::ATTR: RESUME Mask */
N
N#define USBD_ATTR_SUSPEND_Pos    1                                       /*!< USBD_T::ATTR: SUSPEND Position */
N#define USBD_ATTR_SUSPEND_Msk    (1ul << USBD_ATTR_SUSPEND_Pos)          /*!< USBD_T::ATTR: SUSPEND Mask */
N
N#define USBD_ATTR_USBRST_Pos     0                                       /*!< USBD_T::ATTR: USBRST Position */
N#define USBD_ATTR_USBRST_Msk     (1ul << USBD_ATTR_USBRST_Pos)           /*!< USBD_T::ATTR: USBRST Mask */
N
N/* USBD FLDET Bit Field Definitions */                                           
N#define USBD_FLDET_FLDET_Pos     0                                       /*!< USBD_T::FLDET: FLDET Position */
N#define USBD_FLDET_FLDET_Msk     (1ul << USBD_FLDET_FLDET_Pos)           /*!< USBD_T::FLDET: FLDET Mask */
N
N/* USBD STBUFSEG Bit Field Definitions */
N#define USBD_STBUFSEG_STBUFSEG_Pos   3                                        /*!< USBD_T::STBUFSEG: STBUFSEG Position */
N#define USBD_STBUFSEG_STBUFSEG_Msk   (0x3Ful << USBD_STBUFSEG_STBUFSEG_Pos)   /*!< USBD_T::STBUFSEG: STBUFSEG Mask */
N
N/* USBD BUFSEG Bit Field Definitions */
N#define USBD_BUFSEG_BUFSEG_Pos   3                                       /*!< USBD_EP_T::BUFSEG: BUFSEG Position */
N#define USBD_BUFSEG_BUFSEG_Msk   (0x3Ful << USBD_BUFSEG_BUFSEG_Pos)      /*!< USBD_EP_T::BUFSEG: BUFSEG Mask */
N
N/* USBD MXPLD Bit Field Definitions */                                           
N#define USBD_MXPLD_MXPLD_Pos    0                                        /*!< USBD_EP_T::MXPLD: MXPLD Position */
N#define USBD_MXPLD_MXPLD_Msk    (0x1FFul << USBD_MXPLD_MXPLD_Pos)        /*!< USBD_EP_T::MXPLD: MXPLD Mask */
N
N/* USBD CFG Bit Field Definitions */                                             
N#define USBD_CFG_CSTALL_Pos     9                                        /*!< USBD_EP_T::CFG: CSTALL Position */
N#define USBD_CFG_CSTALL_Msk     (1ul << USBD_CFG_CSTALL_Pos)             /*!< USBD_EP_T::CFG: CSTALL Mask */
N
N#define USBD_CFG_DSQ_SYNC_Pos   7                                        /*!< USBD_EP_T::CFG: DSQ_SYNC Position */
N#define USBD_CFG_DSQ_SYNC_Msk   (1ul << USBD_CFG_DSQ_SYNC_Pos)           /*!< USBD_EP_T::CFG: DSQ_SYNC Mask */
N
N#define USBD_CFG_STATE_Pos      5                                        /*!< USBD_EP_T::CFG: STATE Position */
N#define USBD_CFG_STATE_Msk      (3ul << USBD_CFG_STATE_Pos)              /*!< USBD_EP_T::CFG: STATE Mask */
N
N#define USBD_CFG_ISOCH_Pos      4                                        /*!< USBD_EP_T::CFG: ISOCH Position */
N#define USBD_CFG_ISOCH_Msk      (1ul << USBD_CFG_ISOCH_Pos)              /*!< USBD_EP_T::CFG: ISOCH Mask */
N
N#define USBD_CFG_EP_NUM_Pos     0                                        /*!< USBD_EP_T::CFG: EP_NUM Position */
N#define USBD_CFG_EP_NUM_Msk     (0xFul << USBD_CFG_EP_NUM_Pos)           /*!< USBD_EP_T::CFG: EP_NUM Mask */
N
N/* USBD CFGP Bit Field Definitions */                                            
N#define USBD_CFGP_SSTALL_Pos    1                                        /*!< USBD_EP_T::CFGP: SSTALL Position */
N#define USBD_CFGP_SSTALL_Msk    (1ul << USBD_CFGP_SSTALL_Pos)            /*!< USBD_EP_T::CFGP: SSTALL Mask */
N
N#define USBD_CFGP_CLRRDY_Pos    0                                        /*!< USBD_EP_T::CFGP: CLRRDY Position */
N#define USBD_CFGP_CLRRDY_Msk    (1ul << USBD_CFGP_CLRRDY_Pos)            /*!< USBD_EP_T::CFGP: CLRRDY Mask */
N
N/* USBD DRVSE0 Bit Field Definitions */                                          
N#define USBD_DRVSE0_DRVSE0_Pos   0                                       /*!< USBD_T::DRVSE0: DRVSE0 Position */
N#define USBD_DRVSE0_DRVSE0_Msk   (1ul << USBD_DRVSE0_DRVSE0_Pos)         /*!< USBD_T::DRVSE0: DRVSE0 Mask */
N
N/*@}*/ /* end of group USBD_CONST */
N/*@}*/ /* end of group USBD */
N
N
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller (WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var WDT_T::WTCR
N * Offset: 0x00  Watchdog Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WTR       |Reset Watchdog Timer Up Counter (Write Protect)
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal 18-bit WDT up counter value.
N * |        |          |Note: This bit will be automatically cleared by hardware.
N * |[1]     |WTRE      |Watchdog Timer Reset Enable (Write Protect)
N * |        |          |Setting this bit will enable the WDT time-out reset function if the WDT up counter value has
N * |        |          |not been cleared after the specific WDT reset delay period expires.
N * |        |          |0 = WDT time-out reset function Disabled.
N * |        |          |1 = WDT time-out reset function Enabled.
N * |[2]     |WTRF      |Watchdog Timer Time-out Reset Flag
N * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
N * |        |          |0 = WDT time-out reset did not occur.
N * |        |          |1 = WDT time-out reset occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[3]     |WTIF      |Watchdog Timer Time-out Interrupt Flag
N * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out
N * |        |          |interval.
N * |        |          |0 = WDT time-out interrupt did not occur.
N * |        |          |1 = WDT time-out interrupt occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[4]     |WTWKE     |Watchdog Timer Time-out Wake-Up Function Control
N * |        |          |(Write Protect)
N * |        |          |If this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out
N * |        |          |interrupt signal will generate a wake-up trigger event to chip.
N * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
N * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
N * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock
N * |        |          |source is selected to 10 kHz oscillator.
N * |[5]     |WTWKF     |Watchdog Timer Time-out Wake-Up Flag
N * |        |          |This bit indicates the interrupt wake-up flag status of WDT.
N * |        |          |0 = WDT does not cause chip wake-up.
N * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[6]     |WTIE      |Watchdog Timer Time-out Interrupt Enable Control (Write Protect)
N * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
N * |        |          |0 = WDT time-out interrupt Disabled.
N * |        |          |1 = WDT time-out interrupt Enabled.
N * |[7]     |WTE       |Watchdog Timer Enable Control (Write Protect)
N * |        |          |0 = WDT Disabled. (This action will reset the internal up counter value.)
N * |        |          |1 = WDT Enabled.
N * |        |          |Note: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and
N * |        |          | user cannot change this bit to 0.
N * |[10:8]  |WTIS      |Watchdog Timer Time-out Interval Selection (Write Protect)
N * |        |          |These three bits select the time-out interval period for the WDT.
N * |        |          |000 = 24 *TWDT.
N * |        |          |001 = 26 * TWDT.
N * |        |          |010 = 28 * TWDT.
N * |        |          |011 = 210 * TWDT.
N * |        |          |100 = 212 * TWDT.
N * |        |          |101 = 214 * TWDT.
N * |        |          |110 = 216 * TWDT.
N * |        |          |111 = 218 * TWDT.
N * |[31]    |DBGACK_WDT|ICE Debug Mode Acknowledge Disable Control (Write Protect)
N * |        |          |0 = ICE debug mode acknowledgment effects WDT counting.
N * |        |          |WDT up counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgment Disabled.
N * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
N * @var WDT_T::WTCRALT
N * Offset: 0x04  Watchdog Timer Alternative Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WTRDSEL   |Watchdog Timer Reset Delay Selection (Write Protect)
N * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT
N * |        |          |counter to prevent WDT time-out reset happened.
N * |        |          |User can select a suitable value of WDT Reset Delay Period for different WDT time-out
N * |        |          |period.
N * |        |          |These bits are protected bit.
N * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Reference the register REGWRPROT at address GCR_BA+0x100.
N * |        |          |00 = Watchdog Timer Reset Delay Period is 1026 * WDT_CLK.
N * |        |          |01 = Watchdog Timer Reset Delay Period is 130 * WDT_CLK.
N * |        |          |10 = Watchdog Timer Reset Delay Period is 18 * WDT_CLK.
N * |        |          |11 = Watchdog Timer Reset Delay Period is 3 * WDT_CLK.
N * |        |          |Note: This register will be reset to 0 if WDT time-out reset happened.
N */
N
N    __IO uint32_t WTCR;          /* Offset: 0x00  Watchdog Timer Control Register                                    */
X    volatile uint32_t WTCR;           
N    __IO uint32_t WTCRALT;       /* Offset: 0x04  Watchdog Timer Alternative Control Register                        */
X    volatile uint32_t WTCRALT;        
N
N} WDT_T;
N
N
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask     */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask     */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position  */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask      */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask     */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask     */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask     */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position  */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask      */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position  */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask      */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position  */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask      */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position   */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask       */
N
N/* WDT WTCRALT Bit Field Definitions */                                                 
N#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
N#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
N/*@}*/ /* end of group WDT_CONST */
N/*@}*/ /* end of group WDT */
N
N
N/*---------------------- Window Watchdog Timer -------------------------*/
N/**
N    @addtogroup WWDT Window Watchdog Timer (WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var WWDT_T::WWDTRLD
N * Offset: 0x00  Window Watchdog Timer Reload Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
N * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
N * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT
N * |        |          | counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT
N * |        |          | counter value is larger than WINCMP, WWDT reset signal will generate immediately.
N * @var WWDT_T::WWDTCR
N * Offset: 0x04  Window Watchdog Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTEN    |WWDT Enable Control
N * |        |          |0 = WWDT counter is stopped.
N * |        |          |1 = WWDT counter is starting counting.
N * |[1]     |WWDTIE    |WWDT Interrupt Enable Control
N * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and
N * |        |          |inform to CPU.
N * |        |          |0 = WWDT counter compare match interrupt Disabled.
N * |        |          |1 = WWDT counter compare match interrupt Enabled.
N * |[11:8]  |PERIODSEL |WWDT Counter Prescale Period Selection
N * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
N * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
N * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
N * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
N * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
N * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
N * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
N * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
N * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
N * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
N * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
N * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
N * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
N * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
N * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
N * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
N * |[21:16] |WINCMP    |WWDT Window Compare Register
N * |        |          |Set this register to adjust the valid reload window.
N * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter
N * |        |          |value between 0 and WINCMP.
N * |        |          |If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal
N * |        |          |will generate immediately.
N * |[31]    |DBGACK_WWDT|ICE Debug Mode Acknowledge Disable Control
N * |        |          |0 = ICE debug mode acknowledgment effects WWDT counting.
N * |        |          |WWDT down counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgment Disabled.
N * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
N * @var WWDT_T::WWDTSR
N * Offset: 0x08  Window Watchdog Timer Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP
N * |        |          |value.
N * |        |          |0 = No effect.
N * |        |          |1 = WWDT counter value matches WINCMP value.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[1]     |WWDTRF    |WWDT Time-out Reset Flag
N * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
N * |        |          |0 = WWDT time-out reset did not occur.
N * |        |          |1 = WWDT time-out reset occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var WWDT_T::WWDTCVR
N * Offset: 0x0C  Window Watchdog Timer Counter Value Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |WWDTCVAL  |WWDT Counter Value
N * |        |          |WWDTCVAL will be updated continuously to monitor 6-bit down counter value.
N */
N
N    __IO uint32_t WWDTRLD;       /* Offset: 0x00  Window Watchdog Timer Reload Counter Register                      */
X    volatile uint32_t WWDTRLD;        
N    __IO uint32_t WWDTCR;        /* Offset: 0x04  Window Watchdog Timer Control Register                             */
X    volatile uint32_t WWDTCR;         
N    __IO uint32_t WWDTSR;        /* Offset: 0x08  Window Watchdog Timer Status Register                              */
X    volatile uint32_t WWDTSR;         
N    __I  uint32_t WWDTCVR;       /* Offset: 0x0C  Window Watchdog Timer Counter Value Register                       */
X    volatile const  uint32_t WWDTCVR;        
N
N} WWDT_T;
N
N
N
N/**
N    @addtogroup WWDT_CONST WWDT Bit Field Definition
N    Constant Definitions for WWDT Controller
N@{ */
N
N/* WWDT WWDTRLD Bit Field Definitions */
N#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
N#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
N
N/* WWDT WWDTCR Bit Field Definitions */                                                  
N#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
N#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
N
N#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
N#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
N
N#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
N#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
N
N#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
N#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
N
N#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
N#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
N
N/* WWDT WWDTSR Bit Field Definitions */                                                  
N#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
N#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
N
N#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
N#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
N
N/* WWDT WWDTCVR Bit Field Definitions */                                                 
N#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTRF Position */
N#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTRF Mask */
N/*@}*/ /* end of group WWDT_CONST */
N/*@}*/ /* end of group WWDT */
N/*@}*/ /* end of group REGISTER */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup PERIPHERAL_MEM_MAP Peripheral Memory Map
N  Memory Mapped Structure for Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE        + 0x4000)                   /*!< GPIO Base Address                                   */
N#define PA_BASE             (GPIO_BASE               )                   /*!< GPIO PORTA Base Address                             */
N#define PB_BASE             (GPIO_BASE       + 0x0040)                   /*!< GPIO PORTB Base Address                             */
N#define PC_BASE             (GPIO_BASE       + 0x0080)                   /*!< GPIO PORTC Base Address                             */
N#define PD_BASE             (GPIO_BASE       + 0x00C0)                   /*!< GPIO PORTD Base Address                             */
N#define PE_BASE             (GPIO_BASE       + 0x0100)                   /*!< GPIO PORTE Base Address                             */
N#define PF_BASE             (GPIO_BASE       + 0x0140)                   /*!< GPIO PORTF Base Address                             */
N#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N
N#define UART0_BASE           (APB1_BASE      + 0x50000)
N#define UART1_BASE           (APB2_BASE      + 0x50000)
N#define UART2_BASE           (APB2_BASE      + 0x54000)
N
N
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
N#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
N#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
N
N#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
N
N#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
N
N#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
N#define SPI1_BASE            (APB1_BASE      + 0x34000)                 /*!< SPI1 Base Address                                */
N#define SPI2_BASE            (APB2_BASE      + 0x30000)                 /*!< SPI2 Base Address                                */
N#define SPI3_BASE            (APB2_BASE      + 0x34000)                 /*!< SPI3 Base Address                                */
N
N#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
N#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
N
N#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
N
N#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
N
N#define ACMP_BASE            (APB1_BASE      + 0xD0000)                 /*!< ACMP Base Address                                */
N
N#define CLK_BASE             (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
N
N#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
N
N#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)
N
N#define PS2_BASE             (APB2_BASE      + 0x00000)                 /*!< PS/2 Base Address                                */
N
N#define USBD_BASE            (APB1_BASE      + 0x60000)                 /*!< USBD Base Address                                */
N
N#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
N#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
N#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
N#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
N#define PDMA4_BASE           (AHB_BASE       + 0x08400)                 /*!< PDMA4 Base Address                               */
N#define PDMA5_BASE           (AHB_BASE       + 0x08500)                 /*!< PDMA5 Base Address                               */
N#define PDMA6_BASE           (AHB_BASE       + 0x08600)                 /*!< PDMA6 Base Address                               */
N#define PDMA7_BASE           (AHB_BASE       + 0x08700)                 /*!< PDMA7 Base Address                               */
N#define PDMA8_BASE           (AHB_BASE       + 0x08800)                 /*!< PDMA8 Base Address                               */
N
N#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Global Base Address                         */
N
N#define CRC_BASE             (AHB_BASE       + 0x08E00)                 /*!< CRC Base Address                                 */
N
N#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
N#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
N
N#define SC0_BASE             (APB2_BASE      + 0x90000)                 /*!< SC0 Base Address                                 */
N#define SC1_BASE             (APB2_BASE      + 0x94000)                 /*!< SC1 Base Address                                 */
N#define SC2_BASE             (APB2_BASE      + 0x98000)                 /*!< SC2 Base Address                                 */
N
N#define I2S_BASE             (APB2_BASE      + 0xA0000)                 /*!< I2S Base Address                                 */
N
N#define EBI_BASE             (AHB_BASE       + 0x10000)                 /*!< EBI Base Address                                 */
N/*@}*/ /* end of group PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                         Peripheral Definitions                             */
N/******************************************************************************/
N
N/** @addtogroup PERIPHERAL Peripheral Definitions
N  The Definitions of Series Peripheral
N  @{
N */
N#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
N#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
N#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
N#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
N#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
N#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
N#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
N
N#define UART0               ((UART_T *) UART0_BASE)
N#define UART1               ((UART_T *) UART1_BASE)
N#define UART2               ((UART_T *) UART2_BASE)
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
N#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
N#define SPI2                ((SPI_T *) SPI2_BASE)                       /*!< SPI2 Configuration Struct                        */
N#define SPI3                ((SPI_T *) SPI3_BASE)                       /*!< SPI3 Configuration Struct                        */
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define I2S                 ((I2S_T *) I2S_BASE)                        /*!< I2S Configuration Struct                         */
N
N#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
N
N#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
N
N#define ACMP                ((ACMP_T *) ACMP_BASE)                      /*!< ACMP Configuration Struct                        */
N
N#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)
N
N#define PS2                 ((PS2_T *) PS2_BASE)                        /*!< PS/2 Configuration Struct                        */
N
N#define USBD                ((USBD_T *) USBD_BASE)                      /*!< USBD Configuration Struct                        */
N
N#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
N#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
N#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
N#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
N#define PDMA4               ((PDMA_T *) PDMA4_BASE)                     /*!< PDMA4 Configuration Struct                       */
N#define PDMA5               ((PDMA_T *) PDMA5_BASE)                     /*!< PDMA5 Configuration Struct                       */
N#define PDMA6               ((PDMA_T *) PDMA6_BASE)                     /*!< PDMA6 Configuration Struct                       */
N#define PDMA7               ((PDMA_T *) PDMA7_BASE)                     /*!< PDMA7 Configuration Struct                       */
N#define PDMA8               ((PDMA_T *) PDMA8_BASE)                     /*!< PDMA8 Configuration Struct                       */
N
N#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
N
N#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
N
N#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
N#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
N
N#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                        */
N#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                        */
N#define SC2                 ((SC_T *) SC2_BASE)                         /*!< SC2 Configuration Struct                        */
N
N#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
N
N/*@}*/ /* end of group PERIPHERAL */
N
N#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
N#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00
N
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
N
N//=============================================================================
N/** @addtogroup IO_ROUTINE I/O routines
N  The Declaration of I/O routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N/*@}*/ /* end of group IO_ROUTINE */
N
N
N
N
N/** @addtogroup legacy_Constants Legacy Constants
N  Legacy Constants
N  @{
N*/
N
N
N#define E_SUCCESS   0
N#ifndef NULL
S#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE     1
N#define DISABLE    0
N
N/* Define one bit mask */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group legacy_Constants */
N
N/*@}*/ /* end of group Definitions */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "SYS.h"
L 1 "..\..\..\Library\StdDriver\inc\SYS.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V3.00
N * $Revision: 8 $
N * $Date: 15/05/04 3:27p $
N * @brief    SYS Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CHIP_RST    ((0x0<<24) | SYS_IPRSTC1_CHIP_RST_Pos  ) /*!< CHIP reset is one of the SYS_ResetModule parameter */
N#define CPU_RST     ((0x0<<24) | SYS_IPRSTC1_CPU_RST_Pos   ) /*!< CPU reset is one of the SYS_ResetModule parameter */
N#define PDMA_RST    ((0x0<<24) | SYS_IPRSTC1_PDMA_RST_Pos  ) /*!< PDMA reset is one of the SYS_ResetModule parameter */
N#define EBI_RST     ((0x0<<24) | SYS_IPRSTC1_EBI_RST_Pos   ) /*!< EBI reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST    ((0x4<<24) | SYS_IPRSTC2_GPIO_RST_Pos  ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST    ((0x4<<24) | SYS_IPRSTC2_TMR0_RST_Pos  ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST    ((0x4<<24) | SYS_IPRSTC2_TMR1_RST_Pos  ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR2_RST    ((0x4<<24) | SYS_IPRSTC2_TMR2_RST_Pos  ) /*!< TMR2 reset is one of the SYS_ResetModule parameter */
N#define TMR3_RST    ((0x4<<24) | SYS_IPRSTC2_TMR3_RST_Pos  ) /*!< TMR3 reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST    ((0x4<<24) | SYS_IPRSTC2_I2C0_RST_Pos  ) /*!< I2C0 reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST    ((0x4<<24) | SYS_IPRSTC2_I2C1_RST_Pos  ) /*!< I2C1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST    ((0x4<<24) | SYS_IPRSTC2_SPI0_RST_Pos  ) /*!< SPI0 reset is one of the SYS_ResetModule parameter */
N#define SPI1_RST    ((0x4<<24) | SYS_IPRSTC2_SPI1_RST_Pos  ) /*!< SPI1 reset is one of the SYS_ResetModule parameter */
N#define SPI2_RST    ((0x4<<24) | SYS_IPRSTC2_SPI2_RST_Pos  ) /*!< SPI2 reset is one of the SYS_ResetModule parameter */
N#define SPI3_RST    ((0x4<<24) | SYS_IPRSTC2_SPI3_RST_Pos  ) /*!< SPI3 reset is one of the SYS_ResetModule parameter */
N#define UART0_RST   ((0x4<<24) | SYS_IPRSTC2_UART0_RST_Pos ) /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST   ((0x4<<24) | SYS_IPRSTC2_UART1_RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define UART2_RST   ((0x4<<24) | SYS_IPRSTC2_UART2_RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define PWM03_RST   ((0x4<<24) | SYS_IPRSTC2_PWM03_RST_Pos ) /*!< PWM03 reset is one of the SYS_ResetModule parameter */
N#define PWM47_RST   ((0x4<<24) | SYS_IPRSTC2_PWM47_RST_Pos ) /*!< PWM47 reset is one of the SYS_ResetModule parameter */
N#define ACMP_RST    ((0x4<<24) | SYS_IPRSTC2_ACMP_RST_Pos  ) /*!< ACMP reset is one of the SYS_ResetModule parameter */
N#define PS2_RST     ((0x4<<24) | SYS_IPRSTC2_PS2_RST_Pos   ) /*!< PS2 reset is one of the SYS_ResetModule parameter */
N#define USBD_RST    ((0x4<<24) | SYS_IPRSTC2_USBD_RST_Pos  ) /*!< USBD reset is one of the SYS_ResetModule parameter */
N#define ADC_RST     ((0x4<<24) | SYS_IPRSTC2_ADC_RST_Pos   ) /*!< ADC reset is one of the SYS_ResetModule parameter */
N#define I2S_RST     ((0x4<<24) | SYS_IPRSTC2_I2S_RST_Pos   ) /*!< I2S reset is one of the SYS_ResetModule parameter */
N#define SC0_RST     ((0x8<<24) | SYS_IPRSTC3_SC0_RST_Pos   ) /*!< SC0 reset is one of the SYS_ResetModule parameter */
N#define SC1_RST     ((0x8<<24) | SYS_IPRSTC3_SC1_RST_Pos   ) /*!< SC1 reset is one of the SYS_ResetModule parameter */
N#define SC2_RST     ((0x8<<24) | SYS_IPRSTC3_SC2_RST_Pos   ) /*!< SC2 reset is one of the SYS_ResetModule parameter */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_RST_EN            (1UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCR_BOD_INTERRUPT_EN      (0UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCR_BOD_VL_4_4V           (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */
N#define SYS_BODCR_BOD_VL_3_7V           (2UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCR_BOD_VL_2_7V           (1UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V           (0UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* How to use below #define?
NExample: If user want to set PA.0 as ADC0 and PA1 as ADC1 in initial function,
N         user can issue following command to achieve it.
N
N         SYS->GPA_MFP  = SYS_GPA_MFP_PA0_ADC0 | SYS_GPA_MFP_PA1_ADC1;
N         SYS->ALT_MFP1 = SYS_ALT_MFP1_PA0_ADC0| SYS_ALT_MFP1_PA1_ADC1;
N*/
N
N//PA.0
N#define SYS_GPA_MFP_PA0_GPIO            0x00000000UL        /*!< GPA_MFP PA.0 setting for GPIO */
N#define SYS_ALT_MFP_PA0_GPIO            NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.0 setting for GPIO */
N#define SYS_ALT_MFP2_PA0_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.0 */
N
N#define SYS_GPA_MFP_PA0_ADC0            (1UL<<0)            /*!< GPA_MFP PA.0 setting for ADC0 */
N#define SYS_ALT_MFP_PA0_ADC0            NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_ADC0           0x00000000UL        /*!< ALT_MFP1 PA.0 setting for ADC0 */
N#define SYS_ALT_MFP2_PA0_ADC0           NULL                /*!< No ALT_MFP2 setting for PA.0 */
N
N#define SYS_GPA_MFP_PA0_SC0_PWR         (1UL<<0)            /*!< GPA_MFP PA.0 setting for SC0_PWR */
N#define SYS_ALT_MFP_PA0_SC0_PWR         NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_SC0_PWR        (1UL<<2)            /*!< ALT_MFP1 PA.0 setting for SC0_PWR */
N#define SYS_ALT_MFP2_PA0_SC0_PWR        NULL                /*!< No ALT_MFP2 setting for PA.0 */
N
N#define SYS_GPA_MFP_PA0_Msk             (1UL<<0)            /*!< GPA_MFP PA.0 mask */
N#define SYS_ALT_MFP1_PA0_Msk            (1UL<<2)            /*!< ALT_MFP1 PA.0 mask */
N
N//PA.1
N#define SYS_GPA_MFP_PA1_GPIO            0x00000000UL        /*!< GPA_MFP PA.1 setting for GPIO */
N#define SYS_ALT_MFP_PA1_GPIO            0x00000000UL        /*!< ALT_MFP PA.1 setting for GPIO */
N#define SYS_ALT_MFP1_PA1_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.1 setting for GPIO */
N#define SYS_ALT_MFP2_PA1_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.1 */
N
N#define SYS_GPA_MFP_PA1_ADC1            (1UL<<1)            /*!< GPA_MFP PA.1 setting for ADC1 */
N#define SYS_ALT_MFP_PA1_ADC1            0x00000000UL        /*!< ALT_MFP PA.1 setting for ADC1 */
N#define SYS_ALT_MFP1_PA1_ADC1           0x00000000UL        /*!< ALT_MFP1 PA.1 setting for ADC1 */
N#define SYS_ALT_MFP2_PA1_ADC1           NULL                /*!< No ALT_MFP2 setting for PA.1 */
N
N#define SYS_GPA_MFP_PA1_SC0_RST         (1UL<<1)            /*!< GPA_MFP PA.1 setting for SC0_RST */
N#define SYS_ALT_MFP_PA1_SC0_RST         0x00000000UL        /*!< ALT_MFP PA.1 setting for SC0_RST */
N#define SYS_ALT_MFP1_PA1_SC0_RST        (1UL<<3)            /*!< ALT_MFP1 PA.1 setting for SC0_RST */
N#define SYS_ALT_MFP2_PA1_SC0_RST        NULL                /*!< No ALT_MFP2 setting for PA.1 */
N    
N#define SYS_GPA_MFP_PA1_EBI_AD12        (1UL<<1)                /*!< GPA_MFP PA.1 setting for EBI_AD12 */
N#define SYS_ALT_MFP_PA1_EBI_AD12        ((1UL<<11) | (1UL<<20)) /*!< ALT_MFP PA.1 setting for EBI_AD12 */
N#define SYS_ALT_MFP1_PA1_EBI_AD12       0x00000000UL            /*!< ALT_MFP1 PA.1 setting for EBI_AD12 */
N#define SYS_ALT_MFP2_PA1_EBI_AD12       NULL                    /*!< No ALT_MFP2 setting for PA.1 */
N
N#define SYS_GPA_MFP_PA1_Msk             (1UL<<1)                /*!< GPA_MFP PA.1 mask */
N#define SYS_ALT_MFP_PA1_Msk             ((1UL<<11) | (1UL<<20)) /*!< ALT_MFP PA.1 mask */ 
N#define SYS_ALT_MFP1_PA1_Msk            (1UL<<3)                /*!< ALT_MFP1 PA.1 mask */
N
N//PA.2
N#define SYS_GPA_MFP_PA2_GPIO            0x00000000UL        /*!< GPA_MFP PA.2 setting for GPIO */
N#define SYS_ALT_MFP_PA2_GPIO            0x00000000UL        /*!< ALT_MFP PA.2 setting for GPIO */
N#define SYS_ALT_MFP1_PA2_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.2 setting for GPIO */
N#define SYS_ALT_MFP2_PA2_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_ADC2            (1UL<<2)            /*!< GPA_MFP PA.2 setting for ADC2 */
N#define SYS_ALT_MFP_PA2_ADC2            0x00000000UL        /*!< ALT_MFP PA.2 setting for ADC2 */
N#define SYS_ALT_MFP1_PA2_ADC2           0x00000000UL        /*!< ALT_MFP1 PA.2 setting for ADC2 */
N#define SYS_ALT_MFP2_PA2_ADC2           NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_SC0_CLK         (1UL<<2)            /*!< GPA_MFP PA.2 setting for SC0_CLK */
N#define SYS_ALT_MFP_PA2_SC0_CLK         0x00000000UL        /*!< ALT_MFP PA.2 setting for SC0_CLK */
N#define SYS_ALT_MFP1_PA2_SC0_CLK        (1UL<<0)            /*!< ALT_MFP1 PA.2 setting for SC0_CLK */
N#define SYS_ALT_MFP2_PA2_SC0_CLK        NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_EBI_AD11        (1UL<<2)                /*!< GPA_MFP PA.2 setting for EBI_AD11 */
N#define SYS_ALT_MFP_PA2_EBI_AD11        ((1UL<<11) | (1UL<<19)) /*!< ALT_MFP PA.2 setting for EBI_AD11 */
N#define SYS_ALT_MFP1_PA2_EBI_AD11       0x00000000UL            /*!< ALT_MFP1 PA.2 setting for EBI_AD11 */
N#define SYS_ALT_MFP2_PA2_EBI_AD11       NULL                    /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_Msk             (1UL<<2)                /*!< GPA_MFP PA.2 mask */
N#define SYS_ALT_MFP_PA2_Msk             ((1UL<<11) | (1UL<<19)) /*!< ALT_MFP PA.1 mask */   
N#define SYS_ALT_MFP1_PA2_Msk            (1UL<<0)                /*!< ALT_MFP1 PA.2 mask */
N
N//PA.3
N#define SYS_GPA_MFP_PA3_GPIO            0x00000000UL        /*!< GPA_MFP PA.3 setting for GPIO */
N#define SYS_ALT_MFP_PA3_GPIO            0x00000000UL        /*!< ALT_MFP PA.3 setting for GPIO */
N#define SYS_ALT_MFP1_PA3_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.3 setting for GPIO */
N#define SYS_ALT_MFP2_PA3_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_ADC3            (1UL<<3)            /*!< GPA_MFP PA.3 setting for ADC3 */
N#define SYS_ALT_MFP_PA3_ADC3            0x00000000UL        /*!< ALT_MFP PA.3 setting for ADC3 */
N#define SYS_ALT_MFP1_PA3_ADC3           0x00000000UL        /*!< ALT_MFP1 PA.3 setting for ADC3 */
N#define SYS_ALT_MFP2_PA3_ADC3           NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_SC0_DAT         (1UL<<3)            /*!< GPA_MFP PA.3 setting for SC0_DAT */
N#define SYS_ALT_MFP_PA3_SC0_DAT         0x00000000UL        /*!< ALT_MFP PA.3 setting for SC0_DAT */
N#define SYS_ALT_MFP1_PA3_SC0_DAT        (1UL<<1)            /*!< ALT_MFP1 PA.3 setting for SC0_DAT */
N#define SYS_ALT_MFP2_PA3_SC0_DAT        NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_EBI_AD10        (1UL<<3)                /*!< GPA_MFP PA.3 setting for EBI_AD10 */
N#define SYS_ALT_MFP_PA3_EBI_AD10        ((1UL<<11) | (1UL<<18)) /*!< ALT_MFP PA.3 setting for EBI_AD10 */
N#define SYS_ALT_MFP1_PA3_EBI_AD10       0x00000000UL            /*!< ALT_MFP1 PA.3 setting for EBI_AD10 */
N#define SYS_ALT_MFP2_PA3_EBI_AD10       NULL                    /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_Msk             (1UL<<3)                /*!< GPA_MFP PA.3 mask */
N#define SYS_ALT_MFP_PA3_Msk             ((1UL<<11) | (1UL<<18)) /*!< ALT_MFP PA.3 mask */   
N#define SYS_ALT_MFP1_PA3_Msk            (1UL<<1)                /*!< ALT_MFP1 PA.3 mask */
N
N//PA.4
N#define SYS_GPA_MFP_PA4_GPIO            0x00000000UL        /*!< GPA_MFP PA.4 setting for GPIO */
N#define SYS_ALT_MFP_PA4_GPIO            0x00000000UL        /*!< ALT_MFP PA.4 setting for GPIO */
N#define SYS_ALT_MFP1_PA4_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.4 setting for GPIO */
N#define SYS_ALT_MFP2_PA4_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_ADC4            (1UL<<4)            /*!< GPA_MFP PA.4 setting for ADC4 */
N#define SYS_ALT_MFP_PA4_ADC4            0x00000000UL        /*!< ALT_MFP PA.4 setting for ADC4 */
N#define SYS_ALT_MFP1_PA4_ADC4           0x00000000UL        /*!< ALT_MFP1 PA.4 setting for ADC4 */
N#define SYS_ALT_MFP2_PA4_ADC4           NULL                /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_SC1_PWR         (1UL<<4)            /*!< GPA_MFP PA.4 setting for SC1_PWR */
N#define SYS_ALT_MFP_PA4_SC1_PWR         0x00000000UL        /*!< ALT_MFP PA.4 setting for SC1_PWR */
N#define SYS_ALT_MFP1_PA4_SC1_PWR        (1UL<<7)            /*!< ALT_MFP1 PA.4 setting for SC1_PWR */
N#define SYS_ALT_MFP2_PA4_SC1_PWR        NULL                /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_EBI_AD9         (1UL<<4)                /*!< GPA_MFP PA.4 setting for EBI_AD9 */
N#define SYS_ALT_MFP_PA4_EBI_AD9         ((1UL<<11) | (1UL<<17)) /*!< ALT_MFP PA.4 setting for EBI_AD9 */
N#define SYS_ALT_MFP1_PA4_EBI_AD9        0x00000000UL            /*!< ALT_MFP1 PA.4 setting for EBI_AD9 */
N#define SYS_ALT_MFP2_PA4_EBI_AD9        NULL                    /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_Msk             (1UL<<4)                /*!< GPA_MFP PA.4 mask */
N#define SYS_ALT_MFP_PA4_Msk             ((1UL<<11) | (1UL<<17)) /*!< ALT_MFP PA.4 mask */ 
N#define SYS_ALT_MFP1_PA4_Msk            (1UL<<7)                /*!< ALT_MFP1 PA.4 mask */
N
N//PA.5
N#define SYS_GPA_MFP_PA5_GPIO            0x00000000UL        /*!< GPA_MFP PA.5 setting for GPIO */
N#define SYS_ALT_MFP_PA5_GPIO            0x00000000UL        /*!< ALT_MFP PA.5 setting for GPIO */
N#define SYS_ALT_MFP1_PA5_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.5 setting for GPIO */
N#define SYS_ALT_MFP2_PA5_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_ADC5            (1UL<<5)            /*!< GPA_MFP PA.5 setting for ADC5 */
N#define SYS_ALT_MFP_PA5_ADC5            0x00000000UL        /*!< ALT_MFP PA.5 setting for ADC5 */
N#define SYS_ALT_MFP1_PA5_ADC5           0x00000000UL        /*!< ALT_MFP1 PA.5 setting for ADC5 */
N#define SYS_ALT_MFP2_PA5_ADC5           NULL                /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_SC1_RST         (1UL<<5)            /*!< GPA_MFP PA.5 setting for SC1_RST */
N#define SYS_ALT_MFP_PA5_SC1_RST         0x00000000UL        /*!< ALT_MFP PA.5 setting for SC1_RST */
N#define SYS_ALT_MFP1_PA5_SC1_RST        (1UL<<8)            /*!< ALT_MFP1 PA.5 setting for SC1_RST */
N#define SYS_ALT_MFP2_PA5_SC1_RST        NULL                /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_EBI_AD8         (1UL<<5)                /*!< GPA_MFP PA.5 setting for EBI_AD8 */
N#define SYS_ALT_MFP_PA5_EBI_AD8         ((1UL<<11) | (1UL<<16)) /*!< ALT_MFP PA.5 setting for EBI_AD8 */
N#define SYS_ALT_MFP1_PA5_EBI_AD8        0x00000000UL            /*!< ALT_MFP1 PA.5 setting for EBI_AD8 */
N#define SYS_ALT_MFP2_PA5_EBI_AD8        NULL                    /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_Msk             (1UL<<5)                /*!< GPA_MFP PA.5 mask */
N#define SYS_ALT_MFP_PA5_Msk             ((1UL<<11) | (1UL<<16)) /*!< ALT_MFP PA.5 mask */ 
N#define SYS_ALT_MFP1_PA5_Msk            (1UL<<8)                /*!< ALT_MFP1 PA.5 mask */
N
N//PA.6
N#define SYS_GPA_MFP_PA6_GPIO            0x00000000UL        /*!< GPA_MFP PA.6 setting for GPIO */
N#define SYS_ALT_MFP_PA6_GPIO            0x00000000UL        /*!< ALT_MFP PA.6 setting for GPIO */
N#define SYS_ALT_MFP1_PA6_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.6 setting for GPIO */
N#define SYS_ALT_MFP2_PA6_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_ADC6            (1UL<<6)            /*!< GPA_MFP PA.6 setting for ADC6 */
N#define SYS_ALT_MFP_PA6_ADC6            0x00000000UL        /*!< ALT_MFP PA.6 setting for ADC6 */
N#define SYS_ALT_MFP1_PA6_ADC6           0x00000000UL        /*!< ALT_MFP1 PA.6 setting for ADC6 */
N#define SYS_ALT_MFP2_PA6_ADC6           NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_SC1_CLK         (1UL<<6)            /*!< GPA_MFP PA.6 setting for SC1_CLK */
N#define SYS_ALT_MFP_PA6_SC1_CLK         0x00000000UL        /*!< ALT_MFP PA.6 setting for SC1_CLK */
N#define SYS_ALT_MFP1_PA6_SC1_CLK        (1UL<<5)            /*!< ALT_MFP1 PA.6 setting for SC1_CLK */
N#define SYS_ALT_MFP2_PA6_SC1_CLK        NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_EBI_AD7         (1UL<<6)            /*!< GPA_MFP PA.6 setting for AD7 */    
N#define SYS_ALT_MFP_PA6_EBI_AD7         (1UL<<11)           /*!< ALT_MFP PA.6 setting for AD7 */ 
N#define SYS_ALT_MFP1_PA6_EBI_AD7        0x00000000UL        /*!< ALT_MFP1 PA.6 setting for AD7 */ 
N#define SYS_ALT_MFP2_PA6_EBI_AD7        NULL                /*!< No ALT_MFP2 setting for PA.6 */ 
N
N#define SYS_GPA_MFP_PA6_Msk             (1UL<<6)            /*!< GPA_MFP PA.6 mask */
N#define SYS_ALT_MFP_PA6_Msk             (1UL<<11)           /*!< ALT_MFP PA.6 mask */ 
N#define SYS_ALT_MFP1_PA6_Msk            (1UL<<5)            /*!< ALT_MFP1 PA.6 mask */
N
N//PA.7
N#define SYS_GPA_MFP_PA7_GPIO            0x00000000UL        /*!< GPA_MFP PA.7 setting for GPIO */
N#define SYS_ALT_MFP_PA7_GPIO            0x00000000UL        /*!< ALT_MFP PA.7 setting for GPIO */
N#define SYS_ALT_MFP1_PA7_GPIO           0x00000000UL        /*!< ALT_MFP1 PA.7 setting for GPIO */
N#define SYS_ALT_MFP2_PA7_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.7 */ 
N
N#define SYS_GPA_MFP_PA7_ADC7            (1UL<<7)            /*!< GPA_MFP PA.7 setting for ADC7 */
N#define SYS_ALT_MFP_PA7_ADC7            0x00000000UL        /*!< ALT_MFP PA.7 setting for ADC7 */
N#define SYS_ALT_MFP1_PA7_ADC7           0x00000000UL        /*!< ALT_MFP1 PA.7 setting for ADC7 */
N#define SYS_ALT_MFP2_PA7_ADC7           NULL                /*!< No ALT_MFP2 setting for PA.7 */ 
N
N#define SYS_GPA_MFP_PA7_SPI2_SS1        (1UL<<7)            /*!< GPA_MFP PA.7 setting for SPI2_SS1 */
N#define SYS_ALT_MFP_PA7_SPI2_SS1        (1UL<<2)            /*!< ALT_MFP PA.7 setting for SPI2_SS1 */
N#define SYS_ALT_MFP1_PA7_SPI2_SS1       0x00000000UL        /*!< ALT_MFP1 PA.7 setting for SPI2_SS1 */
N#define SYS_ALT_MFP2_PA7_SPI2_SS1       NULL                /*!< No ALT_MFP2 setting for PA.7 */ 
N
N#define SYS_GPA_MFP_PA7_SC1_DAT         (1UL<<7)            /*!< GPA_MFP PA.7 setting for SC1_DAT */
N#define SYS_ALT_MFP_PA7_SC1_DAT         0x00000000UL        /*!< ALT_MFP PA.7 setting for SC1_DAT */
N#define SYS_ALT_MFP1_PA7_SC1_DAT        (1UL<<6)            /*!< ALT_MFP1 PA.7 setting for SC1_DAT */
N#define SYS_ALT_MFP2_PA7_SC1_DAT        NULL                /*!< No ALT_MFP2 setting for PA.7 */ 
N
N#define SYS_GPA_MFP_PA7_EBI_AD6         (1UL<<7)            /*!< GPA_MFP PA.7 setting for EBI_AD6 */    
N#define SYS_ALT_MFP_PA7_EBI_AD6         (1UL<<11)           /*!< ALT_MFP PA.7 setting for EBI_AD6 */ 
N#define SYS_ALT_MFP1_PA7_EBI_AD6        0x00000000UL        /*!< ALT_MFP1 PA.7 setting for EBI_AD6 */ 
N#define SYS_ALT_MFP2_PA7_EBI_AD6        NULL                /*!< No ALT_MFP2 setting for PA.7 */ 
N
N#define SYS_GPA_MFP_PA7_Msk             (1UL<<7)                /*!< GPA_MFP PA.7 mask */
N#define SYS_ALT_MFP_PA7_Msk             ((1UL<<2) | (1UL<<11))  /*!< ALT_MFP PA.7 mask */ 
N#define SYS_ALT_MFP1_PA7_Msk            (1UL<<6)                /*!< ALT_MFP1 PA.7 mask */
N
N//PA.8
N#define SYS_GPA_MFP_PA8_GPIO            0x00000000UL        /*!< GPA_MFP PA.8 setting for GPIO */
N#define SYS_ALT_MFP_PA8_GPIO            NULL                /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_GPIO           NULL                /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.8 */
N
N#define SYS_GPA_MFP_PA8_I2C0_SDA        (1UL<<8)            /*!< GPA_MFP PA.8 setting for I2C0_SDA */
N#define SYS_ALT_MFP_PA8_I2C0_SDA        NULL                /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_I2C0_SDA       NULL                /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_I2C0_SDA       NULL                /*!< No ALT_MFP2 setting for PA.8 */
N
N#define SYS_GPA_MFP_PA8_Msk             (1UL<<8)            /*!< GPA_MFP PA.8 mask */
N
N//PA.9
N#define SYS_GPA_MFP_PA9_GPIO            0x00000000UL        /*!< GPA_MFP PA.9 setting for GPIO */
N#define SYS_ALT_MFP_PA9_GPIO            NULL                /*!< No ALT_MFP setting for PA.9 */
N#define SYS_ALT_MFP1_PA9_GPIO           NULL                /*!< No ALT_MFP1 setting for PA.9 */
N#define SYS_ALT_MFP2_PA9_GPIO           NULL                /*!< No ALT_MFP2 setting for PA.9 */
N
N#define SYS_GPA_MFP_PA9_I2C0_SCL        (1UL<<9)            /*!< GPA_MFP PA.9 setting for I2C0_SCL */
N#define SYS_ALT_MFP_PA9_I2C0_SCL        NULL                /*!< No ALT_MFP setting for PA.9 */
N#define SYS_ALT_MFP1_PA9_I2C0_SCL       NULL                /*!< No ALT_MFP1 setting for PA.9 */
N#define SYS_ALT_MFP2_PA9_I2C0_SCL       NULL                /*!< No ALT_MFP2 setting for PA.9 */
N
N#define SYS_GPA_MFP_PA9_Msk             (1UL<<9)            /*!< GPA_MFP PA.9 mask */
N
N//PA.10
N#define SYS_GPA_MFP_PA10_GPIO           0x00000000UL        /*!< GPA_MFP PA.10 setting for GPIO */
N#define SYS_ALT_MFP_PA10_GPIO           0x00000000UL        /*!< No ALT_MFP setting for PA.10 */
N#define SYS_ALT_MFP1_PA10_GPIO          NULL                /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_GPIO          NULL                /*!< No ALT_MFP2 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_I2C1_SDA       (1UL<<10)           /*!< GPA_MFP PA.10 setting for I2C1_SDA */
N#define SYS_ALT_MFP_PA10_I2C1_SDA       0x00000000UL        /*!< No ALT_MFP setting for PA.10 */
N#define SYS_ALT_MFP1_PA10_I2C1_SDA      NULL                /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_I2C1_SDA      NULL                /*!< No ALT_MFP2 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_EBI_nWR        (1UL<<10)           /*!< GPA_MFP PA.10 setting for EBI_nWR */    
N#define SYS_ALT_MFP_PA10_EBI_nWR        (1UL<<11)           /*!< ALT_MFP PA.10 setting for EBI_nWR */ 
N#define SYS_ALT_MFP1_PA10_EBI_nWR       NULL                /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_EBI_nWR       NULL                /*!< No ALT_MFP2 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_Msk            (1UL<<10)           /*!< GPA_MFP PA.10 mask */
N#define SYS_ALT_MFP_PA10_Msk            (1UL<<11)           /*!< ALT_MFP PA.10 mask */
N
N//PA.11
N#define SYS_GPA_MFP_PA11_GPIO           0x00000000UL        /*!< GPA_MFP PA.11 setting for GPIO */
N#define SYS_ALT_MFP_PA11_GPIO           0x00000000UL        /*!< ALT_MFP PA.11 setting for GPIO */
N#define SYS_ALT_MFP1_PA11_GPIO          NULL                /*!< No ALT_MFP1 setting for PA.11 */
N#define SYS_ALT_MFP2_PA11_GPIO          NULL                /*!< No ALT_MFP2 setting for PA.11 */
N
N#define SYS_GPA_MFP_PA11_I2C1_SCL       (1UL<<11)           /*!< GPA_MFP PA.11 setting for I2C1_SCL */
N#define SYS_ALT_MFP_PA11_I2C1_SCL       0x00000000UL        /*!< ALT_MFP PA.11 setting for I2C1_SCL */
N#define SYS_ALT_MFP1_PA11_I2C1_SCL      NULL                /*!< No ALT_MFP1 setting for PA.11 */
N#define SYS_ALT_MFP2_PA11_I2C1_SCL      NULL                /*!< No ALT_MFP2 setting for PA.11 */
N
N#define SYS_GPA_MFP_PA11_EBI_nRD        (1UL<<11)           /*!< GPA_MFP PA.11 setting for EBI_nRD */    
N#define SYS_ALT_MFP_PA11_EBI_nRD        (1UL<<11)           /*!< ALT_MFP PA.11 setting for EBI_nRD */ 
N#define SYS_ALT_MFP1_PA11_EBI_nRD       NULL                /*!< No ALT_MFP1 setting for PA.11 */
N#define SYS_ALT_MFP2_PA11_EBI_nRD       NULL                /*!< No ALT_MFP2 setting for PA.11 */
N
N#define SYS_GPA_MFP_PA11_Msk            (1UL<<11)           /*!< GPA_MFP PA.11 mask */
N#define SYS_ALT_MFP_PA11_Msk            (1UL<<11)           /*!< ALT_MFP PA.11 mask */
N
N//PA.12
N#define SYS_GPA_MFP_PA12_GPIO           0x00000000UL        /*!< GPA_MFP PA.12 setting for GPIO */
N#define SYS_ALT_MFP_PA12_GPIO           0x00000000UL        /*!< ALT_MFP PA.12 setting for GPIO */
N#define SYS_ALT_MFP1_PA12_GPIO          0x00000000UL        /*!< ALT_MFP1 PA.12 setting for GPIO */
N#define SYS_ALT_MFP2_PA12_GPIO          NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_PWM0           (1UL<<12)           /*!< GPA_MFP PA.12 setting for PWM0 */
N#define SYS_ALT_MFP_PA12_PWM0           0x00000000UL        /*!< ALT_MFP PA.12 setting for PWM0 */
N#define SYS_ALT_MFP1_PA12_PWM0          0x00000000UL        /*!< ALT_MFP1 PA.12 setting for PWM0 */
N#define SYS_ALT_MFP2_PA12_PWM0          NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_SC2_DAT        (1UL<<12)           /*!< GPA_MFP PA.12 setting for SC2_DAT */
N#define SYS_ALT_MFP_PA12_SC2_DAT        0x00000000UL        /*!< ALT_MFP PA.12 setting for SC2_DAT */
N#define SYS_ALT_MFP1_PA12_SC2_DAT       (1UL<<11)           /*!< ALT_MFP1 PA.12 setting for SC2_DAT */
N#define SYS_ALT_MFP2_PA12_SC2_DAT       NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_EBI_AD13       (1UL<<12)               /*!< GPA_MFP PA.12 setting for EBI_AD13 */
N#define SYS_ALT_MFP_PA12_EBI_AD13       ((1UL<<21) | (1UL<<11)) /*!< ALT_MFP PA.12 setting for EBI_AD13 */
N#define SYS_ALT_MFP1_PA12_EBI_AD13      0x00000000UL            /*!< ALT_MFP1 PA.12 setting for EBI_AD13 */
N#define SYS_ALT_MFP2_PA12_EBI_AD13      NULL                    /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_Msk            (1UL<<12)               /*!< GPA_MFP PA.12 mask */
N#define SYS_ALT_MFP_PA12_Msk            ((1UL<<21) | (1UL<<11)) /*!< ALT_MFP PA.12 mask */ 
N#define SYS_ALT_MFP1_PA12_Msk           (1UL<<11)               /*!< ALT_MFP1 PA.12 mask */
N
N//PA.13
N#define SYS_GPA_MFP_PA13_GPIO           0x00000000UL        /*!< GPA_MFP PA.13 setting for GPIO */
N#define SYS_ALT_MFP_PA13_GPIO           0x00000000UL        /*!< ALT_MFP PA.13 setting for GPIO */
N#define SYS_ALT_MFP1_PA13_GPIO          0x00000000UL        /*!< ALT_MFP1 PA.13 setting for GPIO */
N#define SYS_ALT_MFP2_PA13_GPIO          NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_PWM1           (1UL<<13)           /*!< GPA_MFP PA.13 setting for PWM1 */
N#define SYS_ALT_MFP_PA13_PWM1           0x00000000UL        /*!< ALT_MFP PA.13 setting for PWM1 */
N#define SYS_ALT_MFP1_PA13_PWM1          0x00000000UL        /*!< ALT_MFP1 PA.13 setting for PWM1 */
N#define SYS_ALT_MFP2_PA13_PWM1          NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_SC2_CLK        (1UL<<13)           /*!< GPA_MFP PA.13 setting for SC2_CLK */
N#define SYS_ALT_MFP_PA13_SC2_CLK        0x00000000UL        /*!< ALT_MFP PA.13 setting for SC2_CLK */
N#define SYS_ALT_MFP1_PA13_SC2_CLK       (1UL<<10)           /*!< ALT_MFP1 PA.13 setting for SC2_CLK */
N#define SYS_ALT_MFP2_PA13_SC2_CLK       NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_EBI_AD14       (1UL<<13)               /*!< GPA_MFP PA.13 setting for EBI_AD14 */
N#define SYS_ALT_MFP_PA13_EBI_AD14       ((1UL<<22) | (1UL<<11)) /*!< ALT_MFP PA.13 setting for EBI_AD14 */
N#define SYS_ALT_MFP1_PA13_EBI_AD14      0x00000000UL            /*!< ALT_MFP1 PA.13 setting for EBI_AD14 */
N#define SYS_ALT_MFP2_PA13_EBI_AD14      NULL                    /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_Msk            (1UL<<13)               /*!< GPA_MFP PA.13 mask */
N#define SYS_ALT_MFP_PA13_Msk            ((1UL<<22) | (1UL<<11)) /*!< ALT_MFP PA.13 mask */ 
N#define SYS_ALT_MFP1_PA13_Msk           (1UL<<10)               /*!< ALT_MFP1 PA.13 mask */
N
N//PA.14
N#define SYS_GPA_MFP_PA14_GPIO           0x00000000UL        /*!< GPA_MFP PA.14 setting for GPIO */
N#define SYS_ALT_MFP_PA14_GPIO           0x00000000UL        /*!< ALT_MFP PA.14 setting for GPIO */
N#define SYS_ALT_MFP1_PA14_GPIO          0x00000000UL        /*!< ALT_MFP1 PA.14 setting for GPIO */
N#define SYS_ALT_MFP2_PA14_GPIO          NULL                /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_PWM2           (1UL<<14)           /*!< GPA_MFP PA.14 setting for PWM2 */
N#define SYS_ALT_MFP_PA14_PWM2           0x00000000UL        /*!< ALT_MFP PA.14 setting for PWM2 */
N#define SYS_ALT_MFP1_PA14_PWM2          0x00000000UL        /*!< ALT_MFP1 PA.14 setting for PWM2 */
N#define SYS_ALT_MFP2_PA14_PWM2          NULL                /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_SC2_RST        (1UL<<14)           /*!< GPA_MFP PA.14 setting for SC2_RST */
N#define SYS_ALT_MFP_PA14_SC2_RST        0x00000000UL        /*!< ALT_MFP PA.14 setting for SC2_RST */
N#define SYS_ALT_MFP1_PA14_SC2_RST       (1UL<<13)           /*!< ALT_MFP1 PA.14 setting for SC2_RST */
N#define SYS_ALT_MFP2_PA14_SC2_RST       NULL                /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_EBI_AD15       (1UL<<14)               /*!< GPA_MFP PA.14 setting for EBI_AD15 */
N#define SYS_ALT_MFP_PA14_EBI_AD15       ((1UL<<23) | (1UL<<11)) /*!< ALT_MFP PA.14 setting for EBI_AD15 */
N#define SYS_ALT_MFP1_PA14_EBI_AD15      0x00000000UL            /*!< ALT_MFP1 PA.14 setting for EBI_AD15 */
N#define SYS_ALT_MFP2_PA14_EBI_AD15      NULL                    /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_Msk            (1UL<<14)               /*!< GPA_MFP PA.14 mask */
N#define SYS_ALT_MFP_PA14_Msk            ((1UL<<23) | (1UL<<11)) /*!< ALT_MFP PA.14 mask */  
N#define SYS_ALT_MFP1_PA14_Msk           (1UL<<13)               /*!< ALT_MFP1 PA.14 mask */
N
N//PA.15
N#define SYS_GPA_MFP_PA15_GPIO           0x00000000UL    /*!< GPA_MFP PA.15 setting for GPIO */
N#define SYS_ALT_MFP_PA15_GPIO           0x00000000UL    /*!< ALT_MFP PA.15 setting for GPIO */
N#define SYS_ALT_MFP1_PA15_GPIO          0x00000000UL    /*!< ALT_MFP1 PA.15 setting for GPIO */
N#define SYS_ALT_MFP2_PA15_GPIO          NULL            /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_PWM3           (1UL<<15)       /*!< GPA_MFP PA.15 setting for PWM3 */
N#define SYS_ALT_MFP_PA15_PWM3           0x00000000UL    /*!< ALT_MFP PA.15 setting for PWM3 */
N#define SYS_ALT_MFP1_PA15_PWM3          0x00000000UL    /*!< ALT_MFP1 PA.15 setting for PWM3 */
N#define SYS_ALT_MFP2_PA15_PWM3          NULL            /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_I2S_MCLK       (1UL<<15)       /*!< GPA_MFP PA.15 setting for I2S_MCLK */
N#define SYS_ALT_MFP_PA15_I2S_MCLK       (1UL<<9)        /*!< ALT_MFP PA.15 setting for I2S_MCLK */
N#define SYS_ALT_MFP1_PA15_I2S_MCLK      0x00000000UL    /*!< ALT_MFP1 PA.15 setting for I2S_MCLK */
N#define SYS_ALT_MFP2_PA15_I2S_MCLK      NULL            /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_SC2_PWR        (1UL<<15)       /*!< GPA_MFP PA.15 setting for SC2_PWR */
N#define SYS_ALT_MFP_PA15_SC2_PWR        0x00000000UL    /*!< ALT_MFP PA.15 setting for SC2_PWR */
N#define SYS_ALT_MFP1_PA15_SC2_PWR       (1UL<<12)       /*!< ALT_MFP1 PA.15 setting for SC2_PWR */
N#define SYS_ALT_MFP2_PA15_SC2_PWR       NULL            /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_Msk            (1UL<<15)       /*!< GPA_MFP PA.15 mask */
N#define SYS_ALT_MFP_PA15_Msk            (1UL<<9)        /*!< ALT_MFP PA.15 mask */
N#define SYS_ALT_MFP1_PA15_Msk           (1UL<<12)       /*!< ALT_MFP1 PA.15 mask */
N
N//PB.0
N#define SYS_GPB_MFP_PB0_GPIO            0x00000000UL    /*!< GPB_MFP PB.0 setting for GPIO */
N#define SYS_ALT_MFP_PB0_GPIO            NULL            /*!< No ALT_MFP setting for PB.0 */
N#define SYS_ALT_MFP1_PB0_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.0 */
N#define SYS_ALT_MFP2_PB0_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.0 */
N
N#define SYS_GPB_MFP_PB0_UART0_RXD       (1UL<<0)        /*!< GPB_MFP PB.0 setting for UART0_RXD */
N#define SYS_ALT_MFP_PB0_UART0_RXD       NULL            /*!< No ALT_MFP setting for PB.0 */
N#define SYS_ALT_MFP1_PB0_UART0_RXD      NULL            /*!< No ALT_MFP1 setting for PB.0 */
N#define SYS_ALT_MFP2_PB0_UART0_RXD      NULL            /*!< No ALT_MFP2 setting for PB.0 */
N
N#define SYS_GPB_MFP_PB0_Msk             (1UL<<0)        /*!< GPB_MFP PB.0 mask */
N
N//PB.1
N#define SYS_GPB_MFP_PB1_GPIO            0x00000000UL    /*!< GPB_MFP PB.1 setting for GPIO */
N#define SYS_ALT_MFP_PB1_GPIO            NULL            /*!< No ALT_MFP setting for PB.1 */
N#define SYS_ALT_MFP1_PB1_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.1 */
N#define SYS_ALT_MFP2_PB1_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.1 */
N
N#define SYS_GPB_MFP_PB1_UART0_TXD       (1UL<<1)        /*!< GPB_MFP PB.1 setting for UART0_TXD */
N#define SYS_ALT_MFP_PB1_UART0_TXD       NULL            /*!< No ALT_MFP setting for PB.1 */
N#define SYS_ALT_MFP1_PB1_UART0_TXD      NULL            /*!< No ALT_MFP1 setting for PB.1 */
N#define SYS_ALT_MFP2_PB1_UART0_TXD      NULL            /*!< No ALT_MFP2 setting for PB.1 */
N
N#define SYS_GPB_MFP_PB1_Msk             (1UL<<1)        /*!< GPB_MFP PB.1 mask */
N
N//PB.2
N#define SYS_GPB_MFP_PB2_GPIO            0x00000000UL    /*!< GPB_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP_PB2_GPIO            0x00000000UL    /*!< ALT_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP1_PB2_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_UART0_nRTS      (1UL<<2)        /*!< GPB_MFP PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP_PB2_UART0_nRTS      0x00000000UL    /*!< ALT_MFP PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP1_PB2_UART0_nRTS     NULL            /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_UART0_nRTS     NULL            /*!< No ALT_MFP2 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_EBI_nWRL        (1UL<<2)                /*!< GPB_MFP PB.2 setting for EBI_nWRL */    
N#define SYS_ALT_MFP_PB2_EBI_nWRL        ((1UL<<13)|(1UL<<11))   /*!< ALT_MFP PB.2 setting for EBI_nWRL */ 
N#define SYS_ALT_MFP1_PB2_EBI_nWRL       NULL                    /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_EBI_nWRL       NULL                    /*!< No ALT_MFP2 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_TM2_EXT         (1UL<<2)        /*!< GPB_MFP PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP_PB2_TM2_EXT         (1UL<<26)       /*!< ALT_MFP PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP1_PB2_TM2_EXT        NULL            /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_TM2_EXT        NULL            /*!< No ALT_MFP2 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_Msk             (1UL<<2)                        /*!< GPB_MFP PB.2 mask */
N#define SYS_ALT_MFP_PB2_Msk             ((1UL<<26)|(1UL<<13)|(1UL<<11)) /*!< ALT_MFP PB.2 mask */ 
N
N//PB.3
N#define SYS_GPB_MFP_PB3_GPIO            0x00000000UL    /*!< GPB_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP_PB3_GPIO            0x00000000UL    /*!< ALT_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP1_PB3_GPIO           0x00000000UL    /*!< ALT_MFP1 PB.3 setting for GPIO */
N#define SYS_ALT_MFP2_PB3_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_UART0_nCTS      (1UL<<3)        /*!< GPB_MFP PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP_PB3_UART0_nCTS      0x00000000UL    /*!< ALT_MFP PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP1_PB3_UART0_nCTS     0x00000000UL    /*!< ALT_MFP1 PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP2_PB3_UART0_nCTS     NULL            /*!< No ALT_MFP2 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_TM3_EXT         (1UL<<3)        /*!< GPB_MFP PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP_PB3_TM3_EXT         (1UL<<27)       /*!< ALT_MFP PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP1_PB3_TM3_EXT        0x00000000UL    /*!< ALT_MFP1 PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP2_PB3_TM3_EXT        NULL            /*!< No ALT_MFP2 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_SC2_CD          (1UL<<3)        /*!< GPB_MFP PB.3 setting for SC2_CD */
N#define SYS_ALT_MFP_PB3_SC2_CD          0x00000000UL    /*!< ALT_MFP PB.3 setting for SC2_CD */
N#define SYS_ALT_MFP1_PB3_SC2_CD         (1UL<<14)       /*!< ALT_MFP1 PB.3 setting for SC2_CD */
N#define SYS_ALT_MFP2_PB3_SC2_CD         NULL            /*!< No ALT_MFP2 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_EBI_nWRH        (1UL<<3)                /*!< GPB_MFP PB.3 setting for EBI_nWRH */    
N#define SYS_ALT_MFP_PB3_EBI_nWRH        ((1UL<<14) | (1UL<<11)) /*!< ALT_MFP PB.3 setting for EBI_nWRH */ 
N#define SYS_ALT_MFP1_PB3_EBI_nWRH       0x00000000UL            /*!< ALT_MFP1 PB.3 setting for EBI_nWRH */ 
N#define SYS_ALT_MFP2_PB3_EBI_nWRH       NULL                    /*!< ALT_MFP2 PB.3 setting for EBI_nWRH */ 
N
N#define SYS_GPB_MFP_PB3_Msk             (1UL<<3)                        /*!< GPB_MFP PB.3 mask */
N#define SYS_ALT_MFP_PB3_Msk             ((1UL<<27)|(1UL<<14)|(1UL<<11)) /*!< ALT_MFP PB.3 mask */ 
N#define SYS_ALT_MFP1_PB3_Msk            (1UL<<14)                       /*!< ALT_MFP1 PB.3 mask */
N
N//PB.4
N#define SYS_GPB_MFP_PB4_GPIO            0x00000000UL    /*!< GPA_MFP PB.4 setting for GPIO */
N#define SYS_ALT_MFP_PB4_GPIO            NULL            /*!< No ALT_MFP setting for PB.4 */
N#define SYS_ALT_MFP1_PB4_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.4 */
N#define SYS_ALT_MFP2_PB4_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.4 */
N
N#define SYS_GPB_MFP_PB4_UART1_RXD       (1UL<<4)        /*!< GPA_MFP PB.4 setting for UART1_RXD */
N#define SYS_ALT_MFP_PB4_UART1_RXD       NULL            /*!< No ALT_MFP setting for PB.4 */
N#define SYS_ALT_MFP1_PB4_UART1_RXD      NULL            /*!< No ALT_MFP1 setting for PB.4 */
N#define SYS_ALT_MFP2_PB4_UART1_RXD      NULL            /*!< No ALT_MFP2 setting for PB.4 */
N
N#define SYS_GPB_MFP_PB4_Msk             (1UL<<4)        /*!< GPA_MFP PB.4 mask */
N
N//PB.5
N#define SYS_GPB_MFP_PB5_GPIO            0x00000000UL    /*!< GPA_MFP PB.5 setting for GPIO */
N#define SYS_ALT_MFP_PB5_GPIO            NULL            /*!< No ALT_MFP setting for PB.5 */
N#define SYS_ALT_MFP1_PB5_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.5 */
N#define SYS_ALT_MFP2_PB5_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.5 */
N
N#define SYS_GPB_MFP_PB5_UART1_TXD       (1UL<<5)        /*!< GPA_MFP PB.5 setting for UART1_TXD */
N#define SYS_ALT_MFP_PB5_UART1_TXD       NULL            /*!< No ALT_MFP setting for PB.5 */
N#define SYS_ALT_MFP1_PB5_UART1_TXD      NULL            /*!< No ALT_MFP1 setting for PB.5 */
N#define SYS_ALT_MFP2_PB5_UART1_TXD      NULL            /*!< No ALT_MFP2 setting for PB.5 */
N
N#define SYS_GPB_MFP_PB5_Msk             (1UL<<5)        /*!< GPA_MFP PB.5 mask */
N
N//PB.6
N#define SYS_GPB_MFP_PB6_GPIO            0x00000000UL    /*!< GPB_MFP PB.6 setting for GPIO */
N#define SYS_ALT_MFP_PB6_GPIO            0x00000000UL    /*!< ALT_MFP PB.6 setting for GPIO */
N#define SYS_ALT_MFP1_PB6_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.6 */
N#define SYS_ALT_MFP2_PB6_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_UART1_nRTS      (1UL<<6)        /*!< GPB_MFP PB.6 setting for UART1_nRTS */
N#define SYS_ALT_MFP_PB6_UART1_nRTS      NULL            /*!< ALT_MFP PB.6 setting for UART1_nRTS */
N#define SYS_ALT_MFP1_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP1 setting for PB.6 */
N#define SYS_ALT_MFP2_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP2 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_EBI_ALE         (1UL<<6)        /*!< GPB_MFP PB.6 setting for EBI_ALE */        
N#define SYS_ALT_MFP_PB6_EBI_ALE         (1UL<<11)       /*!< ALT_MFP PB.6 setting for EBI_ALE */
N#define SYS_ALT_MFP1_PB6_EBI_ALE        NULL            /*!< No ALT_MFP1 setting for PB.6 */ 
N#define SYS_ALT_MFP2_PB6_EBI_ALE        NULL            /*!< No ALT_MFP2 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_Msk             (1UL<<6)        /*!< GPB_MFP PB.6 mask */
N#define SYS_ALT_MFP_PB6_Msk             (1UL<<11)       /*!< ALT_MFP PB.6 mask */ 
N
N//PB.7
N#define SYS_GPB_MFP_PB7_GPIO            0x00000000UL    /*!< GPB_MFP PB.7 setting for GPIO */
N#define SYS_ALT_MFP_PB7_GPIO            0x00000000UL    /*!< ALT_MFP PB.7 setting for GPIO */
N#define SYS_ALT_MFP1_PB7_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.7 */
N#define SYS_ALT_MFP2_PB7_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_UART1_nCTS      (1UL<<7)        /*!< GPB_MFP PB.7 setting for UART1_nCTS */
N#define SYS_ALT_MFP_PB7_UART1_nCTS      0x00000000UL    /*!< ALT_MFP PB.7 setting for UART1_nCTS */
N#define SYS_ALT_MFP1_PB7_UART1_nCTS     NULL            /*!< No ALT_MFP1 setting for PB.7 */
N#define SYS_ALT_MFP2_PB7_UART1_nCTS     NULL            /*!< No ALT_MFP2 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_EBI_nCS         (1UL<<7)        /*!< GPB_MFP PB.7 setting for EBI_nCS */
N#define SYS_ALT_MFP_PB7_EBI_nCS         (1UL<<11)       /*!< ALT_MFP PB.7 setting for EBI_nCS */
N#define SYS_ALT_MFP1_PB7_EBI_nCS        NULL            /*!< No ALT_MFP1 setting for PB.7 */ 
N#define SYS_ALT_MFP2_PB7_EBI_nCS        NULL            /*!< No ALT_MFP2 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_Msk             (1UL<<7)        /*!< GPB_MFP PB.7 mask */
N#define SYS_ALT_MFP_PB7_Msk             (1UL<<11)       /*!< ALT_MFP PB.7 mask */ 
N
N//PB.8
N#define SYS_GPB_MFP_PB8_GPIO            0x00000000UL    /*!< GPA_MFP PB.8 setting for GPIO */
N#define SYS_ALT_MFP_PB8_GPIO            NULL            /*!< No ALT_MFP setting for PB.8 */
N#define SYS_ALT_MFP1_PB8_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_TM0             (1UL<<8)        /*!< GPA_MFP PB.8 setting for TM0 */
N#define SYS_ALT_MFP_PB8_TM0             NULL            /*!< No ALT_MFP setting for PB.8 */
N#define SYS_ALT_MFP1_PB8_TM0            NULL            /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_TM0            NULL            /*!< No ALT_MFP2 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_Msk             (1UL<<8)        /*!< GPA_MFP PB.8 mask */
N
N//PB.9
N#define SYS_GPB_MFP_PB9_GPIO            0x00000000UL    /*!< GPB_MFP PB.9 setting for GPIO */
N#define SYS_ALT_MFP_PB9_GPIO            0x00000000UL    /*!< ALT_MFP PB.9 setting for GPIO */
N#define SYS_ALT_MFP1_PB9_GPIO           NULL            /*!< No ALT_MFP1 setting for PB.9 */
N#define SYS_ALT_MFP2_PB9_GPIO           NULL            /*!< No ALT_MFP2 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_TM1             (1UL<<9)        /*!< GPB_MFP PB.9 setting for TM1 */
N#define SYS_ALT_MFP_PB9_TM1             0x00000000UL    /*!< ALT_MFP PB.9 setting for TM1 */
N#define SYS_ALT_MFP1_PB9_TM1            NULL            /*!< No ALT_MFP1 setting for PB.9 */
N#define SYS_ALT_MFP2_PB9_TM1            NULL            /*!< No ALT_MFP2 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_SPI1_SS1        (1UL<<9)        /*!< GPB_MFP PB.9 setting for SPI1_SS1 */
N#define SYS_ALT_MFP_PB9_SPI1_SS1        (1UL<<1)        /*!< ALT_MFP PB.9 setting for SPI1_SS1 */
N#define SYS_ALT_MFP1_PB9_SPI1_SS1       NULL            /*!< No ALT_MFP1 setting for PB.9 */
N#define SYS_ALT_MFP2_PB9_SPI1_SS1       NULL            /*!< No ALT_MFP2 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_Msk             (1UL<<9)        /*!< GPB_MFP PB.9 mask */
N#define SYS_ALT_MFP_PB9_Msk             (1UL<<1)        /*!< ALT_MFP PB.9 mask */
N
N//PB.10
N#define SYS_GPB_MFP_PB10_GPIO           0x00000000UL    /*!< GPB_MFP PB.10 setting for GPIO */
N#define SYS_ALT_MFP_PB10_GPIO           0x00000000UL    /*!< ALT_MFP PB.10 setting for GPIO */
N#define SYS_ALT_MFP1_PB10_GPIO          NULL            /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_GPIO          NULL            /*!< No ALT_MFP2 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_TM2            (1UL<<10)       /*!< GPB_MFP PB.10 setting for TM2 */
N#define SYS_ALT_MFP_PB10_TM2            0x00000000UL    /*!< ALT_MFP PB.10 setting for TM2 */
N#define SYS_ALT_MFP1_PB10_TM2           NULL            /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_TM2           NULL            /*!< No ALT_MFP2 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_SPI0_SS1       (1UL<<10)       /*!< GPB_MFP PB.10 setting for SPI0_SS1 */
N#define SYS_ALT_MFP_PB10_SPI0_SS1       (1UL<<0)        /*!< ALT_MFP PB.10 setting for SPI0_SS1 */
N#define SYS_ALT_MFP1_PB10_SPI0_SS1      NULL            /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_SPI0_SS1      NULL            /*!< No ALT_MFP2 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_Msk            (1UL<<10)       /*!< GPB_MFP PB.10 mask */
N#define SYS_ALT_MFP_PB10_Msk            (1UL<<0)        /*!< ALT_MFP PB.10 mask */
N
N//PB.11
N#define SYS_GPB_MFP_PB11_GPIO           0x00000000UL    /*!< GPB_MFP PB.11 setting for GPIO */
N#define SYS_ALT_MFP_PB11_GPIO           0x00000000UL    /*!< ALT_MFP PB.11 setting for GPIO */
N#define SYS_ALT_MFP1_PB11_GPIO          NULL            /*!< No ALT_MFP1 setting for PB.11 */
N#define SYS_ALT_MFP2_PB11_GPIO          NULL            /*!< No ALT_MFP2 setting for PB.11 */
N
N#define SYS_GPB_MFP_PB11_TM3            (1UL<<11)       /*!< GPB_MFP PB.11 setting for TM3 */
N#define SYS_ALT_MFP_PB11_TM3            0x00000000UL    /*!< ALT_MFP PB.11 setting for TM3 */
N#define SYS_ALT_MFP1_PB11_TM3           NULL            /*!< No ALT_MFP1 setting for PB.11 */
N#define SYS_ALT_MFP2_PB11_TM3           NULL            /*!< No ALT_MFP2 setting for PB.11 */
N
N#define SYS_GPB_MFP_PB11_PWM4           (1UL<<11)       /*!< GPB_MFP PB.11 setting for PWM4 */
N#define SYS_ALT_MFP_PB11_PWM4           (1UL<<4)        /*!< ALT_MFP PB.11 setting for PWM4 */
N#define SYS_ALT_MFP1_PB11_PWM4          NULL            /*!< No ALT_MFP1 setting for PB.11 */
N#define SYS_ALT_MFP2_PB11_PWM4          NULL            /*!< No ALT_MFP2 setting for PB.11 */
N
N#define SYS_GPB_MFP_PB11_Msk            (1UL<<11)       /*!< GPB_MFP PB.11 mask */
N#define SYS_ALT_MFP_PB11_Msk            (1UL<<4)        /*!< ALT_MFP PB.11 mask */
N
N//PB.12
N#define SYS_GPB_MFP_PB12_GPIO           0x00000000UL    /*!< GPB_MFP PB.12 setting for GPIO */    
N#define SYS_ALT_MFP_PB12_GPIO           0x00000000UL    /*!< ALT_MFP PB.12 setting for GPIO */
N#define SYS_ALT_MFP1_PB12_GPIO          NULL            /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_GPIO          NULL            /*!< No ALT_MFP2 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_ACMP0_O        (1UL<<12)       /*!< GPB_MFP PB.12 setting for ACMP0_O */      
N#define SYS_ALT_MFP_PB12_ACMP0_O        0x00000000UL    /*!< ALT_MFP PB.12 setting for ACMP0_O */
N#define SYS_ALT_MFP1_PB12_ACMP0_O       NULL            /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_ACMP0_O       NULL            /*!< No ALT_MFP2 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_CLKO           (1UL<<12)       /*!< GPB_MFP PB.12 setting for CLKO */      
N#define SYS_ALT_MFP_PB12_CLKO           (1UL<<10)       /*!< ALT_MFP PB.12 setting for CLKO */
N#define SYS_ALT_MFP1_PB12_CLKO          NULL            /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_CLKO          NULL            /*!< No ALT_MFP2 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_EBI_AD0        (1UL<<12)       /*!< GPB_MFP PB.12 setting for AD0 */      
N#define SYS_ALT_MFP_PB12_EBI_AD0        (1UL<<11)       /*!< ALT_MFP PB.12 setting for AD0 */
N#define SYS_ALT_MFP1_PB12_EBI_AD0       NULL            /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_EBI_AD0       NULL            /*!< No ALT_MFP2 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_Msk            (1UL<<12)               /*!< GPB_MFP PB.12 mask */      
N#define SYS_ALT_MFP_PB12_Msk            ((1UL<<10) | (1UL<<11)) /*!< ALT_MFP PB.12 mask */ 
N
N
N//PB.13
N#define SYS_GPB_MFP_PB13_GPIO           0x00000000UL    /*!< GPB_MFP PB.13 setting for GPIO */
N#define SYS_ALT_MFP_PB13_GPIO           0x00000000UL    /*!< ALT_MFP PB.13 setting for GPIO */
N#define SYS_ALT_MFP1_PB13_GPIO          NULL            /*!< No ALT_MFP1 setting for PB.13  */
N#define SYS_ALT_MFP2_PB13_GPIO          NULL            /*!< No ALT_MFP2 setting for PB.13  */
N
N#define SYS_GPB_MFP_PB13_ACMP1_O        (1UL<<13)       /*!< GPB_MFP PB.13 setting for ACMP1_O */
N#define SYS_ALT_MFP_PB13_ACMP1_O        0x00000000UL    /*!< ALT_MFP PB.13 setting for ACMP1_O */
N#define SYS_ALT_MFP1_PB13_ACMP1_O       NULL            /*!< No ALT_MFP1 setting for PB.13 */
N#define SYS_ALT_MFP2_PB13_ACMP1_O       NULL            /*!< No ALT_MFP2 setting for PB.13 */
N
N#define SYS_GPB_MFP_PB13_EBI_AD1        (1UL<<13)       /*!< GPB_MFP PB.13 setting for EBI_AD1 */      
N#define SYS_ALT_MFP_PB13_EBI_AD1        (1UL<<11)       /*!< ALT_MFP PB.13 setting for EBI_AD1 */
N#define SYS_ALT_MFP1_PB13_EBI_AD1       NULL            /*!< No ALT_MFP1 setting for PB.13 */
N#define SYS_ALT_MFP2_PB13_EBI_AD1       NULL            /*!< No ALT_MFP2 setting for PB.13 */
N
N#define SYS_GPB_MFP_PB13_Msk            (1UL<<13)       /*!< GPB_MFP PB.13 mask */
N#define SYS_ALT_MFP_PB13_Msk            (1UL<<11)       /*!< ALT_MFP PB.13 mask */ 
N
N//PB.14
N#define SYS_GPB_MFP_PB14_GPIO           0x00000000UL    /*!< GPB_MFP PB.14 setting for GPIO */
N#define SYS_ALT_MFP_PB14_GPIO           0x00000000UL    /*!< ALT_MFP PB.14 setting for GPIO */
N#define SYS_ALT_MFP1_PB14_GPIO          NULL            /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_GPIO          NULL            /*!< No ALT_MFP2 setting for PB.14 */
N
N#define SYS_GPB_MFP_PB14_INT0           (1UL<<14)       /*!< GPB_MFP PB.14 setting for INT0 */
N#define SYS_ALT_MFP_PB14_INT0           0x00000000UL    /*!< ALT_MFP PB.14 setting for INT0 */
N#define SYS_ALT_MFP1_PB14_INT0          NULL            /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_INT0          NULL            /*!< No ALT_MFP2 setting for PB.14 */
N
N#define SYS_GPB_MFP_PB14_SPI3_SS1       (1UL<<14)       /*!< GPB_MFP PB.14 setting for SPI3_SS1 */
N#define SYS_ALT_MFP_PB14_SPI3_SS1       (1UL<<3)        /*!< ALT_MFP PB.14 setting for SPI3_SS1 */
N#define SYS_ALT_MFP1_PB14_SPI3_SS1      NULL            /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_SPI3_SS1      NULL            /*!< No ALT_MFP2 setting for PB.14 */
N
N#define SYS_GPB_MFP_PB14_Msk            (1UL<<14)       /*!< GPB_MFP PB.14 mask */
N#define SYS_ALT_MFP_PB14_Msk            (1UL<<3)        /*!< ALT_MFP PB.14 mask */
N
N//PB.15
N#define SYS_GPB_MFP_PB15_GPIO           0x00000000UL    /*!< GPB_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP_PB15_GPIO           0x00000000UL    /*!< ALT_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP1_PB15_GPIO          NULL            /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_GPIO          NULL            /*!< No ALT_MFP2 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_INT1           (1UL<<15)       /*!< GPB_MFP PB.15 setting for INT1 */
N#define SYS_ALT_MFP_PB15_INT1           0x00000000UL    /*!< ALT_MFP PB.15 setting for INT1 */
N#define SYS_ALT_MFP1_PB15_INT1          NULL            /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_INT1          NULL            /*!< No ALT_MFP2 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_TM0_EXT        (1UL<<15)       /*!< GPB_MFP PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP_PB15_TM0_EXT        (1UL<<24)       /*!< ALT_MFP PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP1_PB15_TM0_EXT       NULL            /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_TM0_EXT       NULL            /*!< No ALT_MFP2 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_Msk            (1UL<<15)       /*!< GPB_MFP PB.15 mask */
N#define SYS_ALT_MFP_PB15_Msk            (1UL<<24)       /*!< ALT_MFP PB.15 mask */
N
N
N//PC.0
N#define SYS_GPC_MFP_PC0_GPIO            0x00000000UL    /*!< GPC_MFP PC.0 setting for GPIO */
N#define SYS_ALT_MFP_PC0_GPIO            0x00000000UL    /*!< ALT_MFP PC.0 setting for GPIO */
N#define SYS_ALT_MFP1_PC0_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_SPI0_SS0        (1UL<<0)        /*!< GPC_MFP PC.0 setting for SPI0_SS0 */
N#define SYS_ALT_MFP_PC0_SPI0_SS0        0x00000000UL    /*!< ALT_MFP PC.0 setting for SPI0_SS0 */
N#define SYS_ALT_MFP1_PC0_SPI0_SS0       NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_SPI0_SS0       NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_I2S_LRCLK       (1UL<<0)        /*!< GPC_MFP PC.0 setting for I2S_LRCLK */
N#define SYS_ALT_MFP_PC0_I2S_LRCLK       (1UL<<5)        /*!< ALT_MFP PC.0 setting for I2S_LRCLK */
N#define SYS_ALT_MFP1_PC0_I2S_LRCLK      NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_I2S_LRCLK      NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_I2S_LRCK        (1UL<<0)        /*!< GPC_MFP PC.0 setting for I2S_LRCK */
N#define SYS_ALT_MFP_PC0_I2S_LRCK        (1UL<<5)        /*!< ALT_MFP PC.0 setting for I2S_LRCK */
N#define SYS_ALT_MFP1_PC0_I2S_LRCK       NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_I2S_LRCK       NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_Msk             (1UL<<0)        /*!< GPC_MFP PC.0 mask */
N#define SYS_ALT_MFP_PC0_Msk             (1UL<<5)        /*!< ALT_MFP PC.0 mask */
N
N//PC.1
N#define SYS_GPC_MFP_PC1_GPIO            0x00000000UL    /*!< GPC_MFP PC.1 setting for GPIO */
N#define SYS_ALT_MFP_PC1_GPIO            0x00000000UL    /*!< ALT_MFP PC.1 setting for GPIO */
N#define SYS_ALT_MFP1_PC1_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_SPI0_CLK        (1UL<<1)        /*!< GPC_MFP PC.1 setting for SPI0_CLK */
N#define SYS_ALT_MFP_PC1_SPI0_CLK        0x00000000UL    /*!< ALT_MFP PC.1 setting for SPI0_CLK */
N#define SYS_ALT_MFP1_PC1_SPI0_CLK       NULL            /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_SPI0_CLK       NULL            /*!< No ALT_MFP2 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_I2S_BCLK        (1UL<<1)        /*!< GPC_MFP PC.1 setting for I2S_BCLK */
N#define SYS_ALT_MFP_PC1_I2S_BCLK        (1UL<<6)        /*!< ALT_MFP PC.1 setting for I2S_BCLK */
N#define SYS_ALT_MFP1_PC1_I2S_BCLK       NULL            /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_I2S_BCLK       NULL            /*!< No ALT_MFP2 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_Msk             (1UL<<1)        /*!< GPC_MFP PC.1 mask */
N#define SYS_ALT_MFP_PC1_Msk             (1UL<<6)        /*!< ALT_MFP PC.1 mask */
N
N//PC.2
N#define SYS_GPC_MFP_PC2_GPIO            0x00000000UL    /*!< GPC_MFP PC.2 setting for GPIO */
N#define SYS_ALT_MFP_PC2_GPIO            0x00000000UL    /*!< ALT_MFP PC.2 setting for GPIO */
N#define SYS_ALT_MFP1_PC2_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_SPI0_MISO0      (1UL<<2)        /*!< GPC_MFP PC.2 setting for SPI0_MISO0 */
N#define SYS_ALT_MFP_PC2_SPI0_MISO0      0x00000000UL    /*!< ALT_MFP PC.2 setting for SPI0_MISO0 */
N#define SYS_ALT_MFP1_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP2 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_I2S_DI          (1UL<<2)        /*!< GPC_MFP PC.2 setting for I2S_DI */
N#define SYS_ALT_MFP_PC2_I2S_DI          (1UL<<7)        /*!< ALT_MFP PC.2 setting for I2S_DI */
N#define SYS_ALT_MFP1_PC2_I2S_DI         NULL            /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_I2S_DI         NULL            /*!< No ALT_MFP2 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_Msk             (1UL<<2)        /*!< GPC_MFP PC.2 mask */
N#define SYS_ALT_MFP_PC2_Msk             (1UL<<7)        /*!< ALT_MFP PC.2 mask */
N
N//PC.3
N#define SYS_GPC_MFP_PC3_GPIO            0x00000000UL    /*!< GPC_MFP PC.3 setting for GPIO */
N#define SYS_ALT_MFP_PC3_GPIO            0x00000000UL    /*!< ALT_MFP PC.3 setting for GPIO */
N#define SYS_ALT_MFP1_PC3_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_SPI0_MOSI0      (1UL<<3)        /*!< GPC_MFP PC.3 setting for SPI0_MOSI0 */
N#define SYS_ALT_MFP_PC3_SPI0_MOSI0      0x00000000UL    /*!< ALT_MFP PC.3 setting for SPI0_MOSI0 */
N#define SYS_ALT_MFP1_PC3_SPI0_MOSI0     NULL            /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_SPI0_MOSI0     NULL            /*!< No ALT_MFP2 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_I2S_DO          (1UL<<3)        /*!< GPC_MFP PC.3 setting for I2S_DO */
N#define SYS_ALT_MFP_PC3_I2S_DO          (1UL<<8)        /*!< ALT_MFP PC.3 setting for I2S_DO */
N#define SYS_ALT_MFP1_PC3_I2S_DO         NULL            /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_I2S_DO         NULL            /*!< No ALT_MFP2 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_Msk             (1UL<<3)        /*!< GPC_MFP PC.3 mask */
N#define SYS_ALT_MFP_PC3_Msk             (1UL<<8)        /*!< ALT_MFP PC.3 mask */
N
N//PC.4
N#define SYS_GPC_MFP_PC4_GPIO            0x00000000UL    /*!< GPC_MFP PC.4 setting for GPIO */
N#define SYS_ALT_MFP_PC4_GPIO            NULL            /*!< No ALT_MFP setting for PC.4 */
N#define SYS_ALT_MFP1_PC4_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.4 */
N#define SYS_ALT_MFP2_PC4_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.4 */
N
N#define SYS_GPC_MFP_PC4_SPI0_MISO1      (1UL<<4)        /*!< GPC_MFP PC.4 setting for SPI0_MISO1 */
N#define SYS_ALT_MFP_PC4_SPI0_MISO1      NULL            /*!< No ALT_MFP setting for PC.4 */
N#define SYS_ALT_MFP1_PC4_SPI0_MISO1     NULL            /*!< No ALT_MFP1 setting for PC.4 */
N#define SYS_ALT_MFP2_PC4_SPI0_MISO1     NULL            /*!< No ALT_MFP2 setting for PC.4 */
N
N#define SYS_GPC_MFP_PC4_Msk             (1UL<<4)        /*!< GPC_MFP PC.4 mask */
N
N//PC.5
N#define SYS_GPC_MFP_PC5_GPIO            0x00000000UL    /*!< GPC_MFP PC.5 setting for GPIO */
N#define SYS_ALT_MFP_PC5_GPIO            NULL            /*!< No ALT_MFP setting for PC.5 */
N#define SYS_ALT_MFP1_PC5_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.5 */
N#define SYS_ALT_MFP2_PC5_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.5 */
N
N#define SYS_GPC_MFP_PC5_SPI0_MOSI1      (1UL<<5)        /*!< GPC_MFP PC.5 setting for SPI0_MOSI1 */
N#define SYS_ALT_MFP_PC5_SPI0_MOSI1      NULL            /*!< No ALT_MFP setting for PC.5 */
N#define SYS_ALT_MFP1_PC5_SPI0_MOSI1     NULL            /*!< No ALT_MFP1 setting for PC.5 */
N#define SYS_ALT_MFP2_PC5_SPI0_MOSI1     NULL            /*!< No ALT_MFP2 setting for PC.5 */
N
N#define SYS_GPC_MFP_PC5_Msk             (1UL<<5)        /*!< GPC_MFP PC.5 mask */
N
N//PC.6
N#define SYS_GPC_MFP_PC6_GPIO            0x00000000UL    /*!< GPC_MFP PC.6 setting for GPIO */
N#define SYS_ALT_MFP_PC6_GPIO            0x00000000UL    /*!< ALT_MFP PC.6 setting for GPIO */
N#define SYS_ALT_MFP1_PC6_GPIO           0x00000000UL    /*!< ALT_MFP1 PC.6 setting for GPIO */
N#define SYS_ALT_MFP2_PC6_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_ACMP0_P         (1UL<<6)        /*!< GPC_MFP PC.6 setting for ACMP0_P */
N#define SYS_ALT_MFP_PC6_ACMP0_P         0x00000000UL    /*!< ALT_MFP PC.6 setting for ACMP0_P */
N#define SYS_ALT_MFP1_PC6_ACMP0_P        0x00000000UL    /*!< ALT_MFP1 PC.6 setting for ACMP0_P */
N#define SYS_ALT_MFP2_PC6_ACMP0_P        NULL            /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_SC0_CD          (1UL<<6)        /*!< GPC_MFP PC.6 setting for SC0_CD */
N#define SYS_ALT_MFP_PC6_SC0_CD          0x00000000UL    /*!< ALT_MFP PC.6 setting for SC0_CD */
N#define SYS_ALT_MFP1_PC6_SC0_CD         (1UL<<4)        /*!< ALT_MFP1 PC.6 setting for SC0_CD */
N#define SYS_ALT_MFP2_PC6_SC0_CD         NULL            /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_EBI_AD4         (1UL<<6)        /*!< GPC_MFP PC.6 setting for EBI_AD4 */    
N#define SYS_ALT_MFP_PC6_EBI_AD4         (1UL<<11)       /*!< ALT_MFP PC.6 setting for EBI_AD4 */
N#define SYS_ALT_MFP1_PC6_EBI_AD4        0x00000000UL    /*!< ALT_MFP1 PC.6 setting for EBI_AD4 */ 
N#define SYS_ALT_MFP2_PC6_EBI_AD4        NULL            /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_Msk             (1UL<<6)        /*!< GPC_MFP PC.6 mask */
N#define SYS_ALT_MFP_PC6_Msk             (1UL<<11)       /*!< ALT_MFP PC.6 mask */ 
N#define SYS_ALT_MFP1_PC6_Msk            (1UL<<4)        /*!< ALT_MFP1 PC.6 mask */
N
N//PC.7
N#define SYS_GPC_MFP_PC7_GPIO            0x00000000UL    /*!< GPC_MFP PC.7 setting for GPIO */
N#define SYS_ALT_MFP_PC7_GPIO            0x00000000UL    /*!< ALT_MFP PC.7 setting for GPIO */
N#define SYS_ALT_MFP1_PC7_GPIO           0x00000000UL    /*!< ALT_MFP1 PC.7 setting for GPIO */
N#define SYS_ALT_MFP2_PC7_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_ACMP0_N         (1UL<<7)        /*!< GPC_MFP PC.7 setting for ACMP0_N */
N#define SYS_ALT_MFP_PC7_ACMP0_N         0x00000000UL    /*!< ALT_MFP PC.7 setting for ACMP0_N */
N#define SYS_ALT_MFP1_PC7_ACMP0_N        0x00000000UL    /*!< ALT_MFP1 PC.7 setting for ACMP0_N */
N#define SYS_ALT_MFP2_PC7_ACMP0_N        NULL            /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_SC1_CD          (1UL<<7)        /*!< GPC_MFP PC.7 setting for SC1_CD */
N#define SYS_ALT_MFP_PC7_SC1_CD          0x00000000UL    /*!< ALT_MFP PC.7 setting for SC1_CD */
N#define SYS_ALT_MFP1_PC7_SC1_CD         (1UL<<9)        /*!< ALT_MFP1 PC.7 setting for SC1_CD */
N#define SYS_ALT_MFP2_PC7_SC1_CD         NULL            /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_EBI_AD5         (1UL<<7)        /*!< GPC_MFP PC.7 setting for EBI_AD5 */    
N#define SYS_ALT_MFP_PC7_EBI_AD5         (1UL<<11)       /*!< ALT_MFP PC.7 setting for EBI_AD5 */
N#define SYS_ALT_MFP1_PC7_EBI_AD5        0x00000000UL    /*!< ALT_MFP1 PC.7 setting for EBI_AD5 */ 
N#define SYS_ALT_MFP2_PC7_EBI_AD5        NULL            /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_Msk             (1UL<<7)        /*!< GPC_MFP PC.7 mask */
N#define SYS_ALT_MFP_PC7_Msk             (1UL<<11)       /*!< ALT_MFP PC.7 mask */ 
N#define SYS_ALT_MFP1_PC7_Msk            (1UL<<9)        /*!< ALT_MFP1 PC.7 mask */
N
N//PC.8
N#define SYS_GPC_MFP_PC8_GPIO            0x00000000UL    /*!< GPC_MFP PC.8 setting for GPIO */
N#define SYS_ALT_MFP_PC8_GPIO            0x00000000UL    /*!< ALT_MFP PC.8 setting for GPIO */
N#define SYS_ALT_MFP1_PC8_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_SPI1_SS0        (1UL<<8)        /*!< GPC_MFP PC.8 setting for SPI1_SS0 */
N#define SYS_ALT_MFP_PC8_SPI1_SS0        0x00000000UL    /*!< ALT_MFP PC.8 setting for SPI1_SS0 */
N#define SYS_ALT_MFP1_PC8_SPI1_SS0       NULL            /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_SPI1_SS0       NULL            /*!< No ALT_MFP2 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_EBI_MCLK        (1UL<<8)                /*!< GPC_MFP PC.8 setting for EBI_MCLK */    
N#define SYS_ALT_MFP_PC8_EBI_MCLK        ((1UL<<11) | (1UL<<12)) /*!< ALT_MFP PC.8 setting for EBI_MCLK */
N#define SYS_ALT_MFP1_PC8_EBI_MCLK       NULL                    /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_EBI_MCLK       NULL                    /*!< No ALT_MFP2 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_Msk             (1UL<<8)                /*!< GPC_MFP PC.8 mask */
N#define SYS_ALT_MFP_PC8_Msk             ((1UL<<11) | (1UL<<12)) /*!< ALT_MFP PC.8 mask */ 
N
N//PC.9
N#define SYS_GPC_MFP_PC9_GPIO            0x00000000UL    /*!< GPC_MFP PC.9 setting for GPIO */
N#define SYS_ALT_MFP_PC9_GPIO            NULL            /*!< No ALT_MFP setting for PC.9 */
N#define SYS_ALT_MFP1_PC9_GPIO           NULL            /*!< No ALT_MFP1 setting for PC.9 */
N#define SYS_ALT_MFP2_PC9_GPIO           NULL            /*!< No ALT_MFP2 setting for PC.9 */
N
N#define SYS_GPC_MFP_PC9_SPI1_CLK        (1UL<<9)        /*!< GPC_MFP PC.9 setting for SPI1_CLK */
N#define SYS_ALT_MFP_PC9_SPI1_CLK        NULL            /*!< No ALT_MFP setting for PC.9 */
N#define SYS_ALT_MFP1_PC9_SPI1_CLK       NULL            /*!< No ALT_MFP1 setting for PC.9 */
N#define SYS_ALT_MFP2_PC9_SPI1_CLK       NULL            /*!< No ALT_MFP2 setting for PC.9 */
N
N#define SYS_GPC_MFP_PC9_Msk             (1UL<<9)        /*!< GPC_MFP PC.9 mask */
N
N//PC.10
N#define SYS_GPC_MFP_PC10_GPIO           0x00000000UL    /*!< GPC_MFP PC.10 setting for GPIO */
N#define SYS_ALT_MFP_PC10_GPIO           NULL            /*!< No ALT_MFP setting for PC.10 */
N#define SYS_ALT_MFP1_PC10_GPIO          NULL            /*!< No ALT_MFP1 setting for PC.10 */
N#define SYS_ALT_MFP2_PC10_GPIO          NULL            /*!< No ALT_MFP2 setting for PC.10 */
N
N#define SYS_GPC_MFP_PC10_SPI1_MISO0     (1UL<<10)       /*!< GPC_MFP PC.10 setting for SPI1_MISO0 */
N#define SYS_ALT_MFP_PC10_SPI1_MISO0     NULL            /*!< No ALT_MFP setting for PC.10 */
N#define SYS_ALT_MFP1_PC10_SPI1_MISO0    NULL            /*!< No ALT_MFP1 setting for PC.10 */
N#define SYS_ALT_MFP2_PC10_SPI1_MISO0    NULL            /*!< No ALT_MFP2 setting for PC.10 */
N
N#define SYS_GPC_MFP_PC10_Msk            (1UL<<10)       /*!< GPC_MFP PC.10 mask */
N
N//PC.11
N#define SYS_GPC_MFP_PC11_GPIO           0x00000000UL    /*!< GPC_MFP PC.11 setting for GPIO */
N#define SYS_ALT_MFP_PC11_GPIO           NULL            /*!< No ALT_MFP setting for PC.11 */
N#define SYS_ALT_MFP1_PC11_GPIO          NULL            /*!< No ALT_MFP1 setting for PC.11 */
N#define SYS_ALT_MFP2_PC11_GPIO          NULL            /*!< No ALT_MFP2 setting for PC.11 */
N
N#define SYS_GPC_MFP_PC11_SPI1_MOSI0     (1UL<<11)       /*!< GPC_MFP PC.11 setting for SPI1_MOSI0 */
N#define SYS_ALT_MFP_PC11_SPI1_MOSI0     NULL            /*!< No ALT_MFP setting for PC.11 */
N#define SYS_ALT_MFP1_PC11_SPI1_MOSI0    NULL            /*!< No ALT_MFP1 setting for PC.11 */
N#define SYS_ALT_MFP2_PC11_SPI1_MOSI0    NULL            /*!< No ALT_MFP2 setting for PC.11 */
N
N#define SYS_GPC_MFP_PC11_Msk            (1UL<<11)       /*!< GPC_MFP PC.11 mask */
N
N
N//PC.12
N#define SYS_GPC_MFP_PC12_GPIO           0x00000000UL    /*!< GPC_MFP PC.12 setting for GPIO */
N#define SYS_ALT_MFP_PC12_GPIO           NULL            /*!< No ALT_MFP setting for PC.12 */
N#define SYS_ALT_MFP1_PC12_GPIO          NULL            /*!< No ALT_MFP1 setting for PC.12 */
N#define SYS_ALT_MFP2_PC12_GPIO          NULL            /*!< No ALT_MFP2 setting for PC.12 */
N
N#define SYS_GPC_MFP_PC12_SPI1_MISO1      (1UL<<12)      /*!< GPC_MFP PC.12 setting for SPI1_MISO1 */
N#define SYS_ALT_MFP_PC12_SPI1_MISO1      NULL           /*!< No ALT_MFP setting for PC.12 */
N#define SYS_ALT_MFP1_PC12_SPI1_MISO1     NULL           /*!< No ALT_MFP1 setting for PC.12 */
N#define SYS_ALT_MFP2_PC12_SPI1_MISO1     NULL           /*!< No ALT_MFP2 setting for PC.12 */
N
N#define SYS_GPC_MFP_PC12_Msk            (1UL<<12)       /*!< GPC_MFP PC.12 mask */
N
N//PC.13
N#define SYS_GPC_MFP_PC13_GPIO           0x00000000UL    /*!< GPC_MFP PC.13 setting for GPIO */
N#define SYS_ALT_MFP_PC13_GPIO           NULL            /*!< No ALT_MFP setting for PC.13 */
N#define SYS_ALT_MFP1_PC13_GPIO          NULL            /*!< No ALT_MFP1 setting for PC.13 */
N#define SYS_ALT_MFP2_PC13_GPIO          NULL            /*!< No ALT_MFP2 setting for PC.13 */
N
N#define SYS_GPC_MFP_PC13_SPI1_MOSI1     (1UL<<13)       /*!< GPC_MFP PC.13 setting for SPI1_MOSI1 */
N#define SYS_ALT_MFP_PC13_SPI1_MOSI1     NULL            /*!< No ALT_MFP setting for PC.13 */
N#define SYS_ALT_MFP1_PC13_SPI1_MOSI1    NULL            /*!< No ALT_MFP1 setting for PC.13 */
N#define SYS_ALT_MFP2_PC13_SPI1_MOSI1    NULL            /*!< No ALT_MFP2 setting for PC.13 */
N
N#define SYS_GPC_MFP_PC13_Msk            (1UL<<13)       /*!< GPC_MFP PC.13 mask */
N
N//PC.14
N#define SYS_GPC_MFP_PC14_GPIO           0x00000000UL    /*!< GPC_MFP PC.14 setting for GPIO */
N#define SYS_ALT_MFP_PC14_GPIO           0x00000000UL    /*!< ALT_MFP PC.14 setting for GPIO */
N#define SYS_ALT_MFP1_PC14_GPIO          NULL            /*!< No ALT_MFP1 setting for PC.14 */
N#define SYS_ALT_MFP2_PC14_GPIO          NULL            /*!< No ALT_MFP2 setting for PC.14 */
N
N#define SYS_GPC_MFP_PC14_ACMP1_P        (1UL<<14)       /*!< GPC_MFP PC.14 setting for ACMP1_P */
N#define SYS_ALT_MFP_PC14_ACMP1_P        0x00000000UL    /*!< ALT_MFP PC.14 setting for ACMP1_P */
N#define SYS_ALT_MFP1_PC14_ACMP1_P       NULL            /*!< No ALT_MFP1 setting for PC.14 */
N#define SYS_ALT_MFP2_PC14_ACMP1_P       NULL            /*!< No ALT_MFP2 setting for PC.14 */
N
N#define SYS_GPC_MFP_PC14_EBI_AD2        (1UL<<14)       /*!< GPC_MFP PC.14 setting for EBI_AD2 */      
N#define SYS_ALT_MFP_PC14_EBI_AD2        (1UL<<11)       /*!< ALT_MFP PC.14 setting for EBI_AD2 */
N#define SYS_ALT_MFP1_PC14_EBI_AD2       NULL            /*!< No ALT_MFP1 setting for PC.14 */
N#define SYS_ALT_MFP2_PC14_EBI_AD2       NULL            /*!< No ALT_MFP2 setting for PC.14 */
N
N#define SYS_GPC_MFP_PC14_Msk            (1UL<<14)       /*!< GPC_MFP PC.14 mask */
N#define SYS_ALT_MFP_PC14_Msk            (1UL<<11)       /*!< ALT_MFP PC.14 mask */ 
N
N//PC.15
N#define SYS_GPC_MFP_PC15_GPIO           0x00000000UL    /*!< GPC_MFP PC.15 setting for GPIO */
N#define SYS_ALT_MFP_PC15_GPIO           0x00000000UL    /*!< ALT_MFP PC.15 setting for GPIO */
N#define SYS_ALT_MFP1_PC15_GPIO          NULL            /*!< No ALT_MFP1 setting for PC.15 */
N#define SYS_ALT_MFP2_PC15_GPIO          NULL            /*!< No ALT_MFP2 setting for PC.15 */
N
N#define SYS_GPC_MFP_PC15_ACMP1_N        (1UL<<15)       /*!< GPC_MFP PC.15 setting for ACMP1_N */
N#define SYS_ALT_MFP_PC15_ACMP1_N        0x00000000UL    /*!< ALT_MFP PC.15 setting for ACMP1_N */
N#define SYS_ALT_MFP1_PC15_ACMP1_N       NULL            /*!< No ALT_MFP1 setting for PC.15 */
N#define SYS_ALT_MFP2_PC15_ACMP1_N       NULL            /*!< No ALT_MFP2 setting for PC.15 */
N
N#define SYS_GPC_MFP_PC15_EBI_AD3        (1UL<<15)       /*!< GPB_MFP PC.15 setting for EBI_AD3 */      
N#define SYS_ALT_MFP_PC15_EBI_AD3        (1UL<<11)       /*!< ALT_MFP PC.15 setting for EBI_AD3 */
N#define SYS_ALT_MFP1_PC15_EBI_AD3       NULL            /*!< No ALT_MFP1 setting for PC.15 */
N#define SYS_ALT_MFP2_PC15_EBI_AD3       NULL            /*!< No ALT_MFP2 setting for PC.15 */
N
N#define SYS_GPC_MFP_PC15_Msk            (1UL<<15)       /*!< GPC_MFP PC.15 mask */
N#define SYS_ALT_MFP_PC15_Msk            (1UL<<11)       /*!< ALT_MFP PC.15 mask */ 
N
N//PD.0
N#define SYS_GPD_MFP_PD0_GPIO            0x00000000UL    /*!< GPD_MFP PD.0 setting for GPIO */
N#define SYS_ALT_MFP_PD0_GPIO            NULL            /*!< No ALT_MFP setting for PD.0 */
N#define SYS_ALT_MFP1_PD0_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.0 */
N#define SYS_ALT_MFP2_PD0_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.0 */
N
N#define SYS_GPD_MFP_PD0_SPI2_SS0        (1UL<<0)        /*!< GPD_MFP PD.0 setting for SPI2_SS0 */
N#define SYS_ALT_MFP_PD0_SPI2_SS0        NULL            /*!< No ALT_MFP setting for PD.0 */
N#define SYS_ALT_MFP1_PD0_SPI2_SS0       NULL            /*!< No ALT_MFP1 setting for PD.0 */
N#define SYS_ALT_MFP2_PD0_SPI2_SS0       NULL            /*!< No ALT_MFP2 setting for PD.0 */
N
N#define SYS_GPD_MFP_PD0_Msk             (1UL<<0)        /*!< GPD_MFP PD.0 mask */
N
N//PD.1
N#define SYS_GPD_MFP_PD1_GPIO            0x00000000UL    /*!< GPD_MFP PD.1 setting for GPIO */
N#define SYS_ALT_MFP_PD1_GPIO            NULL            /*!< No ALT_MFP setting for PD.1 */
N#define SYS_ALT_MFP1_PD1_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.1 */
N#define SYS_ALT_MFP2_PD1_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.1 */
N
N#define SYS_GPD_MFP_PD1_SPI2_CLK        (1UL<<1)        /*!< GPD_MFP PD.1 setting for SPI2_CLK */
N#define SYS_ALT_MFP_PD1_SPI2_CLK        NULL            /*!< No ALT_MFP setting for PD.1 */
N#define SYS_ALT_MFP1_PD1_SPI2_CLK       NULL            /*!< No ALT_MFP1 setting for PD.1 */
N#define SYS_ALT_MFP2_PD1_SPI2_CLK       NULL            /*!< No ALT_MFP2 setting for PD.1 */
N
N#define SYS_GPD_MFP_PD1_Msk             (1UL<<1)        /*!< GPD_MFP PD.1 mask */
N    
N//PD.2
N#define SYS_GPD_MFP_PD2_GPIO            0x00000000UL    /*!< GPD_MFP PD.2 setting for GPIO */
N#define SYS_ALT_MFP_PD2_GPIO            NULL            /*!< No ALT_MFP setting for PD.2 */
N#define SYS_ALT_MFP1_PD2_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.2 */
N#define SYS_ALT_MFP2_PD2_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.2 */
N
N#define SYS_GPD_MFP_PD2_SPI2_MISO0      (1UL<<2)        /*!< GPD_MFP PD.2 setting for SPI2_MISO0 */
N#define SYS_ALT_MFP_PD2_SPI2_MISO0      NULL            /*!< No ALT_MFP setting for PD.2 */
N#define SYS_ALT_MFP1_PD2_SPI2_MISO0     NULL            /*!< No ALT_MFP1 setting for PD.2 */
N#define SYS_ALT_MFP2_PD2_SPI2_MISO0     NULL            /*!< No ALT_MFP2 setting for PD.2 */
N
N#define SYS_GPD_MFP_PD2_Msk             (1UL<<2)        /*!< GPD_MFP PD.2 mask */
N
N//PD.3
N#define SYS_GPD_MFP_PD3_GPIO            0x00000000UL    /*!< GPD_MFP PD.3 setting for GPIO */
N#define SYS_ALT_MFP_PD3_GPIO            NULL            /*!< No ALT_MFP setting for PD.3 */
N#define SYS_ALT_MFP1_PD3_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.3 */
N#define SYS_ALT_MFP2_PD3_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.3 */
N
N#define SYS_GPD_MFP_PD3_SPI2_MOSI0      (1UL<<3)        /*!< GPD_MFP PD.3 setting for SPI2_MOSI0 */
N#define SYS_ALT_MFP_PD3_SPI2_MOSI0      NULL            /*!< No ALT_MFP setting for PD.3 */
N#define SYS_ALT_MFP1_PD3_SPI2_MOSI0     NULL            /*!< No ALT_MFP1 setting for PD.3 */
N#define SYS_ALT_MFP2_PD3_SPI2_MOSI0     NULL            /*!< No ALT_MFP2 setting for PD.3 */
N
N#define SYS_GPD_MFP_PD3_Msk             (1UL<<3)        /*!< GPD_MFP PD.3 mask */
N
N//PD.4
N#define SYS_GPD_MFP_PD4_GPIO            0x00000000UL    /*!< GPD_MFP PD.4 setting for GPIO */
N#define SYS_ALT_MFP_PD4_GPIO            NULL            /*!< No ALT_MFP setting for PD.4 */
N#define SYS_ALT_MFP1_PD4_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.4 */
N#define SYS_ALT_MFP2_PD4_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.4 */
N
N#define SYS_GPD_MFP_PD4_SPI2_MISO1      (1UL<<4)        /*!< GPD_MFP PD.4 setting for SPI2_MISO1 */
N#define SYS_ALT_MFP_PD4_SPI2_MISO1      NULL            /*!< No ALT_MFP setting for PD.4 */
N#define SYS_ALT_MFP1_PD4_SPI2_MISO1     NULL            /*!< No ALT_MFP1 setting for PD.4 */
N#define SYS_ALT_MFP2_PD4_SPI2_MISO1     NULL            /*!< No ALT_MFP2 setting for PD.4 */
N
N#define SYS_GPD_MFP_PD4_Msk             (1UL<<4)        /*!< GPD_MFP PD.4 mask */
N
N//PD.5
N#define SYS_GPD_MFP_PD5_GPIO            0x00000000UL    /*!< GPD_MFP PD.5 setting for GPIO */
N#define SYS_ALT_MFP_PD5_GPIO            NULL            /*!< No ALT_MFP setting for PD.5 */
N#define SYS_ALT_MFP1_PD5_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.5 */
N#define SYS_ALT_MFP2_PD5_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.5 */
N
N#define SYS_GPD_MFP_PD5_SPI2_MOSI1      (1UL<<5)        /*!< GPD_MFP PD.5 setting for SPI2_MOSI1 */
N#define SYS_ALT_MFP_PD5_SPI2_MOSI1      NULL            /*!< No ALT_MFP setting for PD.5 */
N#define SYS_ALT_MFP1_PD5_SPI2_MOSI1     NULL            /*!< No ALT_MFP1 setting for PD.5 */
N#define SYS_ALT_MFP2_PD5_SPI2_MOSI1     NULL            /*!< No ALT_MFP2 setting for PD.5 */
N
N#define SYS_GPD_MFP_PD5_Msk             (1UL<<5)        /*!< GPD_MFP PD.5 mask */
N
N//PD.8
N#define SYS_GPD_MFP_PD8_GPIO            0x00000000UL    /*!< GPD_MFP PD.8 setting for GPIO */
N#define SYS_ALT_MFP_PD8_GPIO            NULL            /*!< No ALT_MFP setting for PD.8 */
N#define SYS_ALT_MFP1_PD8_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.8 */
N#define SYS_ALT_MFP2_PD8_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.8 */
N
N#define SYS_GPD_MFP_PD8_SPI3_SS0        (1UL<<8)        /*!< GPD_MFP PD.8 setting for SPI3_SS0 */
N#define SYS_ALT_MFP_PD8_SPI3_SS0        NULL            /*!< No ALT_MFP setting for PD.8 */
N#define SYS_ALT_MFP1_PD8_SPI3_SS0       NULL            /*!< No ALT_MFP1 setting for PD.8 */
N#define SYS_ALT_MFP2_PD8_SPI3_SS0       NULL            /*!< No ALT_MFP2 setting for PD.8 */
N
N#define SYS_GPD_MFP_PD8_Msk             (1UL<<8)        /*!< GPD_MFP PD.8 mask */
N
N//PD.9
N#define SYS_GPD_MFP_PD9_GPIO            0x00000000UL    /*!< GPD_MFP PD.9 setting for GPIO */
N#define SYS_ALT_MFP_PD9_GPIO            NULL            /*!< No ALT_MFP setting for PD.9 */
N#define SYS_ALT_MFP1_PD9_GPIO           NULL            /*!< No ALT_MFP1 setting for PD.9 */
N#define SYS_ALT_MFP2_PD9_GPIO           NULL            /*!< No ALT_MFP2 setting for PD.9 */
N
N#define SYS_GPD_MFP_PD9_SPI3_CLK        (1UL<<9)        /*!< GPD_MFP PD.9 setting for SPI3_CLK */
N#define SYS_ALT_MFP_PD9_SPI3_CLK        NULL            /*!< No ALT_MFP setting for PD.9 */
N#define SYS_ALT_MFP1_PD9_SPI3_CLK       NULL            /*!< No ALT_MFP1 setting for PD.9 */
N#define SYS_ALT_MFP2_PD9_SPI3_CLK       NULL            /*!< No ALT_MFP2 setting for PD.9 */
N
N#define SYS_GPD_MFP_PD9_Msk             (1UL<<9)        /*!< GPD_MFP PD.9 mask */
N
N//PD.10
N#define SYS_GPD_MFP_PD10_GPIO           0x00000000UL    /*!< GPD_MFP PD.10 setting for GPIO */
N#define SYS_ALT_MFP_PD10_GPIO           NULL            /*!< No ALT_MFP setting for PD.10 */
N#define SYS_ALT_MFP1_PD10_GPIO          NULL            /*!< No ALT_MFP1 setting for PD.10 */
N#define SYS_ALT_MFP2_PD10_GPIO          NULL            /*!< No ALT_MFP2 setting for PD.10 */
N
N#define SYS_GPD_MFP_PD10_SPI3_MISO0     (1UL<<10)       /*!< GPD_MFP PD.10 setting for SPI3_MISO0 */
N#define SYS_ALT_MFP_PD10_SPI3_MISO0     NULL            /*!< No ALT_MFP setting for PD.10 */
N#define SYS_ALT_MFP1_PD10_SPI3_MISO0    NULL            /*!< No ALT_MFP1 setting for PD.10 */
N#define SYS_ALT_MFP2_PD10_SPI3_MISO0    NULL            /*!< No ALT_MFP2 setting for PD.10 */
N
N#define SYS_GPD_MFP_PD10_Msk            (1UL<<10)       /*!< GPD_MFP PD.10 mask */
N
N//PD.11
N#define SYS_GPD_MFP_PD11_GPIO           0x00000000UL    /*!< GPD_MFP PD.11 setting for GPIO */
N#define SYS_ALT_MFP_PD11_GPIO           NULL            /*!< No ALT_MFP setting for PD.11 */
N#define SYS_ALT_MFP1_PD11_GPIO          NULL            /*!< No ALT_MFP1 setting for PD.11 */
N#define SYS_ALT_MFP2_PD11_GPIO          NULL            /*!< No ALT_MFP2 setting for PD.11 */
N
N#define SYS_GPD_MFP_PD11_SPI3_MOSI0     (1UL<<11)       /*!< GPD_MFP PD.11 setting for SPI3_MOSI0 */
N#define SYS_ALT_MFP_PD11_SPI3_MOSI0     NULL            /*!< No ALT_MFP setting for PD.11 */
N#define SYS_ALT_MFP1_PD11_SPI3_MOSI0    NULL            /*!< No ALT_MFP1 setting for PD.11 */
N#define SYS_ALT_MFP2_PD11_SPI3_MOSI0    NULL            /*!< No ALT_MFP2 setting for PD.11 */
N
N#define SYS_GPD_MFP_PD11_Msk            (1UL<<11)       /*!< GPD_MFP PD.11 mask */
N
N//PD.12
N#define SYS_GPD_MFP_PD12_GPIO           0x00000000UL    /*!< GPD_MFP PD.12 setting for GPIO */
N#define SYS_ALT_MFP_PD12_GPIO           NULL            /*!< No ALT_MFP setting for PD.12 */
N#define SYS_ALT_MFP1_PD12_GPIO          NULL            /*!< No ALT_MFP1 setting for PD.12 */
N#define SYS_ALT_MFP2_PD12_GPIO          NULL            /*!< No ALT_MFP2 setting for PD.12 */
N
N#define SYS_GPD_MFP_PD12_SPI3_MISO1     (1UL<<12)       /*!< GPD_MFP PD.12 setting for SPI3_MISO1 */
N#define SYS_ALT_MFP_PD12_SPI3_MISO1     NULL            /*!< No ALT_MFP setting for PD.12 */
N#define SYS_ALT_MFP1_PD12_SPI3_MISO1    NULL            /*!< No ALT_MFP1 setting for PD.12 */
N#define SYS_ALT_MFP2_PD12_SPI3_MISO1    NULL            /*!< No ALT_MFP2 setting for PD.12 */
N
N#define SYS_GPD_MFP_PD12_Msk            (1UL<<12)       /*!< GPD_MFP PD.12 mask */
N
N//PD.13
N#define SYS_GPD_MFP_PD13_GPIO           0x00000000UL    /*!< GPD_MFP PD.13 setting for GPIO */
N#define SYS_ALT_MFP_PD13_GPIO           NULL            /*!< No ALT_MFP setting for PD.13 */
N#define SYS_ALT_MFP1_PD13_GPIO          NULL            /*!< No ALT_MFP1 setting for PD.13 */
N#define SYS_ALT_MFP2_PD13_GPIO          NULL            /*!< No ALT_MFP2 setting for PD.13 */
N
N#define SYS_GPD_MFP_PD13_SPI3_MOSI1     (1UL<<13)       /*!< GPD_MFP PD.13 setting for SPI3_MOSI1 */
N#define SYS_ALT_MFP_PD13_SPI3_MOSI1     NULL            /*!< No ALT_MFP setting for PD.13 */
N#define SYS_ALT_MFP1_PD13_SPI3_MOSI1    NULL            /*!< No ALT_MFP1 setting for PD.13 */
N#define SYS_ALT_MFP2_PD13_SPI3_MOSI1    NULL            /*!< No ALT_MFP2 setting for PD.13 */
N
N#define SYS_GPD_MFP_PD13_Msk            (1UL<<13)       /*!< GPD_MFP PD.13 mask */
N
N//PD.14
N#define SYS_GPD_MFP_PD14_GPIO           0x00000000UL    /*!< GPD_MFP PD.14 setting for GPIO */
N#define SYS_ALT_MFP_PD14_GPIO           NULL            /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_GPIO          NULL            /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_GPIO          NULL            /*!< No ALT_MFP2 setting for PD.14 */
N
N#define SYS_GPD_MFP_PD14_UART2_RXD      (1UL<<14)       /*!< GPD_MFP PD.14 setting for UART2_RXD */
N#define SYS_ALT_MFP_PD14_UART2_RXD      NULL            /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_UART2_RXD     NULL            /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_UART2_RXD     NULL            /*!< No ALT_MFP2 setting for PD.14 */
N
N#define SYS_GPD_MFP_PD14_Msk            (1UL<<14)       /*!< GPD_MFP PD.14 mask */
N
N//PD.15
N#define SYS_GPD_MFP_PD15_GPIO           0x00000000UL    /*!< GPD_MFP PD.15 setting for GPIO */
N#define SYS_ALT_MFP_PD15_GPIO           NULL            /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_GPIO          NULL            /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_GPIO          NULL            /*!< No ALT_MFP2 setting for PD.15 */
N
N#define SYS_GPD_MFP_PD15_UART2_TXD       (1UL<<15)      /*!< GPD_MFP PD.15 setting for UART2_TXD */
N#define SYS_ALT_MFP_PD15_UART2_TXD       NULL           /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_UART2_TXD      NULL           /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_UART2_TXD      NULL           /*!< No ALT_MFP2 setting for PD.15 */
N
N#define SYS_GPD_MFP_PD15_Msk            (1UL<<15)       /*!< GPD_MFP PD.15 mask */
N
N//PE.0
N#define SYS_GPE_MFP_PE0_GPIO            0x00000000UL    /*!< GPE_MFP PE.0 setting for GPIO */
N#define SYS_ALT_MFP_PE0_GPIO            NULL            /*!< No ALT_MFP setting for PE.0 */
N#define SYS_ALT_MFP1_PE0_GPIO           NULL            /*!< No ALT_MFP1 setting for PE.0 */
N#define SYS_ALT_MFP2_PE0_GPIO           NULL            /*!< No ALT_MFP2 setting for PE.0 */
N
N#define SYS_GPE_MFP_PE0_PWM6            (1UL<<0)        /*!< GPE_MFP PE.0 setting for PWM6 */
N#define SYS_ALT_MFP_PE0_PWM6            NULL            /*!< No ALT_MFP setting for PE.0 */
N#define SYS_ALT_MFP1_PE0_PWM6           NULL            /*!< No ALT_MFP1 setting for PE.0 */
N#define SYS_ALT_MFP2_PE0_PWM6           NULL            /*!< No ALT_MFP2 setting for PE.0 */
N
N#define SYS_GPE_MFP_PE0_Msk             (1UL<<0)        /*!< GPE_MFP PE.0 mask */
N
N//PE.1
N#define SYS_GPE_MFP_PE1_GPIO            0x00000000UL    /*!< GPE_MFP PE.1 setting for GPIO */
N#define SYS_ALT_MFP_PE1_GPIO            NULL            /*!< No ALT_MFP setting for PE.1 */
N#define SYS_ALT_MFP1_PE1_GPIO           NULL            /*!< No ALT_MFP1 setting for PE.1 */
N#define SYS_ALT_MFP2_PE1_GPIO           NULL            /*!< No ALT_MFP2 setting for PE.1 */
N
N#define SYS_GPE_MFP_PE1_PWM7            (1UL<<1)        /*!< GPE_MFP PE.1 setting for PWM7 */
N#define SYS_ALT_MFP_PE1_PWM7            NULL            /*!< No ALT_MFP setting for PE.1 */
N#define SYS_ALT_MFP1_PE1_PWM7           NULL            /*!< No ALT_MFP1 setting for PE.1 */
N#define SYS_ALT_MFP2_PE1_PWM7           NULL            /*!< No ALT_MFP2 setting for PE.1 */
N
N#define SYS_GPE_MFP_PE1_Msk             (1UL<<1)        /*!< GPE_MFP PE.1 mask */
N
N//PE.5
N#define SYS_GPE_MFP_PE5_GPIO            0x00000000UL    /*!< GPE_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP_PE5_GPIO            0x00000000UL    /*!< ALT_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP1_PE5_GPIO           NULL            /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_GPIO           NULL            /*!< No ALT_MFP2 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_PWM5            (1UL<<5)        /*!< GPE_MFP PE.5 setting for PWM5 */
N#define SYS_ALT_MFP_PE5_PWM5            0x00000000UL    /*!< ALT_MFP PE.5 setting for PWM5 */
N#define SYS_ALT_MFP1_PE5_PWM5           NULL            /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_PWM5           NULL            /*!< No ALT_MFP2 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_TM1_EXT         (1UL<<5)        /*!< GPE_MFP PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP_PE5_TM1_EXT         (1UL<<25)       /*!< ALT_MFP PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP1_PE5_TM1_EXT        NULL            /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_TM1_EXT        NULL            /*!< No ALT_MFP2 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_Msk             (1UL<<5)        /*!< GPE_MFP PE.5 mask */
N#define SYS_ALT_MFP_PE5_Msk             (1UL<<25)       /*!< ALT_MFP PE.5 mask */
N
N//PF.0
N#define SYS_GPF_MFP_PF0_GPIO            0x00000000UL    /*!< GPF_MFP PF.0 setting for GPIO */
N#define SYS_ALT_MFP_PF0_GPIO            NULL            /*!< No ALT_MFP setting for PF.0 */
N#define SYS_ALT_MFP1_PF0_GPIO           NULL            /*!< No ALT_MFP1 setting for PF.0 */
N#define SYS_ALT_MFP2_PF0_GPIO           NULL            /*!< No ALT_MFP2 setting for PF.0 */
N
N#define SYS_GPF_MFP_PF0_XT1_OUT         (1UL<<0)        /*!< GPF_MFP PF.0 setting for XT1_OUT */
N#define SYS_ALT_MFP_PF0_XT1_OUT         NULL            /*!< No ALT_MFP setting for PF.0 */
N#define SYS_ALT_MFP1_PF0_XT1_OUT        NULL            /*!< No ALT_MFP1 setting for PF.0 */
N#define SYS_ALT_MFP2_PF0_XT1_OUT        NULL            /*!< No ALT_MFP2 setting for PF.0 */
N
N#define SYS_GPF_MFP_PF0_Msk             (1UL<<0)        /*!< GPF_MFP PF.0 mask */
N
N//PF.1
N#define SYS_GPF_MFP_PF1_GPIO            0x00000000UL    /*!< GPF_MFP PF.1 setting for GPIO */
N#define SYS_ALT_MFP_PF1_GPIO            NULL            /*!< No ALT_MFP setting for PF.1 */
N#define SYS_ALT_MFP1_PF1_GPIO           NULL            /*!< No ALT_MFP1 setting for PF.1 */
N#define SYS_ALT_MFP2_PF1_GPIO           NULL            /*!< No ALT_MFP2 setting for PF.1 */
N
N#define SYS_GPF_MFP_PF1_XT1_IN          (1UL<<1)        /*!< GPF_MFP PF.1 setting for XT1_IN */
N#define SYS_ALT_MFP_PF1_XT1_IN          NULL            /*!< No ALT_MFP setting for PF.1 */
N#define SYS_ALT_MFP1_PF1_XT1_IN         NULL            /*!< No ALT_MFP1 setting for PF.1 */
N#define SYS_ALT_MFP2_PF1_XT1_IN         NULL            /*!< No ALT_MFP2 setting for PF.1 */
N
N#define SYS_GPF_MFP_PF1_Msk             (1UL<<1)        /*!< GPF_MFP PF.1 mask */
N
N//PF.2
N#define SYS_GPF_MFP_PF2_GPIO            0x00000000UL    /*!< GPF_MFP PF.2 setting for GPIO */
N#define SYS_ALT_MFP_PF2_GPIO            NULL            /*!< No ALT_MFP setting for PF.2 */
N#define SYS_ALT_MFP1_PF2_GPIO           NULL            /*!< No ALT_MFP1 setting for PF.2 */
N#define SYS_ALT_MFP2_PF2_GPIO           NULL            /*!< No ALT_MFP2 setting for PF.2 */
N
N#define SYS_GPF_MFP_PF2_PS2_DAT         (1UL<<2)        /*!< GPF_MFP PF.2 setting for PS2_DAT */
N#define SYS_ALT_MFP_PF2_PS2_DAT         NULL            /*!< No ALT_MFP setting for PF.2 */
N#define SYS_ALT_MFP1_PF2_PS2_DAT        NULL            /*!< No ALT_MFP1 setting for PF.2 */
N#define SYS_ALT_MFP2_PF2_PS2_DAT        NULL            /*!< No ALT_MFP2 setting for PF.2 */
N
N#define SYS_GPF_MFP_PF2_Msk             (1UL<<2)        /*!< GPF_MFP PF.2 mask */
N
N//PF.3
N#define SYS_GPF_MFP_PF3_GPIO            0x00000000UL    /*!< GPF_MFP PF.3 setting for GPIO */
N#define SYS_ALT_MFP_PF3_GPIO            NULL            /*!< No ALT_MFP setting for PF.3 */
N#define SYS_ALT_MFP1_PF3_GPIO           NULL            /*!< No ALT_MFP1 setting for PF.3 */
N#define SYS_ALT_MFP2_PF3_GPIO           NULL            /*!< No ALT_MFP2 setting for PF.3 */
N
N#define SYS_GPF_MFP_PF3_PS2_CLK         (1UL<<3)        /*!< GPF_MFP PF.3 setting for PS2_CLK */
N#define SYS_ALT_MFP_PF3_PS2_CLK         NULL            /*!< No ALT_MFP setting for PF.3 */
N#define SYS_ALT_MFP1_PF3_PS2_CLK        NULL            /*!< No ALT_MFP1 setting for PF.3 */
N#define SYS_ALT_MFP2_PF3_PS2_CLK        NULL            /*!< No ALT_MFP2 setting for PF.3 */
N
N#define SYS_GPF_MFP_PF3_Msk             (1UL<<3)        /*!< GPF_MFP PF.3 mask */
N
N
N/*@}*/ /* end of group SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCR |= SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCR &= ~SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCR &= ~SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCR |= SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCR & SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD_VL setting or BOD_EN is 0.
N  * @retval     >=1 System voltage is lower than BOD_VL setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD_EN is 0, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCR & SYS_BODCR_BOD_OUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCR &= ~SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCR |= SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCR |= SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCR_BOD_VL_4_4V
N  *             - \ref SYS_BODCR_BOD_VL_3_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | (u32Level))
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_BOD_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_CPU_Msk)
N
N/**
N  * @brief      Get reset source is from Low-Voltage-Reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from Low-Voltage-Reset
N  * @retval     >=1 Previous reset source is from Low-Voltage-Reset
N  * @details    This macro get previous reset source is from Low-Voltage-Reset.   
N  */
N#define SYS_IS_LVR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_LVR_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_POR_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_RESET_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_SYS_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_WDT_Msk)
N
N/**
N  * @brief      Disable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Low-Voltage-Reset function.
N  */
N#define SYS_DISABLE_LVR()               (SYS->BODCR &= ~SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Enable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Low-Voltage-Reset function.
N  */
N#define SYS_ENABLE_LVR()                (SYS->BODCR |= SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCR = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCR = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including:
N  *             - \ref SYS_RSTSRC_RSTS_CPU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_SYS_Msk
N  *             - \ref SYS_RSTSRC_RSTS_BOD_Msk
N  *             - \ref SYS_RSTSRC_RSTS_LVR_Msk
N  *             - \ref SYS_RSTSRC_RSTS_WDT_Msk
N  *             - \ref SYS_RSTSRC_RSTS_RESET_Msk
N  *             - \ref SYS_RSTSRC_RSTS_POR_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RSTSRC = (u32RstSrc) )
N
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
Nstatic __INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGWRPROT = 0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0;
N}
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  *
N  */
Nstatic __INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
X    while(((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT != (1ul << 0))
N    {
N        SYS->REGWRPROT = 0x59;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x59;
N        SYS->REGWRPROT = 0x16;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x16;
N        SYS->REGWRPROT = 0x88;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x88;
N    }
N}
N
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
N
N
N/*@}*/ /* end of group SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SYS_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12805 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "ADC.h"
L 1 "..\..\..\Library\StdDriver\inc\ADC.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V3.00
N * $Revision: 6 $
N * $Date: 15/05/06 4:49p $
N * @brief    ADC Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable triggering of A/D conversion by external STADC pin or PWM   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable triggering of A/D conversion by external STADC pin or PWM  */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by external STADC pin */
N#define ADC_ADCR_TRGS_PWM               (3UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by PWM */
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCHER Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL         (0UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the external analog input                   */
N#define ADC_ADCHER_PRESEL_INT_BANDGAP              (1UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the internal bandgap voltage                */
N#define ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR   (2UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the output of internal temperature sensor   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)         /*!< Compare channel for compare function          */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "less than"          */
N#define ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "greater than or equal to" */
N#define ADC_ADCMPR_CMPIE_INTERRUPT_ENABLE     (ADC_ADCMPR_CMPIE_Msk)                /*!< The compare function interrupt enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Interrupt Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADF_INT         (ADC_ADSR_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT        (ADC_ADSR_CMPF0_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT        (ADC_ADSR_CMPF1_Msk)        /*!< ADC comparator 1 interrupt */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant Definitions of ADC Channel 7 Input Source                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_CH7_EXT_INPUT_SIGNAL         0   /*!< External input signal       */
N#define ADC_CH7_INT_BANDGAP              1   /*!< Internal band-gap voltage   */
N#define ADC_CH7_INT_TEMPERATURE_SENSOR   2   /*!< Internal temperature sensor */
N
N
N/*@}*/ /* end of group ADC_EXPORTED_CONSTANTS */
N
N/** @addtogroup ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Configure the analog input source of channel 7.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Source Decides the analog input source of channel 7. Valid values are:
N  *                       - \ref ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL        : External analog input.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_BANDGAP             : Internal bandgap voltage.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR  : Output of internal temperature sensor.
N  * @return None
N  * @details Channel 7 supports 3 input sources: External analog voltage, internal Band-gap voltage, and internal temperature sensor output.
N  * @note While using VBG as channel 7 source, ADC module clock must /b not exceed 300kHz.
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_PRESEL_Msk) | (u32Source))
N
N/**
N  * @brief Enable PDMA transfer.
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Enable PDMA to transfer the conversion data.
N  * @note While enable PDMA transfer, software must set ADIE = 0 to disable interrupt.
N  */
N#define ADC_ENABLE_PDMA(adc) ((adc)->ADCR |= ADC_ADCR_PTEN_Msk)
N
N/**
N  * @brief Disable PDMA transfer.
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Disable PDMA to transfer the conversion data.
N  */
N#define ADC_DISABLE_PDMA(adc) ((adc)->ADCR &= ~ADC_ADCR_PTEN_Msk)
N
N/**
N  * @brief Get conversion data of specified channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  ADC Channel, valid value are from 0 to 7.
N  * @return 16-bit data.
N  * @details Read RSLT bit field to get conversion data.
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) ((adc)->ADDR[(u32ChNum)] & ADC_ADDR_RSLT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return User specified interrupt flags.
N  * @details Get the status of the ADC interrupt flag.
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) ((adc)->ADSR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return None
N  * @details ADF (ADSR[0])/CMPF0 (ADSR[1])/CMPF0 (ADSR[2]) can be cleared by writing 1 to itself.
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->ADSR = (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @retval 0 ADC is not busy.
N  * @retval 1 ADC is busy.
N  * @details BUSY(ADSR[3])is mirror of as ADST bit (ADCR[11]).
N  */
N#define ADC_IS_BUSY(adc) ((adc)->ADSR & ADC_ADSR_BUSY_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is over written or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not overrun.
N  * @retval 1 ADC data is overrun.
N  * @details OVERRUN (ADSR[23:16]) is a mirror to OVERRUN (ADDR0~7[16]).
N  */
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) ((adc)->ADSR & (0x1 << (ADC_ADSR_OVERRUN_Pos + (u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not valid.
N  * @retval 1 ADC data is valid.
N  * @details VALID (ADDR0~7[17]) is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
N  */
N#define ADC_IS_DATA_VALID(adc, u32ChNum) ((adc)->ADSR & (0x1<<(ADC_ADSR_VALID_Pos+(u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Power down ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Disable A/D converter analog circuit for saving power consumption.
N  * @note None
N  */
N#define ADC_POWER_DOWN(adc) ((adc)->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Before starting A/D conversion function, ADEN bit (ADCR[0]) should be set to 1.
N  */
N#define ADC_POWER_ON(adc) ((adc)->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Configure the comparator 0 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is greater or
N  *          equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                          (u32Condition) | \
N                                                         ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                         (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                          ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                           (u32Condition) |                                                          ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                          (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                          ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 0.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR0[0]) to 0 to disable ADC controller to compare CMPD (ADCMPR0[27:16]).
N  */
N#define ADC_DISABLE_CMP0(adc) ((adc)->ADCMPR[0] = 0)
N
N/**
N  * @brief Configure the comparator 1 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is greater or
N  *          equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                          (u32Condition) | \
N                                                         ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                         (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                          ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                           (u32Condition) |                                                          ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                          (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                          ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 1.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR1[0]) to 0 to disable ADC controller to compare CMPD (ADCMPR1[27:16]).
N  */
N#define ADC_DISABLE_CMP1(adc) ((adc)->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1..., bit 7 is channel 7.
N  * @return None
N  * @details Enabled channel will be converted while ADC starts.
N  * @note NUC100 series MCU ADC can only convert 1 channel at a time. If more than 1 channels are enabled, only channel
N  *       with smallest number will be convert.
N  */
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Set the output format mode.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Format Decides the output format. Valid values are:
N  *                       - \ref ADC_ADCR_DMOF_UNSIGNED_OUTPUT      :Select the straight binary format as the output format of the conversion result.
N  *                       - \ref ADC_ADCR_DMOF_TWOS_COMPLEMENT      :Select the 2's complement format as the output format of the conversion result.
N  * @return None
N  * @details  The macro is used to set A/D differential input mode output format.
N  */
N#define ADC_SET_DMOF(adc, u32Format) ((adc)->ADCR = ((adc)->ADCR & ~ADC_ADCR_DMOF_Msk) | (u32Format))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC.
N  */
N#define ADC_START_CONV(adc) ((adc)->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
N  *          In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.
N  */
N#define ADC_STOP_CONV(adc) ((adc)->ADCR &= ~ADC_ADCR_ADST_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N              uint32_t u32InputMode,
N              uint32_t u32OpMode,
N              uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N
N
N
N/*@}*/ /* end of group ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ADC_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12806 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "FMC.h"
L 1 "..\..\..\Library\StdDriver\inc\FMC.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V3.0
N * $Revision: 3 $
N * $Date: 15/05/12 1:47p $
N * @brief    Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4K Bytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCON constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCON_BS_LDROM     0x2     /*!< ISPCON setting to select to boot from LDROM */
N#define FMC_ISPCON_BS_APROM     0x0     /*!< ISPCON setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ        0x00     /*!< ISP Command: Read Flash       */
N#define FMC_ISPCMD_PROGRAM     0x21     /*!< ISP Command: Program Flash    */
N#define FMC_ISPCMD_PAGE_ERASE  0x22     /*!< ISP Command: Page Erase Flash */
N#define FMC_ISPCMD_VECMAP      0x2e     /*!< ISP Command: Set VECMAP       */
N#define FMC_ISPCMD_READ_UID    0x04     /*!< ISP Command: Read Unique ID   */
N#define FMC_ISPCMD_READ_CID    0x0B     /*!< ISP Command: Read Company ID   */
N#define FMC_ISPCMD_READ_DID    0x0C     /*!< ISP Command: Read Device ID    */
N
N
N/*@}*/ /* end of group FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Enable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to enable ISP function.
N *
N */
N#define FMC_ENABLE_ISP()          (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Disable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear ISPEN bit of ISPCON control register to disable ISP function.
N *
N */
N#define FMC_DISABLE_ISP()         (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Enable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set LDUEN bit of ISPCON control register to enable LDROM update function.
N *             User needs to set LDUEN bit before they can update LDROM.
N *
N */
N#define FMC_ENABLE_LD_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)
N
N
N
N/**
N * @brief      Disable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to disable LDROM update function.
N *
N */
N#define FMC_DISABLE_LD_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N
N
N
N/**
N * @brief      Enable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set CFGUEN bit of ISPCON control register to enable User Configuration update function.
N *             User needs to set CFGUEN bit before they can update User Configuration area.
N *
N */
N#define FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)
N
N/**
N * @brief      Disable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear CFGUEN bit of ISPCON control register to disable User Configuration update function.
N *
N */
N#define FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk)           /*!< Disable CONFIG Update Function */
N
N
N/**
N * @brief      Enable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set APUEN bit of ISPCON control register to enable APROM update function.
N *             User needs to set APUEN bit before they can update APROM in APROM boot mode.
N *
N */
N#define FMC_ENABLE_AP_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)
N
N
N/**
N * @brief      Disable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear APUEN bit of ISPCON control register to disable APROM update function.
N *
N */
N#define FMC_DISABLE_AP_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)            /*!< Disable APROM Update Function  */
N
N/**
N * @brief      Get ISP fail flag
N *
N * @param      None
N *
N * @retval     0 Previous ISP command execution result is successful
N * @retval     1 Previous ISP command execution result is fail
N *
N * @details    ISPFF flag of ISPCON is used to indicate ISP command success or fail.
N *             This function will return the ISPFF flag to identify ISP command OK or fail.
N *
N */
N#define FMC_GET_FAIL_FLAG()       ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)
N
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set BS bit of ISPCON and reset CPU to execute the code of LDROM/APROM.
N *             This function is used to set BS bit of ISPCON to boot to APROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after setting BS bit.
N *
N */
N#define FMC_SET_APROM_BOOT()      (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set/clear BS bit of ISPCON and reset CPU to execute the code of APROM/LDROM.
N *             This function is used to clear BS bit of ISPCON to boot to LDROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after clear BS bit.
N *
N */
N#define FMC_SET_LDROM_BOOT()      (FMC->ISPCON |= FMC_ISPCON_BS_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N *
N * @param[in]  u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32data  32-bit Data to program
N *
N * @return     None
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write(uint32_t u32addr, uint32_t u32data)
Xstatic __inline void FMC_Write(uint32_t u32addr, uint32_t u32data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;   /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;    
N    FMC->ISPADR = u32addr;              /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;               
N    FMC->ISPDAT = u32data;              /* Set Data to Program */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32data;               
N    FMC->ISPTRG = 0x1;                  /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                   
N    __ISB();                            /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                             
N    while(FMC->ISPTRG);                 /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                  
N}
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N *
N * @param[in]   u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;  
N    FMC->ISPADR = u32addr;         /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;          
N    FMC->ISPTRG = 0x1;             /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;              
N    __ISB();                       /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                        
N    while(FMC->ISPTRG);            /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);             
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N * @brief      Flash page erase
N *
N * @param[in]  u32addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG.
N *             The page size is 512 bytes.
N *
N * @retval      0 Success
N * @retval     -1 Erase failed
N *
N */
Nstatic __INLINE int32_t FMC_Erase(uint32_t u32addr)
Xstatic __inline int32_t FMC_Erase(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;  
N    FMC->ISPADR = u32addr;               /* Set Target ROM Address. The address must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;                
N    FMC->ISPTRG = 0x1;                   /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                    
N    __ISB();                             /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                              
N    while(FMC->ISPTRG);                  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                   
N
N    /* Check ISPFF flag to know whether erase OK or fail. */
N    if(FMC->ISPCON & FMC_ISPCON_ISPFF_Msk)
X    if(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON & (1ul << 6))
N    {
N        FMC->ISPCON = FMC_ISPCON_ISPFF_Msk;
X        ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON = (1ul << 6);
N        return -1;
N    }
N    return 0;
N}
N
N/**
N * @brief       Read Unique ID
N *
N * @param[in]   u8index  UID index. 0 = UID[31:0], 1 = UID[63:32], 2 = UID[95:64]
N *
N * @return      The 32-bit unique ID data of specified UID index.
N *
N * @details     To read out 96-bit Unique ID.
N *
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;  
N    FMC->ISPADR = (u8index << 2);      /* Set UID Address. It must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (u8index << 2);       
N    FMC->ISPTRG = 0x1;                 /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                  
N    __ISB();                           /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                            
N    while(FMC->ISPTRG);                /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                 
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N  * @brief    Read company ID
N  *
N  * @param    None
N  *
N  * @return   The company ID (32-bit)
N  *
N  * @details  The company ID of Nuvoton is fixed to be 0xDA
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadCID(void)
Xstatic __inline uint32_t FMC_ReadCID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_CID;           /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0B;            
N    FMC->ISPADR = 0x0;                           /* Must keep 0x0 when read CID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x0;                            
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;          /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);           
N    __ISB();                                     /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                      
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) ;  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0)) ;   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read product ID
N  *
N  * @param    None
N  *
N  * @return   The product ID (32-bit)
N  *
N  * @details  This function is used to read product ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadPID(void)
Xstatic __inline uint32_t FMC_ReadPID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADR = 0x04;                         /* Must keep 0x4 when read PID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x04;                          
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief      To read UCID
N  *
N  * @param[in]  u32Index    Index of the UCID to read. u32Index must be 0, 1, 2, or 3.
N  *
N  * @return     The UCID of specified index
N  *
N  * @details    This function is used to read unique chip ID (UCID).
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadUCID(uint32_t u32Index)
Xstatic __inline uint32_t FMC_ReadUCID(uint32_t u32Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;           
N    FMC->ISPADR = (0x04 * u32Index) + 0x10;     /* The UCID is at offset 0x10 with word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (0x04 * u32Index) + 0x10;      
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N
N/**
N * @brief       Set vector mapping address
N *
N * @param[in]   u32PageAddr  The page address to remap to address 0x0. The address must be page alignment.
N *
N * @return      None
N *
N * @details     This function is used to set VECMAP to map specified page to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
Xstatic __inline void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x2e;  
N    FMC->ISPADR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32PageAddr;        
N    FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                
N    __ISB();                         /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                          
N    while(FMC->ISPTRG);              /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);               
N}
N
N
N/**
N * @brief       Get current vector mapping address.
N *
N * @param       None
N *
N * @return      The current vector mapping address.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE uint32_t FMC_GetVECMAP(void)
Xstatic __inline uint32_t FMC_GetVECMAP(void)
N{
N    return (FMC->ISPSTA & FMC_ISPSTA_VECMAP_Msk);
X    return (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPSTA & (0xFFFul << 9));
N}
N
Nextern void FMC_Open(void);
Nextern void FMC_Close(void);
Nextern void FMC_EnableAPUpdate(void);
Nextern void FMC_DisableAPUpdate(void);
Nextern void FMC_EnableConfigUpdate(void);
Nextern void FMC_DisableConfigUpdate(void);
Nextern void FMC_EnableLDUpdate(void);
Nextern void FMC_DisableLDUpdate(void);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern void FMC_SetBootSource(int32_t i32BootSrc);
Nextern int32_t FMC_GetBootSource(void);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
N
N/*@}*/ /* end of group FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group FMC_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 12807 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "GPIO.h"
L 1 "..\..\..\Library\StdDriver\inc\GPIO.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V3.00
N * $Revision: 3 $
N * $Date: 15/05/04 3:27p $
N * @brief    General Purpose I/O Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX            16 /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT          0x0UL /*!< Input Mode */
N#define GPIO_PMD_OUTPUT         0x1UL /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN     0x2UL /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI          0x3UL /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING         0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING        0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE      0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH           0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW            0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE           0UL /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL          1UL /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_CLK_ON         0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_INT_CLK_OFF        0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCLKSRC_LIRC      0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCLKSRC_HCLK      0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the HCLK */
N
N#define GPIO_DBCLKSEL_1         0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBCLKSEL_2         0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBCLKSEL_4         0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBCLKSEL_8         0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBCLKSEL_16        0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBCLKSEL_32        0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBCLKSEL_64        0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBCLKSEL_128       0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBCLKSEL_256       0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBCLKSEL_512       0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBCLKSEL_1024      0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCLKSEL_2048      0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCLKSEL_4096      0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCLKSEL_8192      0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCLKSEL_16384     0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCLKSEL_32768     0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N
N/* Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N   Example 1:
N
N       PA0 = 1;
N
N   It is used to set GPIO PA.0 to high;
N
N   Example 2:
N
N       if (PA0)
N           PA0 = 0;
N
N   If GPIO PA.0 pin status is high, then set GPIO PA.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))
N#define PA0             GPIO_PIN_DATA(0, 0 ) /*!< Specify PA.0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_DATA(0, 1 ) /*!< Specify PA.1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_DATA(0, 2 ) /*!< Specify PA.2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_DATA(0, 3 ) /*!< Specify PA.3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_DATA(0, 4 ) /*!< Specify PA.4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_DATA(0, 5 ) /*!< Specify PA.5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_DATA(0, 6 ) /*!< Specify PA.6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_DATA(0, 7 ) /*!< Specify PA.7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_DATA(0, 8 ) /*!< Specify PA.8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_DATA(0, 9 ) /*!< Specify PA.9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_DATA(0, 10) /*!< Specify PA.10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_DATA(0, 11) /*!< Specify PA.11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_DATA(0, 12) /*!< Specify PA.12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_DATA(0, 13) /*!< Specify PA.13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_DATA(0, 14) /*!< Specify PA.14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_DATA(0, 15) /*!< Specify PA.15 Pin Data Input/Output */
N#define PB0             GPIO_PIN_DATA(1, 0 ) /*!< Specify PB.0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_DATA(1, 1 ) /*!< Specify PB.1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_DATA(1, 2 ) /*!< Specify PB.2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_DATA(1, 3 ) /*!< Specify PB.3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_DATA(1, 4 ) /*!< Specify PB.4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_DATA(1, 5 ) /*!< Specify PB.5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_DATA(1, 6 ) /*!< Specify PB.6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_DATA(1, 7 ) /*!< Specify PB.7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_DATA(1, 8 ) /*!< Specify PB.8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_DATA(1, 9 ) /*!< Specify PB.9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_DATA(1, 10) /*!< Specify PB.10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_DATA(1, 11) /*!< Specify PB.11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_DATA(1, 12) /*!< Specify PB.12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_DATA(1, 13) /*!< Specify PB.13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_DATA(1, 14) /*!< Specify PB.14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_DATA(1, 15) /*!< Specify PB.15 Pin Data Input/Output */
N#define PC0             GPIO_PIN_DATA(2, 0 ) /*!< Specify PC.0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_DATA(2, 1 ) /*!< Specify PC.1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_DATA(2, 2 ) /*!< Specify PC.2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_DATA(2, 3 ) /*!< Specify PC.3 Pin Data Input/Output */
N#define PC4             GPIO_PIN_DATA(2, 4 ) /*!< Specify PC.4 Pin Data Input/Output */
N#define PC5             GPIO_PIN_DATA(2, 5 ) /*!< Specify PC.5 Pin Data Input/Output */
N#define PC6             GPIO_PIN_DATA(2, 6 ) /*!< Specify PC.6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_DATA(2, 7 ) /*!< Specify PC.7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_DATA(2, 8 ) /*!< Specify PC.8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_DATA(2, 9 ) /*!< Specify PC.9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_DATA(2, 10) /*!< Specify PC.10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_DATA(2, 11) /*!< Specify PC.11 Pin Data Input/Output */
N#define PC12            GPIO_PIN_DATA(2, 12) /*!< Specify PC.12 Pin Data Input/Output */
N#define PC13            GPIO_PIN_DATA(2, 13) /*!< Specify PC.13 Pin Data Input/Output */
N#define PC14            GPIO_PIN_DATA(2, 14) /*!< Specify PC.14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_DATA(2, 15) /*!< Specify PC.15 Pin Data Input/Output */
N#define PD0             GPIO_PIN_DATA(3, 0 ) /*!< Specify PD.0 Pin Data Input/Output */
N#define PD1             GPIO_PIN_DATA(3, 1 ) /*!< Specify PD.1 Pin Data Input/Output */
N#define PD2             GPIO_PIN_DATA(3, 2 ) /*!< Specify PD.2 Pin Data Input/Output */
N#define PD3             GPIO_PIN_DATA(3, 3 ) /*!< Specify PD.3 Pin Data Input/Output */
N#define PD4             GPIO_PIN_DATA(3, 4 ) /*!< Specify PD.4 Pin Data Input/Output */
N#define PD5             GPIO_PIN_DATA(3, 5 ) /*!< Specify PD.5 Pin Data Input/Output */
N#define PD6             GPIO_PIN_DATA(3, 6 ) /*!< Specify PD.6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_DATA(3, 7 ) /*!< Specify PD.7 Pin Data Input/Output */
N#define PD8             GPIO_PIN_DATA(3, 8 ) /*!< Specify PD.8 Pin Data Input/Output */
N#define PD9             GPIO_PIN_DATA(3, 9 ) /*!< Specify PD.9 Pin Data Input/Output */
N#define PD10            GPIO_PIN_DATA(3, 10) /*!< Specify PD.10 Pin Data Input/Output */
N#define PD11            GPIO_PIN_DATA(3, 11) /*!< Specify PD.11 Pin Data Input/Output */
N#define PD12            GPIO_PIN_DATA(3, 12) /*!< Specify PD.12 Pin Data Input/Output */
N#define PD13            GPIO_PIN_DATA(3, 13) /*!< Specify PD.13 Pin Data Input/Output */
N#define PD14            GPIO_PIN_DATA(3, 14) /*!< Specify PD.14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_DATA(3, 15) /*!< Specify PD.15 Pin Data Input/Output */
N#define PE0             GPIO_PIN_DATA(4, 0 ) /*!< Specify PE.0 Pin Data Input/Output */
N#define PE1             GPIO_PIN_DATA(4, 1 ) /*!< Specify PE.1 Pin Data Input/Output */
N#define PE2             GPIO_PIN_DATA(4, 2 ) /*!< Specify PE.2 Pin Data Input/Output */
N#define PE3             GPIO_PIN_DATA(4, 3 ) /*!< Specify PE.3 Pin Data Input/Output */
N#define PE4             GPIO_PIN_DATA(4, 4 ) /*!< Specify PE.4 Pin Data Input/Output */
N#define PE5             GPIO_PIN_DATA(4, 5 ) /*!< Specify PE.5 Pin Data Input/Output */
N#define PE6             GPIO_PIN_DATA(4, 6 ) /*!< Specify PE.6 Pin Data Input/Output */
N#define PE7             GPIO_PIN_DATA(4, 7 ) /*!< Specify PE.7 Pin Data Input/Output */
N#define PE8             GPIO_PIN_DATA(4, 8 ) /*!< Specify PE.8 Pin Data Input/Output */
N#define PE9             GPIO_PIN_DATA(4, 9 ) /*!< Specify PE.9 Pin Data Input/Output */
N#define PE10            GPIO_PIN_DATA(4, 10) /*!< Specify PE.10 Pin Data Input/Output */
N#define PE11            GPIO_PIN_DATA(4, 11) /*!< Specify PE.11 Pin Data Input/Output */
N#define PE12            GPIO_PIN_DATA(4, 12) /*!< Specify PE.12 Pin Data Input/Output */
N#define PE13            GPIO_PIN_DATA(4, 13) /*!< Specify PE.13 Pin Data Input/Output */
N#define PE14            GPIO_PIN_DATA(4, 14) /*!< Specify PE.14 Pin Data Input/Output */
N#define PE15            GPIO_PIN_DATA(4, 15) /*!< Specify PE.15 Pin Data Input/Output */
N#define PF0             GPIO_PIN_DATA(5, 0 ) /*!< Specify PF.0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_DATA(5, 1 ) /*!< Specify PF.1 Pin Data Input/Output */
N#define PF2             GPIO_PIN_DATA(5, 2 ) /*!< Specify PF.2 Pin Data Input/Output */
N#define PF3             GPIO_PIN_DATA(5, 3 ) /*!< Specify PF.3 Pin Data Input/Output */
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(port, u32PinMask)         ((port)->ISRC = (u32PinMask))
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(port, u32PinMask)     ((port)->DBEN &= ~(u32PinMask))
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(port, u32PinMask)      ((port)->DBEN |= (u32PinMask))
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(port, u32PinMask) ((port)->OFFD |= ((u32PinMask)<<16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(port, u32PinMask)  ((port)->OFFD &= ~((u32PinMask)<<16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(port, u32PinMask)    ((port)->DMASK &= ~(u32PinMask))
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(port, u32PinMask) ((port)->DMASK |= (u32PinMask))
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(port, u32PinMask)     ((port)->ISRC & (u32PinMask))
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be GPIO_DBCLKSRC_HCLK or GPIO_DBCLKSRC_LIRC.
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be \n
N *                              GPIO_DBCLKSEL_1, GPIO_DBCLKSEL_2, GPIO_DBCLKSEL_4, GPIO_DBCLKSEL_8, \n
N *                              GPIO_DBCLKSEL_16, GPIO_DBCLKSEL_32, GPIO_DBCLKSEL_64, GPIO_DBCLKSEL_128, \n
N *                              GPIO_DBCLKSEL_256, GPIO_DBCLKSEL_512, GPIO_DBCLKSEL_1024, GPIO_DBCLKSEL_2048, \n
N *                              GPIO_DBCLKSEL_4096, GPIO_DBCLKSEL_8192, GPIO_DBCLKSEL_16384, GPIO_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBCLKSRC_LIRC, GPIO_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (4)*(1/(10*1000)) s = 4*0.0001 s = 400 us,
N *              and system will sampling interrupt input once per 400 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)    (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | (u32ClkSrc) | (u32ClkSel)))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N *
N * @return      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(port)  ((port)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Data     GPIO port data.
N *
N * @return      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(port, u32Data)    ((port)->DOUT = (u32Data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin      Pxy
N *
N * @return      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin) ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO Interrupt 0
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N *                              It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                              It could be 0 ~ 3 for PF GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 0
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin      The pin of specified GPIO port.
N *                          It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be 0 ~ 3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO Interrupt 1
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N *                              It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                              It could be 0 ~ 3 for PF GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 1
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin      The pin of specified GPIO port.
N *                          It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be 0 ~ 3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group GPIO_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12808 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "I2C.h"
L 1 "..\..\..\Library\StdDriver\inc\I2C.h" 1
N/**************************************************************************//**
N * @file     I2C.h
N * @version  V3.0
N * $Revision: 3 $
N * $Date: 15/05/04 3:27p $
N * @brief    I2C Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CON constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CON_STA_STO_SI        0x38UL /*!< I2CON setting for I2C control bits. It would set STA, STO and SI bits     */
N#define I2C_I2CON_STA_STO_SI_AA     0x3CUL /*!< I2CON setting for I2C control bits. It would set STA, STO, SI and AA bits */
N#define I2C_I2CON_STA_SI            0x28UL /*!< I2CON setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_I2CON_STA_SI_AA         0x2CUL /*!< I2CON setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_I2CON_STO_SI            0x18UL /*!< I2CON setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_I2CON_STO_SI_AA         0x1CUL /*!< I2CON setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_I2CON_SI                0x08UL /*!< I2CON setting for I2C control bits. It would set SI bit                   */
N#define I2C_I2CON_SI_AA             0x0CUL /*!< I2CON setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_I2CON_STA               0x20UL /*!< I2CON setting for I2C control bits. It would set STA bit                  */
N#define I2C_I2CON_STO               0x10UL /*!< I2CON setting for I2C control bits. It would set STO bit                  */
N#define I2C_I2CON_AA                0x04UL /*!< I2CON setting for I2C control bits. It would set AA bit                   */
N
N#define I2C_GCMODE_ENABLE           1      /*!< Enable  I2C GC Mode                                                       */
N#define I2C_GCMODE_DISABLE          0      /*!< Disable I2C GC Mode                                                       */
N
N/*@}*/ /* end of group I2C_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N/**
N *    @brief        The macro is used to set I2C bus condition at One Time
N *
N *    @param[in]    i2c        Specify I2C port
N *    @param[in]    u8Ctrl     A byte writes to I2C control register
N *
N *    @return       None
N *
N *    @details      Set I2CON register to control I2C bus conditions of START, STOP, SI, ACK.
N */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ((i2c)->I2CON = ((i2c)->I2CON & ~0x3c) | u8Ctrl)
N
N/**
N *    @brief        The macro is used to set START condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus START condition in I2CON register.
N */
N#define I2C_START(i2c)  ((i2c)->I2CON = ((i2c)->I2CON | I2C_I2CON_SI_Msk) | I2C_I2CON_STA_Msk)
N
N/**
N *    @brief        The macro is used to set STOP condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus STOP condition in I2CON register.
N */
N#define I2C_STOP(i2c)   ((i2c)->I2CON = ((i2c)->I2CON | I2C_I2CON_SI_Msk) | I2C_I2CON_STO_Msk)
N
N/**
N *    @brief        The macro is used to wait I2C bus status get ready
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      When a new status is presented of I2C bus, the SI flag will be set in I2CON register.
N */
N#define I2C_WAIT_READY(i2c)     while(!((i2c)->I2CON & I2C_I2CON_SI_Msk))
N
N/**
N *    @brief        The macro is used to Read I2C Bus Data Register
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       A byte of I2C data register
N *
N *    @details      I2C controller read data from bus and save it in I2CDAT register.
N */
N#define I2C_GET_DATA(i2c)   ((i2c)->I2CDAT)
N
N/**
N *    @brief        Write a Data to I2C Data Register
N *
N *    @param[in]    i2c         Specify I2C port
N *    @param[in]    u8Data      A byte that writes to data register
N *
N *    @return       None
N *
N *    @details      When write a data to I2CDAT register, the I2C controller will shift it to I2C bus.
N */
N#define I2C_SET_DATA(i2c, u8Data) ((i2c)->I2CDAT = u8Data)
N
N/**
N *    @brief        Get I2C Bus status code
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       I2C status code
N *
N *    @details      To get this status code to monitor I2C bus event.
N */
N#define I2C_GET_STATUS(i2c) ((i2c)->I2CSTATUS)
N
N/**
N *    @brief        Get Time-out flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       I2C Bus time-out is not happened
N *    @retval       1       I2C Bus time-out is happened
N *
N *    @details      When I2C bus occurs time-out event, the time-out flag will be set.
N */
N#define I2C_GET_TIMEOUT_FLAG(i2c)   ( (i2c->I2CTOC & I2C_I2CTOC_TIF_Msk) == I2C_I2CTOC_TIF_Msk ? 1:0 )
N
N/**
N *    @brief        To get wake-up flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Chip is not woken-up from power-down mode
N *    @retval       1       Chip is woken-up from power-down mode
N *
N *    @details      I2C bus occurs wake-up event, wake-up flag will be set.
N */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->I2CWKUPSTS & I2C_I2CWKUPSTS_WKUPIF_Msk) == I2C_I2CWKUPSTS_WKUPIF_Msk ? 1:0  )
N
N/**
N *    @brief        To clear wake-up flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up flag is set, use this macro to clear it.
N */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->I2CWKUPSTS |= I2C_I2CWKUPSTS_WKUPIF_Msk)
N
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nuint8_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
N
N/*@}*/ /* end of group I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group I2C_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N#endif //__I2C_H__
L 12809 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "PWM.h"
L 1 "..\..\..\Library\StdDriver\inc\PWM.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/06 2:38p $
N * @brief    PWM driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                     (4)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divide by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divide by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divide by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divide by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divide by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL) /*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (1UL) /*!< PWM working in center aligned type */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                         /*!< PWM period interrupt triggered if counter underflow */
N#define PWM_PERIOD_INT_MATCH_CNR            (PWM_PIER_INT01TYPE_Msk)    /*!< PWM period interrupt triggered if counter match CNR */
N#define PWM_CAPTURE_INT_RISING_LATCH        (PWM_CCR0_CRL_IE0_Msk)      /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH       (PWM_CCR0_CFL_IE0_Msk)      /*!< PWM capture interrupt if channel has falling transition */
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel number constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0                             0x0                         /*!< PWM Group A/B channel 0 */
N#define PWM_CH1                             0x1                         /*!< PWM Group A/B channel 1 */
N#define PWM_CH2                             0x2                         /*!< PWM Group A/B channel 2 */
N#define PWM_CH3                             0x3                         /*!< PWM Group A/B channel 3 */
N#define PWM_CCR_MASK                        0x000F000F                  /*!< PWM CCR0/CCR2 bit0~3 and bit16~19 mask */
N
N/*@}*/ /* end of group PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief Enable output inverter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable capture input inverter for specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N                (pwm)->PCR &= ~(PWM_PCR_CH0INV_Msk|PWM_PCR_CH1INV_Msk|PWM_PCR_CH2INV_Msk|PWM_PCR_CH3INV_Msk);\
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4))); \
N        } \
N    }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     do{         int i;                (pwm)->PCR &= ~(PWM_PCR_CH0INV_Msk|PWM_PCR_CH1INV_Msk|PWM_PCR_CH2INV_Msk|PWM_PCR_CH3INV_Msk);        for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4)));         }     }while(0)
N
N/**
N * @brief Get captured rising data of specified channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @return The timer counter, 0~0xFFFF
N * @details This macro is used to get captured rising data for specified channel.
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CRLR0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Get captured falling data of specified channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @return The timer counter, 0~0xFFFF
N * @details This macro is used to get captured falling data for specified channel.
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CFLR0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Set the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @details This macro is used to set timer pre-scale for specified channel.
N * @note If u32Prescaler = 0, corresponding PWM-timer will be stopped.
N * @note If u32Prescaler = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    ((pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     ((pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
N
N/**
N * @brief Set the divider of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16
N * @return None
N * @details This macro is used to set Timer clock source divider selection for specified channel.
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    ((pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     ((pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief Set the duty of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set PWM Comparator value for specified channel.
N * @note This new setting will take effect on next PWM period.
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CMR0)) + (u32ChannelNum) * 12))) = (u32CMR))
N
N/**
N * @brief Set the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set timer loaded value(CNR) for specified channel.\n
N *          Loaded value determines the PWM period.
N * @note This new setting will take effect on next PWM period.
N * @note PWM counter will stop if period length set to 0.
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CNR0)) + (u32ChannelNum) * 12))) = (u32CNR))
N
N/**
N * @brief Set the PWM aligned type
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *                  - \ref PWM_EDGE_ALIGNED
N *                  - \ref PWM_CENTER_ALIGNED
N * @return None
N * @details This macro is used to set the PWM aligned type.
N * @note PWM trigger ADC function is only supported when PWM operating at Center-aligned type.
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N    do{ \
N        int i; \
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PCR = ((pwm)->PCR & ~(PWM_PCR_PWM01TYPE_Msk << (i >> 1))) | ((u32AlignedType) << (PWM_PCR_PWM01TYPE_Pos + (i >> 1))); \
N        } \
N    }while(0)
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)     do{         int i;         for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PCR = ((pwm)->PCR & ~(PWM_PCR_PWM01TYPE_Msk << (i >> 1))) | ((u32AlignedType) << (PWM_PCR_PWM01TYPE_Pos + (i >> 1)));         }     }while(0)
N
N
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum,
N                                  uint32_t u32UnitTimeNsec,
N                                  uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                 uint32_t u32ChannelNum,
N                                 uint32_t u32Frequncy,
N                                 uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N
N/*@}*/ /* end of group PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PWM_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12810 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "SPI.h"
L 1 "..\..\..\Library\StdDriver\inc\SPI.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V3.0
N * $Revision: 3 $
N * $Date: 15/05/04 3:27p $
N * @brief    SPI Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CNTRL_TX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CNTRL_RX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk)     /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk)     /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CNTRL_SLAVE_Msk)                           /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS0               (1<<SPI_SSR_SSR_Pos)                       /*!< Select SPIn_SS0 */
N#define SPI_SS1               (2<<SPI_SSR_SSR_Pos)                       /*!< Select SPIn_SS1 */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                        /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low */
N
N#define SPI_UNIT_INT_MASK                (0x01)                           /*!< Unit transfer interrupt mask */
N#define SPI_SSTA_INT_MASK                (0x02)                           /*!< Slave 3-Wire mode start interrupt mask */
N#define SPI_FIFO_TX_INT_MASK             (0x04)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INT_MASK             (0x08)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INT_MASK           (0x10)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INT_MASK        (0x20)                           /*!< FIFO RX timeout interrupt mask */
N
N#define SPI_BUSY_MASK                    (0x01)                           /*!< Busy status mask */
N#define SPI_RX_EMPTY_MASK                (0x02)                           /*!< RX empty status mask */
N#define SPI_RX_FULL_MASK                 (0x04)                           /*!< RX full status mask */
N#define SPI_TX_EMPTY_MASK                (0x08)                           /*!< TX empty status mask */
N#define SPI_TX_FULL_MASK                 (0x10)                           /*!< TX full status mask */
N
N/*@}*/ /* end of group SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Abort the current transfer in Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set the SLV_ABORT bit of SPI_CNTRL2 register to abort the current transfer in Slave 3-wire mode.
N  */
N#define SPI_ABORT_3WIRE_TRANSFER(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk)
N
N/**
N  * @brief      Clear the Slave 3-wire mode start interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to SLV_START_INTSTS bit of SPI_STATUS register to clear the Slave 3-wire mode start interrupt flag.
N  */
N#define SPI_CLR_3WIRE_START_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_SLV_START_INTSTS_Msk)
N
N/**
N  * @brief      Clear the unit transfer interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to IF bit of SPI_STATUS register to clear the unit transfer interrupt flag.
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_IF_Msk)
N
N/**
N  * @brief      Disable 2-bit Transfer mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear TWOB bit of SPI_CNTRL register to disable 2-bit Transfer mode.
N  */
N#define SPI_DISABLE_2BIT_MODE(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_TWOB_Msk)
N
N/**
N  * @brief      Disable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear NOSLVSEL bit of SPI_CNTRL2 register to disable Slave 3-wire mode.
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Disable Dual I/O mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUAL_IO_EN bit of SPI_CNTRL2 register to disable Dual I/O mode.
N  */
N#define SPI_DISABLE_DUAL_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N  * @brief      Enable 2-bit Transfer mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TWOB bit of SPI_CNTRL register to enable 2-bit Transfer mode.
N  */
N#define SPI_ENABLE_2BIT_MODE(spi)   ((spi)->CNTRL |= SPI_CNTRL_TWOB_Msk)
N
N/**
N  * @brief      Enable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set NOSLVSEL bit of SPI_CNTRL2 register to enable Slave 3-wire mode.
N  *             Only available in Slave mode.
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Enable Dual input mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUAL_IO_DIR bit and set DUAL_IO_EN bit of SPI_CNTRL2 register to enable Dual input mode.
N  */
N#define SPI_ENABLE_DUAL_INPUT_MODE(spi)   ((spi)->CNTRL2 = ((spi)->CNTRL2 & (~SPI_CNTRL2_DUAL_IO_DIR_Msk)) | SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N  * @brief      Enable Dual output mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set DUAL_IO_DIR bit and DUAL_IO_EN bit of SPI_CNTRL2 register to enable Dual output mode.
N  */
N#define SPI_ENABLE_DUAL_OUTPUT_MODE(spi)   ((spi)->CNTRL2 |= (SPI_CNTRL2_DUAL_IO_EN_Msk | SPI_CNTRL2_DUAL_IO_DIR_Msk))
N
N/**
N  * @brief      Trigger RX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set RX_DMA_GO bit of SPI_DMA register to enable RX PDMA transfer function.
N  */
N#define SPI_TRIGGER_RX_PDMA(spi)   ((spi)->DMA |= SPI_DMA_RX_DMA_GO_Msk)
N
N/**
N  * @brief      Trigger TX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TX_DMA_GO bit of SPI_DMA register to enable TX PDMA transfer function.
N  */
N#define SPI_TRIGGER_TX_PDMA(spi)   ((spi)->DMA |= SPI_DMA_TX_DMA_GO_Msk)
N
N/**
N  * @brief      Get the count of available data in RX FIFO.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     The count of available data in RX FIFO.
N  * @details    Read RX_FIFO_COUNT (SPI_STATUS[15:12]) to get the count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi)   (((spi)->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk) >> SPI_STATUS_RX_FIFO_COUNT_Pos)
N
N/**
N  * @brief      Get the RX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 RX FIFO is not empty.
N  * @retval     1 RX FIFO is empty.
N  * @details    Read RX_EMPTY bit of SPI_STATUS register to get the RX FIFO empty flag.
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_RX_EMPTY_Msk)>>SPI_STATUS_RX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not empty.
N  * @retval     1 TX FIFO is empty.
N  * @details    Read TX_EMPTY bit of SPI_STATUS register to get the TX FIFO empty flag.
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_EMPTY_Msk)>>SPI_STATUS_TX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO full flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not full.
N  * @retval     1 TX FIFO is full.
N  * @details    Read TX_FULL bit of SPI_STATUS register to get the TX FIFO full flag.
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_FULL_Msk)>>SPI_STATUS_TX_FULL_Pos)
N
N/**
N  * @brief      Get the datum read from RX0 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX0 register.
N  * @details    Read SPI_RX0 register to get the received datum.
N  */
N#define SPI_READ_RX0(spi)   ((spi)->RX[0])
N
N/**
N  * @brief      Get the datum read from RX1 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX1 register.
N  * @details    Read SPI_RX1 register to get the received datum.
N  */
N#define SPI_READ_RX1(spi)   ((spi)->RX[1])
N
N/**
N  * @brief      Write datum to TX0 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to TX0 register.
N  */
N#define SPI_WRITE_TX0(spi, u32TxData)   ((spi)->TX[0] = (u32TxData))
N
N/**
N  * @brief      Write datum to TX1 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to TX1 register.
N  */
N#define SPI_WRITE_TX1(spi, u32TxData)   ((spi)->TX[1] = (u32TxData))
N
N/**
N  * @brief      Set SPIn_SS0, SPIn_SS1 pin to high or low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  ss0 0 = Set SPIn_SS0 to low. 1 = Set SPIn_SS0 to high.
N  * @param[in]  ss1 0 = Set SPIn_SS1 to low. 1 = Set SPIn_SS1 to high.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0/SPIn_SS1 pin to specified high/low state.
N  *             Only available in Master mode.
N  */
N#define SPI_SET_SS_LEVEL(spi, ss0, ss1)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SSR_SSR_Msk)) | (((ss1)^1) << 1) | ((ss0)^1))
N
N/**
N  * @brief      Set SPIn_SS0 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to high state. Only available in Master mode.
N  */
N#define SPI_SET_SS0_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS0)))
N
N/**
N  * @brief      Set SPIn_SS1 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS1 pin to high state. Only available in Master mode.
N  */
N#define SPI_SET_SS1_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS1)))
N
N/**
N  * @brief      Set SPIn_SS0 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to low state. Only available in Master mode.
N  */
N#define SPI_SET_SS0_LOW(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS0)) | SPI_SS0)
N
N/**
N  * @brief      Set SPIn_SS1 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS1 pin to low state. Only available in Master mode.
N  */
N#define SPI_SET_SS1_LOW(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS1)) | SPI_SS1)
N
N/**
N  * @brief      Enable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set REORDER bit of SPI_CNTRL register to enable Byte Reorder function.
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi)   ((spi)->CNTRL |= SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Disable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear REORDER bit of SPI_CNTRL register to disable Byte Reorder function.
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Set the length of suspend interval.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32SuspCycle Decides the length of suspend interval.
N  * @return     None.
N  * @details    Set the length of suspend interval according to u32SuspCycle.
N  *             The length of suspend interval is ((u32SuspCycle + 0.5) * the length of one SPI bus clock cycle).
N  *             Only available in Master mode.
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_SP_CYCLE_Msk) | ((u32SuspCycle) << SPI_CNTRL_SP_CYCLE_Pos))
N
N/**
N  * @brief      Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set LSB bit of SPI_CNTRL register to set the SPI transfer sequence with LSB first.
N  */
N#define SPI_SET_LSB_FIRST(spi)   ((spi)->CNTRL |= SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear LSB bit of SPI_CNTRL register to set the SPI transfer sequence with MSB first.
N  */
N#define SPI_SET_MSB_FIRST(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the data width of a SPI transaction.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32Width The bit width of transfer data.
N  * @return     None.
N  * @details    The data width can be 8 ~ 32 bits.
N  */
N#define SPI_SET_DATA_WIDTH(spi, u32Width)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_TX_BIT_LEN_Msk) | (((u32Width)&0x1F) << SPI_CNTRL_TX_BIT_LEN_Pos))
N
N/**
N  * @brief      Get the SPI busy state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 SPI controller is not busy.
N  * @retval     1 SPI controller is busy.
N  * @details    This macro will return the busy state of SPI controller.
N  */
N#define SPI_IS_BUSY(spi)   ( ((spi)->CNTRL & SPI_CNTRL_GO_BUSY_Msk)>>SPI_CNTRL_GO_BUSY_Pos )
N
N/**
N  * @brief      Set the GO_BUSY bit to trigger SPI transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    If FIFO mode is disabled, user can use this macro to trigger the data transfer after all configuration is ready.
N  *             If FIFO mode is enabled, user should not use this macro to trigger the data transfer. SPI controller will trigger the data transfer
N  *             automatically after user write to SPI_TX0/1 register.
N  */
N#define SPI_TRIGGER(spi)   ((spi)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk)
N
N
N
N/* Function prototype declaration */
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);
N
N
N
N/**
N  * @} End of SPI Device Function Interface
N  */
N
N/**
N  * @} End of Function Interface
N  */
N
N/**
N  * @} End of Device_Driver
N  */
N
N
N#endif
N
L 12811 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "CRC.h"
L 1 "..\..\..\Library\StdDriver\inc\CRC.h" 1
N/**************************************************************************//**
N * @file     crc.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    CRC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __CRC_H__
N#define __CRC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CRC_Driver CRC Driver
N  @{
N*/
N
N/** @addtogroup CRC_EXPORTED_CONSTANTS CRC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CRC Polynomial Mode Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CCITT           0x00000000UL            /*!<CRC Polynomial Mode - CCITT */
N#define CRC_8               0x40000000UL            /*!<CRC Polynomial Mode - CRC8 */
N#define CRC_16              0x80000000UL            /*!<CRC Polynomial Mode - CRC16 */
N#define CRC_32              0xC0000000UL            /*!<CRC Polynomial Mode - CRC32 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Checksum, Write data Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CHECKSUM_COM    0x08000000UL            /*!<CRC Checksum Complement */
N#define CRC_CHECKSUM_RVS    0x02000000UL            /*!<CRC Checksum Reverse */
N#define CRC_WDATA_COM       0x04000000UL            /*!<CRC Write Data Complement */
N#define CRC_WDATA_RVS       0x01000000UL            /*!<CRC Write Data Reverse */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CPU Write Data Length Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CPU_WDATA_8     0x00000000UL            /*!<CRC 8-bit CPU Write Data */
N#define CRC_CPU_WDATA_16    0x10000000UL            /*!<CRC 16-bit CPU Write Data */
N#define CRC_CPU_WDATA_32    0x20000000UL            /*!<CRC 32-bit CPU Write Data */
N
N/*@}*/ /* end of group CRC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CRC_EXPORTED_FUNCTIONS CRC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Enable CRC Interrupt
N  *
N  * @param[in]  u32Mask     Interrupt mask
N  *
N  * @return     None
N  *
N  * @details    This macro enable the specify CRC interrupt function by u32Mask setting.
N  */
N#define CRC_ENABLE_INT(u32Mask)   (CRC->DMAIER |= (u32Mask))
N
N/**
N  * @brief      Disable CRC Interrupt
N  *
N  * @param[in]  u32Mask     Interrupt mask
N  *
N  * @return     None
N  *
N  * @details    This macro disable the specify CRC interrupt function by u32Mask setting.
N  */
N#define CRC_DISABLE_INT(u32Mask)    (CRC->DMAIER &= ~(u32Mask))
N
N/**
N  * @brief      Get CRC Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     Interrupt Flag Status
N  *
N  * @details    This macro gets the CRC interrupt flags.
N  */
N#define CRC_GET_INT_FLAG()          ((uint32_t)(CRC->DMAISR))
N
N/**
N  * @brief      Clear CRC Interrupt Flag
N  *
N  * @param[in]  u32Mask     Interrupt mask
N  *
N  * @return     None
N  *
N  * @details    This macro clear the specify CRC interrupt flag by u32Mask setting.
N  */
N#define CRC_CLR_INT_FLAG(u32Mask)   (CRC->DMAISR = (u32Mask))
N
N/**
N  * @brief      Set CRC seed value
N  *
N  * @param[in]  u32Seed     Seed value
N  *
N  * @return     None
N  *
N  * @details    This macro set CRC seed value.
N  *
N  * @note       User must to setting CRC_RST (CRC_CTL[1] CRC Engine Reset) to reload the new seed value
N  *             to CRC controller.
N  */
N#define CRC_SET_SEED(u32Seed)       { CRC->SEED = (u32Seed); CRC->CTL |= CRC_CTL_CRC_RST_Msk; }
N
N/**
N  * @brief      Get CRC Seed value
N  *
N  * @param      None
N  *
N  * @return     Seed Value
N  *
N  * @details    This macro gets the current CRC seed value.
N  */
N#define CRC_GET_SEED()              ((uint32_t)(CRC->SEED))
N
N/**
N  * @brief      CRC write data
N  *
N  * @param[in]  u32Data     write data
N  *
N  * @return     None
N  *
N  * @details    User can write data directly by this macro to perform CRC operation.
N  */
N#define CRC_WRITE_DATA(u32Data)     (CRC->WDATA = (u32Data))
N
N
N/*********************************************************************/
Nvoid CRC_Open(uint32_t u32Mode, uint32_t u32Attribute, uint32_t u32Seed, uint32_t u32DataLen);
Nvoid CRC_StartDMATransfer(uint32_t u32SrcAddr, uint32_t u32ByteCount);
Nuint32_t CRC_GetChecksum(void);
N
N/*@}*/ /* end of group CRC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CRC_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CRC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12812 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "TIMER.h"
L 1 "..\..\..\Library\StdDriver\inc\TIMER.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    Timer driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in one-shot mode */
N#define TIMER_PERIODIC_MODE                 (1UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                   (2UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in toggle-output mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in continuous counting mode */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE    (0UL << TIMER_TEXCON_RSTCAPSEL_Pos)     /*!< Timer capture event to get timer counter value */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE    (1UL << TIMER_TEXCON_RSTCAPSEL_Pos)     /*!< Timer capture event to reset timer counter */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge trigger timer capture */
N#define TIMER_CAPTURE_FALLING_AND_RISING_EDGE   (2UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Both falling and rising edge trigger timer capture */
N#define TIMER_COUNTER_FALLING_EDGE          (0UL << TIMER_TEXCON_TX_PHASE_Pos)      /*!< Counter increase on falling edge */
N#define TIMER_COUNTER_RISING_EDGE           (1UL << TIMER_TEXCON_TX_PHASE_Pos)      /*!< Counter increase on rising edge */
N
N/*@}*/ /* end of group TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set Timer Compare Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer compare value. Valid values are between 2 to 0xFFFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set new Timer compared value.
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value)        ((timer)->TCMPR = (u32Value))
N
N/**
N  * @brief      Set Timer Prescale Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer prescale value. Valid values are between 0 to 0xFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set new Timer prescale value.
N  * @note       Clock input is divided by (prescale + 1) before it is fed into timer.
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value)   ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_PRESCALE_Msk) | (u32Value))
N
N/**
N  * @brief      Check specify Timer Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer 24-bit up counter is inactive
N  * @retval     1   Timer 24-bit up counter is active
N  *
N  * @details    This macro is used to check if specify Timer channel is inactive or active.
N  */
N#define TIMER_IS_ACTIVE(timer)                      ((timer)->TCSR & TIMER_TCSR_CACT_Msk ? 1 : 0)
N
N/**
N  * @brief      Start Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer counting.
N  */
Nstatic __INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_CEN_Msk;
X    timer->TCSR |= (1ul << 30);
N}
N
N/**
N  * @brief      Stop Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop/suspend Timer counting.
N  */
Nstatic __INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_CEN_Msk;
X    timer->TCSR &= ~(1ul << 30);
N}
N
N/**
N  * @brief      Enable Timer Interrupt Wakeup Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the Timer interrupt wake-up function.
N  * @note       To wake the system from Power-down mode, timer clock source must be ether LXT or LIRC.
N  */
Nstatic __INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR |= (1ul << 23);
N}
N
N/**
N  * @brief      Disable Timer Wakeup Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the Timer interrupt wake-up function.
N  */
Nstatic __INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR &= ~(1ul << 23);
N}
N
N/**
N  * @brief      Enable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the capture pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON |= (1ul << 6);
N}
N
N/**
N  * @brief      Disable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the capture pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON &= ~(1ul << 6);
N}
N
N/**
N  * @brief      Enable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the counter pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON |= (1ul << 7);
N}
N
N/**
N  * @brief      Disable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the counter pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON &= ~(1ul << 7);
N}
N
N/**
N  * @brief      Enable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the Timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_IE_Msk;
X    timer->TCSR |= (1ul << 29);
N}
N
N/**
N  * @brief      Disable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the Timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_IE_Msk;
X    timer->TCSR &= ~(1ul << 29);
N}
N
N/**
N  * @brief      Enable Capture Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the Timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON |= (1ul << 5);
N}
N
N/**
N  * @brief      Disable Capture Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the Timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON &= ~(1ul << 5);
N}
N
N/**
N  * @brief      Get Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer time-out interrupt did not occur
N  * @retval     1   Timer time-out interrupt occurred
N  *
N  * @details    This function indicates Timer time-out interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TIF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 0) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer time-out Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears Timer time-out interrupt flag.
N  */
Nstatic __INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TIF_Msk;
X    timer->TISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer capture interrupt did not occur
N  * @retval     1   Timer capture interrupt occurred
N  *
N  * @details    This function indicates Timer capture interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->TEXISR;
N}
N
N/**
N  * @brief      Clear Timer capture Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears Timer capture interrupt flag.
N  */
Nstatic __INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->TEXISR = TIMER_TEXISR_TEXIF_Msk;
X    timer->TEXISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Wakeup Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer did not wake up system
N  * @retval     1   Timer Timer wake up system
N  *
N  * @details    This function indicates Timer has waked up system or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TWF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 1) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Wake-up Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears the Timer wake-up system flag.
N  */
Nstatic __INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TWF_Msk;
X    timer->TISR = (1ul << 1);
N}
N
N/**
N  * @brief      Get Capture value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Capture Value
N  *
N  * @details    This function reports the current timer capture data value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief      Get Counter value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Counter Value
N  *
N  * @details    This function reports the current 24-bit timer counter value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->TDR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N/*@}*/ /* end of group TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TIMER_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12813 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "WDT.h"
L 1 "..\..\..\Library\StdDriver\inc\WDT.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    WDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCR Constants Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^18 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCRALT Constants Definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 1026 * WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 130 * WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 18 * WDT clocks */
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 3 * WDT clocks */
N
N/*@}*/ /* end of group WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear WDT time-out reset system flag.
N  */
N#define WDT_CLEAR_RESET_FLAG()          (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTRF_Msk)
N
N/**
N  * @brief      Clear WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear WDT time-out interrupt flag.
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG()    (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTIF_Msk)
N
N/**
N  * @brief      Clear WDT Wake-up Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear WDT time-out wake-up system flag.
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk)) | WDT_WTCR_WTWKF_Msk)
N
N/**
N  * @brief      Get WDT Time-out Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT did not cause system reset
N  * @retval     1   WDT caused system reset
N  *
N  * @details    This macro indicate WDT time-out to reset system or not.
N  */
N#define WDT_GET_RESET_FLAG()            ((WDT->WTCR & WDT_WTCR_WTRF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt did not occur
N  * @retval     1   WDT time-out interrupt occurred
N  *
N  * @details    This macro indicate WDT time-out interrupt occurred or not.
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG()      ((WDT->WTCR & WDT_WTCR_WTIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Wake-up Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT did not wake up system
N  * @retval     1   WDT waked up system
N  *
N  * @details    This macro indicate WDT time-out waked system up or not
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG()   ((WDT->WTCR & WDT_WTCR_WTWKF_Msk)? 1 : 0)
N
N/**
N  * @brief      Reset WDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reset 18-bit WDT counter.
N  * @note       If WDT is activated and enabled to reset system, user must reset WDT counter \n
N  *             before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  */
N#define WDT_RESET_COUNTER()             (WDT->WTCR  = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk | WDT_WTCR_WTRF_Msk)) | WDT_WTCR_WTR_Msk)
N
N/**
N  * @brief      Stop WDT Counting
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function stops WDT counting and disable WDT module.
N  */
Nstatic __INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->WTCR = 0;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR = 0;
N    return;
N}
N
N/**
N  * @brief      Enable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function enable the WDT time-out interrupt.
N  */
Nstatic __INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->WTCR |= WDT_WTCR_WTIE_Msk;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR |= (1ul << 6);
N    return;
N}
N
N/**
N  * @brief      Disable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function disables the WDT time-out interrupt.
N  */
Nstatic __INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    // Do not touch write 1 clear bits
N    WDT->WTCR &= ~(WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk);
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR &= ~((1ul << 6) | (1ul << 2) | (1ul << 3) | (1ul << 5));
N    return;
N}
N
Nvoid WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WDT_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12814 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "WWDT.h"
L 1 "..\..\..\Library\StdDriver\inc\WWDT.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    WWDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* WWDTCR Constants Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_PRESCALER_1        (0 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 1 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2        (1 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 2 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_4        (2 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 4 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_8        (3 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 8 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_16       (4 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 16 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_32       (5 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 32 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_64       (6 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 64 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_128      (7 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 128 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_192      (8 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 192 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_256      (9 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 256 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_384      (10 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 384 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_512      (11 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 512 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_768      (12 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 768 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1024     (13 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1024 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1536     (14 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1536 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2048     (15 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 2048 * (64*WWDT_CLK) */
N
N#define WWDT_RELOAD_WORD        (0x00005AA5)                      /*!< Fill this value to WWDTRLD register to reload WWDT counter */
N
N/*@}*/ /* end of group WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT counter time-out reset system flag.
N  */
N#define WWDT_CLEAR_RESET_FLAG()     (WWDT->WWDTSR = WWDT_WWDTSR_WWDTRF_Msk)
N
N/**
N  * @brief      Clear WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT counter compare match interrupt flag.
N  */
N#define WWDT_CLEAR_INT_FLAG()       (WWDT->WWDTSR = WWDT_WWDTSR_WWDTIF_Msk)
N
N/**
N  * @brief      Get WWDT Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT did not cause system reset
N  * @retval     1   WWDT counter time-out caused system reset
N  *
N  * @details    This macro is used to indicate WWDT counter time-out reset system flag.
N  */
N#define WWDT_GET_RESET_FLAG()       ((WWDT->WWDTSR & WWDT_WWDTSR_WWDTRF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT counter compare match interrupt did not occur
N  * @retval     1   WWDT counter compare match interrupt occurred
N  *
N  * @details    This macro is used to indicate WWDT counter compare match interrupt occurred or not.
N  */
N#define WWDT_GET_INT_FLAG()         ((WWDT->WWDTSR & WWDT_WWDTSR_WWDTIF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Counter value
N  *
N  * @param      None
N  *
N  * @return     WWDT Counter Value
N  *
N  * @details    This macro to reflects the current WWDT counter value.
N  */
N#define WWDT_GET_COUNTER()          (WWDT->WWDTCVR)
N
N/**
N  * @brief      Reload WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reload the WWDT counter value to 0x3F.
N  * @note       After WWDT enabled, user must reload WWDT counter while current counter is less than compare value \n
N  *             and larger than 0, otherwise WWDT will cause system reset immediately.
N  */
N#define WWDT_RELOAD_COUNTER()       (WWDT->WWDTRLD = WWDT_RELOAD_WORD)
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N/*@}*/ /* end of group WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WWDT_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12815 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "RTC.h"
L 1 "..\..\..\Library\StdDriver\inc\RTC.h" 1
N/**************************************************************************//**
N * @file     rtc.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/08 2:52p $
N * @brief    RTC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __RTC_H__
N#define __RTC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup RTC_Driver RTC Driver
N  @{
N*/
N
N/** @addtogroup RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N
N#define RTC_INIT_KEY            0xA5EB1357UL    /*!< RTC Initiation Key to make RTC leaving reset state */
N#define RTC_WRITE_KEY           0x0000A965UL    /*!< RTC Access Key to enable RTC read/write accessible and kept 1024 RTC clock */
N
N#define RTC_WAIT_COUNT          0xFFFFFFFF      /*!< Initial Time-out Value */
N
N#define RTC_YEAR2000            2000            /*!< RTC Reference for compute year data */
N#define RTC_FCR_REFERENCE       32761           /*!< RTC Reference for frequency compensation */
N
N#define RTC_CLOCK_12            0               /*!< RTC as 12-hour time scale with AM and PM indication */
N#define RTC_CLOCK_24            1               /*!< RTC as 24-hour time scale */
N
N#define RTC_AM                  1               /*!< RTC as AM indication */
N#define RTC_PM                  2               /*!< RTC as PM indication */
N
N#define RTC_TICK_1_SEC          0x0UL           /*!< RTC time tick is 1 second */
N#define RTC_TICK_1_2_SEC        0x1UL           /*!< RTC time tick is 1/2 second */
N#define RTC_TICK_1_4_SEC        0x2UL           /*!< RTC time tick is 1/4 second */
N#define RTC_TICK_1_8_SEC        0x3UL           /*!< RTC time tick is 1/8 second */
N#define RTC_TICK_1_16_SEC       0x4UL           /*!< RTC time tick is 1/16 second */
N#define RTC_TICK_1_32_SEC       0x5UL           /*!< RTC time tick is 1/32 second */
N#define RTC_TICK_1_64_SEC       0x6UL           /*!< RTC time tick is 1/64 second */
N#define RTC_TICK_1_128_SEC      0x7UL           /*!< RTC time tick is 1/128 second */
N
N#define RTC_SUNDAY              0x0UL           /*!< Day of the Week is Sunday */
N#define RTC_MONDAY              0x1UL           /*!< Day of the Week is Monday */
N#define RTC_TUESDAY             0x2UL           /*!< Day of the Week is Tuesday */
N#define RTC_WEDNESDAY           0x3UL           /*!< Day of the Week is Wednesday */
N#define RTC_THURSDAY            0x4UL           /*!< Day of the Week is Thursday */
N#define RTC_FRIDAY              0x5UL           /*!< Day of the Week is Friday */
N#define RTC_SATURDAY            0x6UL           /*!< Day of the Week is Saturday */
N
N#define RTC_SNOOPER_LOW_LEVEL       0x0UL       /*!< Snooper pin detected is low-level trigger */
N#define RTC_SNOOPER_HIGH_LEVEL      0x2UL       /*!< Snooper pin detected is high-level trigger */
N#define RTC_SNOOPER_FALLING_EDGE    0x8UL       /*!< Snooper pin detected is falling-edge trigger */
N#define RTC_SNOOPER_RISING_EDGE     0xAUL       /*!< Snooper pin detected is rising-edge trigger */
N#define RTC_SNOOPER_DETECT_Msk      0xAUL       /*!< Snooper pin detected mask bits */
N
N/*@}*/ /* end of group RTC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup RTC_EXPORTED_STRUCTS RTC Exported Structs
N  @{
N*/
N/**
N  * @details    RTC define Time Data Struct
N  */
Ntypedef struct
N{
N    uint32_t u32Year;           /*!< Year value */
N    uint32_t u32Month;          /*!< Month value */
N    uint32_t u32Day;            /*!< Day value */
N    uint32_t u32DayOfWeek;      /*!< Day of week value */
N    uint32_t u32Hour;           /*!< Hour value */
N    uint32_t u32Minute;         /*!< Minute value */
N    uint32_t u32Second;         /*!< Second value */
N    uint32_t u32TimeScale;      /*!< 12-Hour, 24-Hour */
N    uint32_t u32AmPm;           /*!< Only Time Scale select 12-hr used */
N} S_RTC_TIME_DATA_T;
N
N/*@}*/ /* end of group RTC_EXPORTED_STRUCTS */
N
N
N/** @addtogroup RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Indicate is Leap Year or not
N  *
N  * @param      None
N  *
N  * @retval     0   This year is not a leap year
N  * @retval     1   This year is a leap year
N  *
N  * @details    According to current date, return this year is leap year or not.
N  */
N#define RTC_IS_LEAP_YEAR()              ((RTC->LIR & RTC_LIR_LIR_Msk)? 1:0)
N
N/**
N  * @brief      Clear RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC alarm interrupt flag.
N  */
N#define RTC_CLEAR_ALARM_INT_FLAG()      (RTC->RIIR = RTC_RIIR_AIF_Msk)
N
N/**
N  * @brief      Clear RTC Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC tick interrupt flag.
N  */
N#define RTC_CLEAR_TICK_INT_FLAG()       (RTC->RIIR = RTC_RIIR_TIF_Msk)
N
N/**
N  * @brief      Get RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC alarm interrupt did not occur
N  * @retval     1   RTC alarm interrupt occurred
N  *
N  * @details    This macro indicate RTC alarm interrupt occurred or not.
N  */
N#define RTC_GET_ALARM_INT_FLAG()        ((RTC->RIIR & RTC_RIIR_AIF_Msk)? 1:0)
N
N/**
N  * @brief      Get RTC Time Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC time tick interrupt did not occur
N  * @retval     1   RTC time tick interrupt occurred
N  *
N  * @details    This macro indicate RTC time tick interrupt occurred or not.
N  */
N#define RTC_GET_TICK_INT_FLAG()         ((RTC->RIIR & RTC_RIIR_TIF_Msk)? 1:0)
N
N/**
N  * @brief      Clear RTC Snooper Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear RTC snooper pin interrupt flag.
N  */
N#define RTC_CLEAR_SNOOPER_INT_FLAG()    (RTC->RIIR = RTC_RIIR_SNOOPIF_Msk)
N
N/**
N  * @brief      Get RTC Snooper Pin Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC snooper pin interrupt did not occur
N  * @retval     1   RTC snooper pin interrupt occurred
N  *
N  * @details    This macro indicate RTC snooper pin interrupt occurred or not.
N  */
N#define RTC_GET_SNPPOER_INT_FLAG()      ((RTC->RIIR & RTC_RIIR_SNOOPIF_Msk)? 1:0)
N
N/**
N  * @brief      Read Spare Register
N  *
N  * @param[in]  u32RegNum   The spare register number, 0~19.
N  *
N  * @return     Spare register content
N  *
N  * @details    Read the specify spare register content.
N  * @note       The returned value is valid only when SPRRDY(SPRCTL[7] SPR Register Ready) bit is set. \n
N  *             And its controlled by RTC Access Enable Register.
N  */
N#define RTC_READ_SPARE_REGISTER(u32RegNum)                  (RTC->SPR[(u32RegNum)])
N
N/**
N  * @brief      Write Spare Register
N  *
N  * @param[in]  u32RegNum    The spare register number, 0~19.
N  * @param[in]  u32RegValue  The spare register value.
N  *
N  * @return     None
N  *
N  * @details    Write specify data to spare register.
N  * @note       This macro is effect only when SPRRDY(SPRCTL[7] SPR Register Ready) bit is set. \n
N  *             And its controlled by RTC Access Enable Register.
N  */
N#define RTC_WRITE_SPARE_REGISTER(u32RegNum, u32RegValue)    (RTC->SPR[(u32RegNum)] = (u32RegValue))
N
N/**
N  * @brief      Wait RTC Access Enable
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the maximum RTC read/write accessible time.
N  */
Nstatic __INLINE void RTC_WaitAccessEnable(void)
Xstatic __inline void RTC_WaitAccessEnable(void)
N{
N    /* To wait AER bit is cleared and enable AER bit (Access bit) again */
N    while((RTC->AER & RTC_AER_ENF_Msk) == RTC_AER_ENF_Msk);
X    while((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER & (1ul << 16)) == (1ul << 16));
N    RTC->AER = RTC_WRITE_KEY;
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER = 0x0000A965UL;
N
N    /* To wait AER bit is set and user can access the RTC registers from now on */
N    while((RTC->AER & RTC_AER_ENF_Msk) == 0x0);
X    while((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER & (1ul << 16)) == 0x0);
N}
N
Nvoid RTC_Open(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_Close(void);
Nvoid RTC_32KCalibration(int32_t i32FrequencyX100);
Nvoid RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
Nvoid RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
Nvoid RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nuint32_t RTC_GetDayOfWeek(void);
Nvoid RTC_SetTickPeriod(uint32_t u32TickSelection);
Nvoid RTC_EnableInt(uint32_t u32IntFlagMask);
Nvoid RTC_DisableInt(uint32_t u32IntFlagMask);
Nvoid RTC_EnableSpareRegister(void);
Nvoid RTC_DisableSpareRegister(void);
Nvoid RTC_EnableSnooperDetection(uint32_t u32PinCondition);
Nvoid RTC_DisableSnooperDetection(void);
N
N/*@}*/ /* end of group RTC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group RTC_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__RTC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12816 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "UART.h"
L 1 "..\..\..\Library\StdDriver\inc\UART.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V3.0
N * $Revision: 6 $
N * $Date: 15/05/04 3:27p $
N * @brief    UART Interface Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N    
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART FIFO size constants definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART0_FIFO_SIZE 64 /*!< UART0 supports separated receive/transmit 64/64 bytes entry FIFO */
N#define UART1_FIFO_SIZE 16 /*!< UART1 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART2_FIFO_SIZE 16 /*!< UART2 supports separated receive/transmit 16/16 bytes entry FIFO */
N  
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE        (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 byte */
N#define UART_FCR_RFITL_4BYTES       (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bytes */
N#define UART_FCR_RFITL_8BYTES       (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bytes */
N#define UART_FCR_RFITL_14BYTES      (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bytes */
N#define UART_FCR_RFITL_30BYTES      (0x4 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 30 bytes */
N#define UART_FCR_RFITL_46BYTES      (0x5 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 46 bytes */
N#define UART_FCR_RFITL_62BYTES      (0x6 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 62 bytes */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE        (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 byte */
N#define UART_FCR_RTS_TRI_LEV_4BYTES       (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bytes */
N#define UART_FCR_RTS_TRI_LEV_8BYTES       (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bytes */
N#define UART_FCR_RTS_TRI_LEV_14BYTES      (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bytes */
N#define UART_FCR_RTS_TRI_LEV_30BYTES      (0x4 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 30 bytes */
N#define UART_FCR_RTS_TRI_LEV_46BYTES      (0x5 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 46 bytes */
N#define UART_FCR_RTS_TRI_LEV_62BYTES      (0x6 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 62 bytes */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_LOW_LEV_ACTIVE      (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Active */
N#define UART_RTS_IS_HIGH_LEV_ACTIVE     (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Active */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_IRCR constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_IRCR_TX_SELECT         (0x1 << UART_IRCR_TX_SELECT_Pos) /*!< Set IrDA function Tx mode */
N#define UART_IRCR_RX_SELECT         (0x0 << UART_IRCR_TX_SELECT_Pos) /*!< Set IrDA function Rx mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN     (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Function             */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LIN_CTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LIN_CTL_LINS_EN        (0x1UL << UART_LIN_CTL_LINS_EN_Pos)       /*!< UA_LIN_CTL setting to set LIN Slave Mode Enable */
N#define UART_LIN_CTL_LINS_HDET_EN   (0x1UL << UART_LIN_CTL_LINS_HDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Slave Header Detection Enable */
N#define UART_LIN_CTL_LINS_ARS_EN    (0x1UL << UART_LIN_CTL_LINS_ARS_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Automatic Resynchronization Mode Enable */
N#define UART_LIN_CTL_LINS_DUM_EN    (0x1UL << UART_LIN_CTL_LINS_DUM_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Divider Update Method Enable */
N#define UART_LIN_CTL_LIN_MUTE_EN    (0x1UL << UART_LIN_CTL_LIN_MUTE_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Mute Mode Enable */
N#define UART_LIN_CTL_LIN_SHD        (0x1UL << UART_LIN_CTL_LIN_SHD_Pos)       /*!< UA_LIN_CTL setting to set LIN TX Send Header Enable */
N#define UART_LIN_CTL_LIN_IDPEN      (0x1UL << UART_LIN_CTL_LIN_IDPEN_Pos)     /*!< UA_LIN_CTL setting to set LIN ID Parity Enable */
N#define UART_LIN_CTL_LIN_BKDET_EN   (0x1UL << UART_LIN_CTL_LIN_BKDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Detection Enable */
N#define UART_LIN_CTL_LIN_RX_DIS     (0x1UL << UART_LIN_CTL_LIN_RX_DIS_Pos)    /*!< UA_LIN_CTL setting to set LIN Receiver Disable */
N#define UART_LIN_CTL_BIT_ERR_EN     (0x1UL << UART_LIN_CTL_BIT_ERR_EN_Pos)    /*!< UA_LIN_CTL setting to set Bit Error Detect Enable */
N#define UART_LIN_CTL_LIN_BKFL(x)    (((x)-1) << UART_LIN_CTL_LIN_BKFL_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LIN_CTL_LIN_BS_LEN(x)  (((x)-1) << UART_LIN_CTL_LIN_BS_LEN_Pos)/*!< UA_LIN_CTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK             (0x0UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC        (0x1UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field and sync field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC_ID     (0x2UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LIN_CTL_LIN_LIN_PID(x) ((x) << UART_LIN_CTL_LIN_PID_Pos)       /*!< UA_LIN_CTL setting to set LIN PID value */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N/*@}*/ /* end of group UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode0 divider
N *
N *    @details      This macro calculate UART baudrate mode0 divider.
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)*8)) / (u32BaudRate) >> 4)-2)
N
N/**
N *    @brief        Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode2 divider
N *
N *    @details      This macro calculate UART baudrate mode2 divider.
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)/2)) / (u32BaudRate))-2)
N
N
N/**
N *    @brief        Write data
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *    @param[in]    u8Data  Data byte to transmit.
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UART_WRITE(uart, u8Data)    ((uart)->THR = (u8Data))
N
N/**
N *    @brief        Read data
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       The oldest data byte in RX FIFO.
N *
N *    @details      This macro read Rx data register.
N */
N#define UART_READ(uart)    ((uart)->RBR)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Tx FIFO is not empty
N *    @retval       >=1 Tx FIFO is empty
N *
N *    @details      This macro get Tx empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    ((uart)->FSR & UART_FSR_TX_EMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Rx FIFO is not empty
N *    @retval       >=1 Rx FIFO is empty
N *
N *    @details      This macro get Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    ((uart)->FSR & UART_FSR_RX_EMPTY_Msk)
N
N/**
N *    @brief        Check specified uart port transmission is over.
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Transmission is not over.
N *    @retval       1   Transmission is over.
N *
N *    @details      This macro return if Tx FIFO is empty and specified uart port transmission is over nor not.
N */
N#define UART_IS_TX_EMPTY(uart)    (((uart)->FSR & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos)
N
N
N/**
N *    @brief        Wait specified uart port transmission is over
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro wait specified uart port transmission is over.
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!((((uart)->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N
N/**
N *    @brief        Check RX is ready or not
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0 The number of bytes in the RX FIFO is less than the RFITL
N *    @retval       1 The number of bytes in the RX FIFO equals or larger than RFITL
N *
N *    @details      This macro check receive data available interrupt flag is set or not.
N */
N#define UART_IS_RX_READY(uart)    (((uart)->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N *    @brief        Check TX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       1 TX FIFO is full
N *    @retval       0 TX FIFO is not full
N *
N *    @details      This macro check TX FIFO is full or not.
N */
N#define UART_IS_TX_FULL(uart)    (((uart)->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N *    @brief        Check RX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       1 RX FIFO is full
N *    @retval       0 RX FIFO is not full
N *
N *    @details      This macro check RX FIFO is full or not.
N */
N#define UART_IS_RX_FULL(uart)    (((uart)->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Tx FIFO is not full.
N *    @retval       >=1 Tx FIFO is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UART_GET_TX_FULL(uart)    ((uart)->FSR & UART_FSR_TX_FULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uart   The pointer of the specified UART module.
N *
N *    @retval       0   Rx FIFO is not full.
N *    @retval       >=1 Rx FIFO is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UART_GET_RX_FULL(uart)    ((uart)->FSR & UART_FSR_RX_FULL_Msk)
N
N
N/**
N *    @brief        Enable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module.
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_LIN_IEN_Msk      : Lin bus interrupt
N *                              - UART_IER_WAKE_EN_Msk      : Wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk  : Buffer Error interrupt
N *                              - UART_IER_TOUT_IEN_Msk     : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk    : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk      : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk     : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk      : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    ((uart)->IER |= (u32eIntSel))
N
N
N/**
N *    @brief        Disable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module.
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_LIN_IEN_Msk      : Lin bus interrupt
N *                              - UART_IER_WAKE_EN_Msk      : Wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk  : Buffer Error interrupt
N *                              - UART_IER_TOUT_IEN_Msk     : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk    : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk      : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk     : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk      : Rx ready interrupt
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    ((uart)->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief        Get specified interrupt indicator status
N *
N *    @param[in]    uart            The pointer of the specified UART module.
N *    @param[in]    u32eIntTypeFlag Interrupt Type Flag, should be
N  *                                 - UART_ISR_LIN_INT_Msk      : Lin bus interrupt
N *                                  - UART_ISR_BUF_ERR_INT_Msk  : Buffer Error interrupt
N *                                  - UART_ISR_TOUT_INT_Msk     : Rx time-out interrupt
N *                                  - UART_ISR_MODEM_INT_Msk    : Modem interrupt
N *                                  - UART_ISR_RLS_INT_Msk      : Rx Line status interrupt
N *                                  - UART_ISR_THRE_INT_Msk     : Tx empty interrupt
N *                                  - UART_ISR_RDA_INT_Msk      : Rx ready interrupt
N *
N *    @retval       0 The specified interrupt is not happened.
N *                  1 The specified interrupt is happened.
N *
N *    @details      This macro get specified interrupt indicator status.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    (((uart)->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief        Set RTS pin to low
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to low.
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    (uart)->MCR |= UART_MCR_LEV_RTS_Msk;
X    (uart)->MCR |= (1ul << 9);
N    (uart)->MCR &= ~UART_MCR_RTS_Msk;
X    (uart)->MCR &= ~(1ul << 1);
N}
N
N/**
N *    @brief        Set RTS pin to high
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to high.
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    (uart)->MCR |= UART_MCR_LEV_RTS_Msk | UART_MCR_RTS_Msk;
X    (uart)->MCR |= (1ul << 9) | (1ul << 1);
N}
N
N
N/**
N *    @brief        Clear RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro clear RS-485 address byte detection flag.
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    ((uart)->FSR = UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/**
N *    @brief        Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0 Receiver detects a data that is not an address bit.
N *    @retval       1 Receiver detects a data that is an address bit.
N *
N *    @details      This macro get RS-485 address byte detection flag.
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    (((uart)->FSR  & UART_FSR_RS485_ADD_DETF_Msk) >> UART_FSR_RS485_ADD_DETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart);
Nvoid UART_DisableFlowCtrl(UART_T* uart);
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_EnableFlowCtrl(UART_T* uart);
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group UART_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
L 12817 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "I2S.h"
L 1 "..\..\..\Library\StdDriver\inc\I2S.h" 1
N/**************************************************************************//**
N * @file     i2s.h
N * @version  V3.0
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    I2S driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __I2S_H__
N#define __I2S_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2S_Driver I2S Driver
N  @{
N*/
N
N/** @addtogroup I2S_EXPORTED_CONSTANTS I2S Exported Constants
N  @{
N*/
N#define I2S_DATABIT_8           (0 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 8-bit */
N#define I2S_DATABIT_16          (1 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 16-bit */
N#define I2S_DATABIT_24          (2 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 24-bit */
N#define I2S_DATABIT_32          (3 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 32-bit */
N
N/* Audio Format */
N#define I2S_MONO                I2S_CON_MONO_Msk                   /*!< Mono channel */
N#define I2S_STEREO              0                                  /*!< Stereo channel */
N
N/* I2S Data Format */
N#define I2S_FORMAT_MSB          I2S_CON_FORMAT_Msk                 /*!< MSB data format */
N#define I2S_FORMAT_I2S          0                                  /*!< I2S data format */
N
N/* I2S Operation mode */
N#define I2S_MODE_SLAVE          I2S_CON_SLAVE_Msk                  /*!< As slave mode */
N#define I2S_MODE_MASTER         0                                  /*!< As master mode */
N
N/* I2S FIFO Threshold */
N#define I2S_FIFO_TX_LEVEL_WORD_0    0                              /*!< TX threshold is 0 word */
N#define I2S_FIFO_TX_LEVEL_WORD_1    (1 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 1 word */
N#define I2S_FIFO_TX_LEVEL_WORD_2    (2 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 2 words */
N#define I2S_FIFO_TX_LEVEL_WORD_3    (3 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 3 words */
N#define I2S_FIFO_TX_LEVEL_WORD_4    (4 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 4 words */
N#define I2S_FIFO_TX_LEVEL_WORD_5    (5 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 5 words */
N#define I2S_FIFO_TX_LEVEL_WORD_6    (6 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 6 words */
N#define I2S_FIFO_TX_LEVEL_WORD_7    (7 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 7 words */
N
N#define I2S_FIFO_RX_LEVEL_WORD_1    0                              /*!< RX threshold is 1 word */
N#define I2S_FIFO_RX_LEVEL_WORD_2    (1 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 2 words */
N#define I2S_FIFO_RX_LEVEL_WORD_3    (2 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 3 words */
N#define I2S_FIFO_RX_LEVEL_WORD_4    (3 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 4 words */
N#define I2S_FIFO_RX_LEVEL_WORD_5    (4 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 5 words */
N#define I2S_FIFO_RX_LEVEL_WORD_6    (5 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 6 words */
N#define I2S_FIFO_RX_LEVEL_WORD_7    (6 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 7 words */
N#define I2S_FIFO_RX_LEVEL_WORD_8    (7 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 8 words */
N
N/* I2S Record Channel */
N#define I2S_MONO_RIGHT          0                                  /*!< Record mono right channel */
N#define I2S_MONO_LEFT           I2S_CON_RXLCH_Msk                  /*!< Record mono left channel */
N
N/* I2S Channel */
N#define I2S_RIGHT               0                                  /*!< Select right channel */
N#define I2S_LEFT                1                                  /*!< Select left channel */
N
N/*@}*/ /* end of group I2S_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2S_EXPORTED_FUNCTIONS I2S Exported Functions
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N  * @brief  Enable zero cross detection function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return None
N  * @details This function will set RCHZCEN or LCHZCEN bit of I2SCON register to enable zero cross detection function.
N  */
Nstatic __INLINE void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CON |= I2S_CON_RCHZCEN_Msk;
X        i2s->CON |= (1ul << 16);
N    else
N        i2s->CON |= I2S_CON_LCHZCEN_Msk;
X        i2s->CON |= (1ul << 17);
N}
N
N/**
N  * @brief  Disable zero cross detection function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return None
N  * @details This function will clear RCHZCEN or LCHZCEN bit of I2SCON register to disable zero cross detection function.
N  */
Nstatic __INLINE void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CON &= ~I2S_CON_RCHZCEN_Msk;
X        i2s->CON &= ~(1ul << 16);
N    else
N        i2s->CON &= ~I2S_CON_LCHZCEN_Msk;
X        i2s->CON &= ~(1ul << 17);
N}
N
N/**
N  * @brief  Enable I2S TX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set TXDMA bit of I2SCON register to transmit data with PDMA.
N  */
N#define I2S_ENABLE_TXDMA(i2s)  ( (i2s)->CON |= I2S_CON_TXDMA_Msk )
N
N/**
N  * @brief  Disable I2S TX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear TXDMA bit of I2SCON register to disable TX DMA function.
N  */
N#define I2S_DISABLE_TXDMA(i2s) ( (i2s)->CON &= ~I2S_CON_TXDMA_Msk )
N
N/**
N  * @brief  Enable I2S RX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set RXDMA bit of I2SCON register to receive data with PDMA.
N  */
N#define I2S_ENABLE_RXDMA(i2s) ( (i2s)->CON |= I2S_CON_RXDMA_Msk )
N
N/**
N  * @brief  Disable I2S RX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear RXDMA bit of I2SCON register to disable RX DMA function.
N  */
N#define I2S_DISABLE_RXDMA(i2s) ( (i2s)->CON &= ~I2S_CON_RXDMA_Msk )
N
N/**
N  * @brief  Enable I2S TX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set TXEN bit of I2SCON register to enable I2S TX function.
N  */
N#define I2S_ENABLE_TX(i2s) ( (i2s)->CON |= I2S_CON_TXEN_Msk )
N
N/**
N  * @brief  Disable I2S TX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear TXEN bit of I2SCON register to disable I2S TX function.
N  */
N#define I2S_DISABLE_TX(i2s) ( (i2s)->CON &= ~I2S_CON_TXEN_Msk )
N
N/**
N  * @brief  Enable I2S RX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set RXEN bit of I2SCON register to enable I2S RX function.
N  */
N#define I2S_ENABLE_RX(i2s) ( (i2s)->CON |= I2S_CON_RXEN_Msk )
N
N/**
N  * @brief  Disable I2S RX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear RXEN bit of I2SCON register to disable I2S RX function.
N  */
N#define I2S_DISABLE_RX(i2s) ( (i2s)->CON &= ~I2S_CON_RXEN_Msk )
N
N/**
N  * @brief  Enable TX Mute function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set MUTE bit of I2SCON register to enable I2S TX mute function.
N  */
N#define I2S_ENABLE_TX_MUTE(i2s)  ( (i2s)->CON |= I2S_CON_MUTE_Msk )
N
N/**
N  * @brief  Disable TX Mute function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear MUTE bit of I2SCON register to disable I2S TX mute function.
N  */
N#define I2S_DISABLE_TX_MUTE(i2s) ( (i2s)->CON &= ~I2S_CON_MUTE_Msk )
N
N/**
N  * @brief  Clear TX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear TX FIFO. The internal TX FIFO pointer will be reset to FIFO start point.
N  */
N#define I2S_CLR_TX_FIFO(i2s) ( (i2s)->CON |= I2S_CON_CLR_TXFIFO_Msk )
N
N/**
N  * @brief  Clear RX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear RX FIFO. The internal RX FIFO pointer will be reset to FIFO start point.
N  */
N#define I2S_CLR_RX_FIFO(i2s) ( (i2s)->CON |= I2S_CON_CLR_RXFIFO_Msk )
N
N/**
N  * @brief  This function sets the recording source channel when mono mode is used.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Ch Left or right channel. Valid values are:
N  *                - \ref I2S_MONO_LEFT
N  *                - \ref I2S_MONO_RIGHT
N  * @return None
N  * @details This function selects the recording source channel of monaural mode.
N  */
Nstatic __INLINE void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
Xstatic __inline void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
N{
N    u32Ch == I2S_MONO_LEFT ?
X    u32Ch == (1ul << 23) ?
N    (i2s->CON |= I2S_CON_RXLCH_Msk) :
X    (i2s->CON |= (1ul << 23)) :
N    (i2s->CON &= ~I2S_CON_RXLCH_Msk);
X    (i2s->CON &= ~(1ul << 23));
N}
N
N/**
N  * @brief  Write data to I2S TX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Data The value written to TX FIFO.
N  * @return None
N  * @details This macro will write a value to TX FIFO.
N  */
N#define I2S_WRITE_TX_FIFO(i2s, u32Data)  ( (i2s)->TXFIFO = (u32Data) )
N
N/**
N  * @brief  Read RX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return The value read from RX FIFO.
N  * @details This function will return a value read from RX FIFO.
N  */
N#define I2S_READ_RX_FIFO(i2s) ( (i2s)->RXFIFO )
N
N/**
N  * @brief  Get the interrupt flag.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return The interrupt flags specified by the u32mask parameter.
N  * @details This macro will return the combination flags of I2SSTATUS register. The flags are specified by the u32mask parameter.
N  */
N#define I2S_GET_INT_FLAG(i2s, u32Mask) ( (i2s)->STATUS & (u32Mask) )
N
N/**
N  * @brief  Clear the interrupt flag.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return None
N  * @details This macro will clear the interrupt flags specified by the u32mask parameter.
N  */
N#define I2S_CLR_INT_FLAG(i2s, u32Mask) ( (i2s)->STATUS = (u32Mask) )
N
N/**
N  * @brief  Get transmit FIFO level
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return TX FIFO level
N  * @details This macro will return the number of available words in TX FIFO.
N  */
N#define I2S_GET_TX_FIFO_LEVEL(i2s) ( (((i2s)->STATUS & I2S_STATUS_TX_LEVEL_Msk) >> I2S_STATUS_TX_LEVEL_Pos) & 0xF )
N
N/**
N  * @brief  Get receive FIFO level
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return RX FIFO level
N  * @details This macro will return the number of available words in RX FIFO.
N  */
N#define I2S_GET_RX_FIFO_LEVEL(i2s) ( (((i2s)->STATUS & I2S_STATUS_RX_LEVEL_Msk) >> I2S_STATUS_RX_LEVEL_Pos) & 0xF )
N
N
N/* Function prototype declaration */
Nuint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat);
Nvoid I2S_Close(I2S_T *i2s);
Nvoid I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
Nvoid I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
Nuint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
Nvoid I2S_DisableMCLK(I2S_T *i2s);
N
N/*@}*/ /* end of group I2S_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group I2S_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 12818 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "USBD.h"
L 1 "..\..\..\Library\StdDriver\inc\USBD.h" 1
N/**************************************************************************//**
N * @file     usbd.h
N * @version  V3.0
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    USB driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N#ifndef __USBD_H__
N#define __USBD_H__
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USBD_Driver USBD Driver
N  @{
N*/
N
N/** @addtogroup USBD_EXPORTED_STRUCTS USBD Exported Structs
N  @{
N*/
N
N
Ntypedef struct s_usbd_info
N{
N    const uint8_t *gu8DevDesc;            /*!< Pointer for USB Device Descriptor          */
N    const uint8_t *gu8ConfigDesc;         /*!< Pointer for USB Configuration Descriptor   */
N    const uint8_t **gu8StringDesc;        /*!< Pointer for USB String Descriptor pointers */
N    const uint8_t *gu8HidReportDesc;      /*!< Pointer for USB HID Report Descriptor      */
N
N} S_USBD_INFO_T;
N
Nextern const S_USBD_INFO_T gsInfo;
N
N/*@}*/ /* end of group USBD_EXPORTED_STRUCTS */
N
N
N
N/** @addtogroup USBD_EXPORTED_CONSTANTS USBD Exported Constants
N  @{
N*/
N
N#define USBD_BUF_BASE   (USBD_BASE+0x100)
N
N
N
N#define USBD_MAX_EP     8
N
N#define EP0     0       /*!< Endpoint 0 */
N#define EP1     1       /*!< Endpoint 1 */
N#define EP2     2       /*!< Endpoint 2 */
N#define EP3     3       /*!< Endpoint 3 */
N#define EP4     4       /*!< Endpoint 4 */
N#define EP5     5       /*!< Endpoint 5 */
N#define EP6     6       /*!< Endpoint 6 */
N#define EP7     7       /*!< Endpoint 7 */
N
N
N/*!<USB Request Type */
N#define REQ_STANDARD        0x00
N#define REQ_CLASS           0x20
N#define REQ_VENDOR          0x40
N
N/*!<USB Standard Request */
N#define GET_STATUS          0x00
N#define CLEAR_FEATURE       0x01
N#define SET_FEATURE         0x03
N#define SET_ADDRESS         0x05
N#define GET_DESCRIPTOR      0x06
N#define SET_DESCRIPTOR      0x07
N#define GET_CONFIGURATION   0x08
N#define SET_CONFIGURATION   0x09
N#define GET_INTERFACE       0x0A
N#define SET_INTERFACE       0x0B
N#define SYNC_FRAME          0x0C
N
N/*!<USB Descriptor Type */
N#define DESC_DEVICE         0x01
N#define DESC_CONFIG         0x02
N#define DESC_STRING         0x03
N#define DESC_INTERFACE      0x04
N#define DESC_ENDPOINT       0x05
N#define DESC_QUALIFIER      0x06
N#define DESC_OTHERSPEED     0x07
N
N/*!<USB HID Descriptor Type */
N#define DESC_HID            0x21
N#define DESC_HID_RPT        0x22
N
N/*!<USB Descriptor Length */
N#define LEN_DEVICE          18
N#define LEN_CONFIG          9
N#define LEN_INTERFACE       9
N#define LEN_ENDPOINT        7
N#define LEN_HID             9
N#define LEN_CCID            0x36
N
N/*!<USB Endpoint Type */
N#define EP_ISO              0x01
N#define EP_BULK             0x02
N#define EP_INT              0x03
N
N#define EP_INPUT            0x80
N#define EP_OUTPUT           0x00
N
N/*!<USB Feature Selector */
N#define FEATURE_DEVICE_REMOTE_WAKEUP    0x01
N#define FEATURE_ENDPOINT_HALT           0x00
N
N/******************************************************************************/
N/*                USB Specific Macros                                         */
N/******************************************************************************/
N
N#define USBD_WAKEUP_EN          USBD_INTEN_WAKEUP_EN_Msk    /*!< USB Wake-up Enable */
N#define USBD_DRVSE0             USBD_DRVSE0_DRVSE0_Msk      /*!< Drive SE0 */
N
N#define USBD_DPPU_EN            USBD_ATTR_DPPU_EN_Msk       /*!< USB D+ Pull-up Enable */
N#define USBD_PWRDN              USBD_ATTR_PWRDN_Msk         /*!< PHY Turn-On */
N#define USBD_PHY_EN             USBD_ATTR_PHY_EN_Msk        /*!< PHY Enable */
N#define USBD_USB_EN             USBD_ATTR_USB_EN_Msk        /*!< USB Enable */
N
N#define USBD_INT_BUS            USBD_INTEN_BUS_IE_Msk       /*!< USB Bus Event Interrupt */
N#define USBD_INT_USB            USBD_INTEN_USB_IE_Msk       /*!< USB USB Event Interrupt */
N#define USBD_INT_FLDET          USBD_INTEN_FLDET_IE_Msk     /*!< USB Float Detect Interrupt */
N#define USBD_INT_WAKEUP         (USBD_INTEN_WAKEUP_IE_Msk | USBD_INTEN_WAKEUP_EN_Msk)   /*!< USB Wake-up Interrupt */
N
N#define USBD_INTSTS_WAKEUP      USBD_INTSTS_WAKEUP_STS_Msk  /*!< USB Wakeup Interrupt Status */
N#define USBD_INTSTS_FLDET       USBD_INTSTS_FLDET_STS_Msk   /*!< USB Float Detect Interrupt Status */
N#define USBD_INTSTS_BUS         USBD_INTSTS_BUS_STS_Msk     /*!< USB Bus Event Interrupt Status */
N#define USBD_INTSTS_USB         USBD_INTSTS_USB_STS_Msk     /*!< USB USB Event Interrupt Status */
N#define USBD_INTSTS_SETUP       USBD_INTSTS_SETUP_Msk       /*!< USB Setup Event */
N#define USBD_INTSTS_EP0         0x00010000                  /*!< USB Endpoint 0 Event */
N#define USBD_INTSTS_EP1         0x00020000                  /*!< USB Endpoint 1 Event */
N#define USBD_INTSTS_EP2         0x00040000                  /*!< USB Endpoint 2 Event */
N#define USBD_INTSTS_EP3         0x00080000                  /*!< USB Endpoint 3 Event */
N#define USBD_INTSTS_EP4         0x00100000                  /*!< USB Endpoint 4 Event */
N#define USBD_INTSTS_EP5         0x00200000                  /*!< USB Endpoint 5 Event */
N#define USBD_INTSTS_EP6         0x00400000                  /*!< USB Endpoint 6 Event */
N#define USBD_INTSTS_EP7         0x00800000                  /*!< USB Endpoint 7 Event */
N
N#define USBD_STATE_USBRST       USBD_ATTR_USBRST_Msk        /*!< USB Bus Reset */
N#define USBD_STATE_SUSPEND      USBD_ATTR_SUSPEND_Msk       /*!< USB Bus Suspend */
N#define USBD_STATE_RESUME       USBD_ATTR_RESUME_Msk        /*!< USB Bus Resume */
N#define USBD_STATE_TIMEOUT      USBD_ATTR_TIMEOUT_Msk       /*!< USB Bus Timeout */
N
N#define USBD_CFGP_SSTALL        USBD_CFGP_SSTALL_Msk        /*!< Set Stall */
N#define USBD_CFG_CSTALL         USBD_CFG_CSTALL_Msk         /*!< Clear Stall */
N
N#define USBD_CFG_EPMODE_DISABLE (0ul << USBD_CFG_STATE_Pos)/*!< Endpoint Disable */
N#define USBD_CFG_EPMODE_OUT     (1ul << USBD_CFG_STATE_Pos)/*!< Out Endpoint */
N#define USBD_CFG_EPMODE_IN      (2ul << USBD_CFG_STATE_Pos)/*!< In Endpoint */
N#define USBD_CFG_TYPE_ISO       (1ul << USBD_CFG_ISOCH_Pos) /*!< Isochronous */
N
N
N
N#define USBD_STATE_DETACHED         0x00    /*!<USB Device Detached State Definition   */
N#define USBD_STATE_ATTACHED         0x01    /*!<USB Device Attached State Definition   */
N#define USBD_STATE_DEFAULT          0x11    /*!<USB Device Default State Definition    */
N#define USBD_STATE_ADDRESS          0x31    /*!<USB Device Addressed State Definition  */
N#define USBD_STATE_CONFIGURED       0x71    /*!<USB Device Configured State Definition */
N
N#define USBD_STATE_FLAG_DEFAULT     0x10    /*!<USB Device State Default Flag    */
N#define USBD_STATE_FLAG_ADDRESS     0x20    /*!<USB Device State Addressed Flag  */
N#define USBD_STATE_FLAG_CONFIGURED  0x40    /*!<USB Device State Configured Flag */
N#define USBD_STATE_FLAG_SUSPENDED   0x80    /*!<USB Device State Suspended Flag  */
N
N
N/*@}*/ /* end of group USBD_EXPORTED_CONSTANTS */
N
N
N
N/** @addtogroup USBD_EXPORTED_FUNCTIONS USBD Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Compare two input numbers and return maximum one.
N  *
N  * @param[in]  a   First number to be compared.
N  * @param[in]  b   Second number to be compared.
N  *
N  * @return     Maximum value between a and b.
N  *
N  * @details    If a > b, then return a. Otherwise, return b.
N  */
N#define Maximum(a,b)        ((a)>(b) ? (a) : (b))
N
N
N/**
N  * @brief      Compare two input numbers and return minimum one
N  *
N  * @param[in]  a   First number to be compared
N  * @param[in]  b   Second number to be compared
N  *
N  * @return     Minimum value between a and b
N  *
N  * @details    If a < b, then return a. Otherwise, return b.
N  */
N#define Minimum(a,b)        ((a)<(b) ? (a) : (b))
N
N
N/**
N  * @brief    Enable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB and PHY.
N  *
N  */
N#define USBD_ENABLE_USB()           ((uint32_t)(USBD->ATTR |= (USBD_USB_EN|USBD_PHY_EN)))
N
N/**
N  * @brief    Disable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB.
N  *
N  */
N#define USBD_DISABLE_USB()          ((uint32_t)(USBD->ATTR &= ~USBD_USB_EN))
N
N/**
N  * @brief    Enable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB PHY.
N  *
N  */
N#define USBD_ENABLE_PHY()           ((uint32_t)(USBD->ATTR |= USBD_PHY_EN))
N
N/**
N  * @brief    Disable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB PHY.
N  *
N  */
N#define USBD_DISABLE_PHY()          ((uint32_t)(USBD->ATTR &= ~USBD_PHY_EN))
N
N/**
N  * @brief    Enable SE0. Force USB PHY transceiver to drive SE0.
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Set DRVSE0 bit of USB_DRVSE0 register to enable software-disconnect function. Force USB PHY transceiver to drive SE0 to bus.
N  *
N  */
N#define USBD_SET_SE0()              ((uint32_t)(USBD->DRVSE0 |= USBD_DRVSE0))
N
N/**
N  * @brief    Disable SE0
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Clear DRVSE0 bit of USB_DRVSE0 register to disable software-disconnect function.
N  *
N  */
N#define USBD_CLR_SE0()              ((uint32_t)(USBD->DRVSE0 &= ~USBD_DRVSE0))
N
N/**
N  * @brief       Set USB device address
N  *
N  * @param[in]   addr The USB device address.
N  *
N  * @return      None
N  *
N  * @details     Write USB device address to USB_FADDR register.
N  *
N  */
N#define USBD_SET_ADDR(addr)         (USBD->FADDR = (addr))
N
N/**
N  * @brief    Get USB device address
N  *
N  * @param    None
N  *
N  * @return   USB device address
N  *
N  * @details  Read USB_FADDR register to get USB device address.
N  *
N  */
N#define USBD_GET_ADDR()             ((uint32_t)(USBD->FADDR))
N
N/**
N  * @brief      Enable USB interrupt function
N  *
N  * @param[in]  intr The combination of the specified interrupt enable bits.
N  *             Each bit corresponds to a interrupt enable bit.
N  *             This parameter decides which interrupts will be enabled.
N  *             (USBD_INT_WAKEUP, USBD_INT_FLDET, USBD_INT_USB, USBD_INT_BUS)
N  *
N  * @return     None
N  *
N  * @details    Enable USB related interrupt functions specified by intr parameter.
N  *
N  */
N#define USBD_ENABLE_INT(intr)       (USBD->INTEN |= (intr))
N
N/**
N  * @brief    Get interrupt status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_INTSTS register
N  *
N  * @details  Return all interrupt flags of USB_INTSTS register.
N  *
N  */
N#define USBD_GET_INT_FLAG()         ((uint32_t)(USBD->INTSTS))
N
N/**
N  * @brief      Clear USB interrupt flag
N  *
N  * @param[in]  flag The combination of the specified interrupt flags.
N  *             Each bit corresponds to a interrupt source.
N  *             This parameter decides which interrupt flags will be cleared.
N  *             (USBD_INTSTS_WAKEUP, USBD_INTSTS_FLDET, USBD_INTSTS_BUS, USBD_INTSTS_USB)
N  *
N  * @return     None
N  *
N  * @details    Clear USB related interrupt flags specified by flag parameter.
N  *
N  */
N#define USBD_CLR_INT_FLAG(flag)     (USBD->INTSTS = (flag))
N
N/**
N  * @brief    Get endpoint status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_EPSTS register.
N  *
N  * @details  Return all endpoint status.
N  *
N  */
N#define USBD_GET_EP_FLAG()          ((uint32_t)(USBD->EPSTS))
N
N/**
N  * @brief    Get USB bus state
N  *
N  * @param    None
N  *
N  * @return   The value of USB_ATTR[3:0].
N  *           Bit 0 indicates USB bus reset status.
N  *           Bit 1 indicates USB bus suspend status.
N  *           Bit 2 indicates USB bus resume status.
N  *           Bit 3 indicates USB bus time-out status.
N  *
N  * @details  Return USB_ATTR[3:0] for USB bus events.
N  *
N  */
N#define USBD_GET_BUS_STATE()        ((uint32_t)(USBD->ATTR & 0xf))
N
N/**
N  * @brief    Check cable connection state
N  *
N  * @param    None
N  *
N  * @retval   0 USB cable is not attached.
N  *           1 USB cable is attached.
N  *
N  * @details  Check the connection state by FLDET bit of USB_FLDET register.
N  *
N  */
N#define USBD_IS_ATTACHED()          ((uint32_t)(USBD->FLDET & USBD_FLDET_FLDET_Msk))
N
N/**
N  * @brief      Stop USB transaction of the specified endpoint
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     None
N  *
N  * @details    Write 1 to CLRRDY bit of USB_CFGPx register to stop USB transaction of the specified endpoint.
N  *
N  */
N#define USBD_STOP_TRANSACTION(ep)   (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_CLRRDY_Msk)
N
N/**
N  * @brief      Set USB DATA1 PID for the specified endpoint
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     None
N  *
N  * @details    Set DSQ_SYNC bit of USB_CFGx register to specify the DATA1 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA1(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_DSQ_SYNC_Msk)
N
N/**
N  * @brief      Set USB DATA0 PID for the specified endpoint
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     None
N  *
N  * @details    Clear DSQ_SYNC bit of USB_CFGx register to specify the DATA0 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA0(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) &= (~USBD_CFG_DSQ_SYNC_Msk))
N
N/**
N  * @brief      Set USB payload size (IN data)
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @param[in]  size The transfer length.
N  *
N  * @return     None
N  *
N  * @details    This macro will write the transfer length to USB_MXPLDx register for IN data transaction.
N  *
N  */
N#define USBD_SET_PAYLOAD_LEN(ep, size)  (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))) = (size))
N
N/**
N  * @brief      Get USB payload size (OUT data)
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     The value of USB_MXPLDx register.
N  *
N  * @details    Get the data length of OUT data transaction by reading USB_MXPLDx register.
N  *
N  */
N#define USBD_GET_PAYLOAD_LEN(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief      Configure endpoint
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @param[in]  config The USB configuration.
N  *
N  * @return     None
N  *
N  * @details    This macro will write config parameter to USB_CFGx register of specified endpoint.
N  *
N  */
N#define USBD_CONFIG_EP(ep, config)      (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) = (config))
N
N/**
N  * @brief      Set USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @param[in]  offset The SRAM offset.
N  *
N  * @return     None
N  *
N  * @details    This macro will set the SRAM offset for the specified endpoint.
N  *
N  */
N#define USBD_SET_EP_BUF_ADDR(ep, offset)    (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))) = (offset))
N
N/**
N  * @brief      Get the offset of the specified USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     The offset of the specified endpoint buffer.
N  *
N  * @details    This macro will return the SRAM offset of the specified endpoint.
N  *
N  */
N#define USBD_GET_EP_BUF_ADDR(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))))
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. NUC123 supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state for the specified endpoint ID. Endpoint will respond STALL token automatically.
N  *
N  */
N#define USBD_SET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. NUC123 supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state for the specified endpoint ID. Endpoint will respond ACK/NAK token.
N  */
N#define USBD_CLR_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) &= ~USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. NUC123 supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) & USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief      To support byte access between USB SRAM and system SRAM
N  *
N  * @param[in]  dest Destination pointer.
N  *
N  * @param[in]  src  Source pointer.
N  *
N  * @param[in]  size Byte count.
N  *
N  * @return     None
N  *
N  * @details    This function will copy the number of data specified by size and src parameters to the address specified by dest parameter.
N  *
N  */
Nstatic __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
Xstatic __inline void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
N{
N    while(size--) *dest++ = *src++;
N}
N
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state. Endpoint will respond STALL token automatically.
N  *
N  */
Nstatic __INLINE void USBD_SetStall(uint8_t epnum)
Xstatic __inline void USBD_SetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg | (1ul << 1));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state. Endpoint will respond ACK/NAK token.
N  */
Nstatic __INLINE void USBD_ClearStall(uint8_t epnum)
Xstatic __inline void USBD_ClearStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg & ~USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg & ~(1ul << 1));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state.
N  *
N  */
Nstatic __INLINE uint32_t USBD_GetStall(uint8_t epnum)
Xstatic __inline uint32_t USBD_GetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            break;
N        }
N    }
N
N    return ((*((__IO uint32_t *)(u32CfgAddr))) & USBD_CFGP_SSTALL);
X    return ((*((volatile uint32_t *)(u32CfgAddr))) & (1ul << 1));
N}
N
N
Nextern volatile uint8_t g_usbd_RemoteWakeupEn;
Ntypedef void (*VENDOR_REQ)(void);           /*!< Functional pointer type declaration for Vendor class */
Ntypedef void (*CLASS_REQ)(void);            /*!< Functional pointer type definition for USB class request callback handler */
Ntypedef void (*SET_INTERFACE_REQ)(void);    /*!< Functional pointer type definition for USB set interface request callback handler */
Ntypedef void (*SET_CONFIG_CB)(void);       /*!< Functional pointer type declaration for USB set configuration request callback handler */
N
N/*--------------------------------------------------------------------*/
Nvoid USBD_Open(const S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
Nvoid USBD_Start(void);
Nvoid USBD_GetSetupPacket(uint8_t *buf);
Nvoid USBD_ProcessSetupPacket(void);
Nvoid USBD_StandardRequest(void);
Nvoid USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlIn(void);
Nvoid USBD_PrepareCtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlOut(void);
Nvoid USBD_SwReset(void);
Nvoid USBD_SetVendorRequest(VENDOR_REQ pfnVendorReq);
Nvoid USBD_SetConfigCallback(SET_CONFIG_CB pfnSetConfigCallback);
Nvoid USBD_LockEpStall(uint32_t u32EpBitmap);
N
N/*@}*/ /* end of group USBD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USBD_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N
N#endif //__USBD_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12819 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "PDMA.h"
L 1 "..\..\..\Library\StdDriver\inc\PDMA.h" 1
N/**************************************************************************//**
N * @file     PDMA.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 15/05/04 4:42p $
N * @brief    PDMA Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  * @{
N  */
N
N/** @addtogroup PDMA_Driver PDMA Driver
N  * @{
N  */
N
N/** @addtogroup PDMA_EXPORTED_CONSTANTS PDMA Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Data Width Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_WIDTH_8        0x00080000UL            /*!<DMA Transfer Width 8-bit */
N#define PDMA_WIDTH_16       0x00100000UL            /*!<DMA Transfer Width 16-bit */
N#define PDMA_WIDTH_32       0x00000000UL            /*!<DMA Transfer Width 32-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Address Attribute Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SAR_INC        0x00000000UL            /*!<DMA SAR increment */
N#define PDMA_SAR_FIX        0x00000020UL            /*!<DMA SAR fix address */
N#define PDMA_DAR_INC        0x00000000UL            /*!<DMA DAR increment */
N#define PDMA_DAR_FIX        0x00000080UL            /*!<DMA DAR fix address */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Peripheral Transfer Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SPI0_TX        0x00000000UL            /*!<DMA Connect to SPI0 TX */
N#define PDMA_SPI1_TX        0x00000001UL            /*!<DMA Connect to SPI1 TX */
N#define PDMA_SPI2_TX        0x00000002UL            /*!<DMA Connect to SPI2 TX */
N#define PDMA_SPI3_TX        0x00000003UL            /*!<DMA Connect to SPI2 TX */
N#define PDMA_UART0_TX       0x00000004UL            /*!<DMA Connect to UART0 TX */
N#define PDMA_UART1_TX       0x00000005UL            /*!<DMA Connect to UART1 TX */
N#define PDMA_I2S_TX         0x00000006UL            /*!<DMA Connect to I2S TX */
N#define PDMA_SPI0_RX        0x00000007UL            /*!<DMA Connect to SPI0 RX */
N#define PDMA_SPI1_RX        0x00000008UL            /*!<DMA Connect to SPI1 RX */
N#define PDMA_SPI2_RX        0x00000009UL            /*!<DMA Connect to SPI2 RX */
N#define PDMA_SPI3_RX        0x0000000AUL            /*!<DMA Connect to SPI2 RX */
N#define PDMA_UART0_RX       0x0000000BUL            /*!<DMA Connect to UART0 RX */
N#define PDMA_UART1_RX       0x0000000CUL            /*!<DMA Connect to UART1 RX */
N#define PDMA_I2S_RX         0x0000000DUL            /*!<DMA Connect to I2S RX */
N#define PDMA_ADC            0x0000000EUL            /*!<DMA Connect to ADC */
N#define PDMA_MEM            0x0000001FUL            /*!<DMA Connect to Memory */
N
N
N/*@}*/ /* end of group PDMA_EXPORTED_CONSTANTS */
N
N/** @addtogroup PDMA_EXPORTED_FUNCTIONS PDMA Exported Functions
N  @{
N*/
N
N/**
N * @brief       Get PDMA Global Interrupt Status
N *
N * @param       None
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the global interrupt status.
N */
N#define PDMA_GET_INT_STATUS()   ((uint32_t)(PDMA_GCR->GCRISR))
N
N/**
N * @brief       Get PDMA Channel Interrupt Status
N *
N * @param[in]   u32Ch   Selected DMA channel
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the channel interrupt status.
N */
N#define PDMA_GET_CH_INT_STS(u32Ch)   (*((__IO uint32_t *)((uint32_t)&PDMA0->ISR + (uint32_t)((u32Ch)*0x100))))
N
N/**
N * @brief       Clear PDMA Channel Interrupt Flag
N *
N * @param[in]   u32Ch   Selected DMA channel
N * @param[in]   u32Mask Interrupt Mask
N *
N * @return      None
N *
N * @details     This macro clear the channel interrupt flag.
N */
N#define PDMA_CLR_CH_INT_FLAG(u32Ch, u32Mask)   (*((__IO uint32_t *)((uint32_t)&PDMA0->ISR + (uint32_t)((u32Ch)*0x100))) = (u32Mask))
N
N/**
N * @brief       Check Channel Status
N *
N * @param[in]   u32Ch    The selected channel
N *
N * @retval      0        The selected channel is idle
N * @retval      1        The selected channel is busy
N *
N * @details     Check the selected channel is busy or not.
N */
N#define PDMA_IS_CH_BUSY(u32Ch)    ((*((__IO uint32_t *)((uint32_t)&PDMA0->CSR +(uint32_t)((u32Ch)*0x100)))&PDMA_CSR_TRIG_EN_Msk)? 1 : 0)
N
N/**
N * @brief       Set Source Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel source address.
N */
N#define PDMA_SET_SRC_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA0->SAR + (uint32_t)((u32Ch)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Destination Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel destination address.
N */
N#define PDMA_SET_DST_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA0->DAR + (uint32_t)((u32Ch)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Transfer Count
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Count  Transfer Count
N *
N * @return      None
N *
N * @details     This macro set the selected channel transfer count.
N * \hideinitializer
N */
N#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) {   \
N    if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_32)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 2);  \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_8)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = (u32Count); \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_16) \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 1);  \
N}
X#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) {       if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_32)          *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 2);      else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_8)          *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = (u32Count);     else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_16)         *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 1);  }
N
N/**
N * @brief       Stop the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro stop the selected channel.
N */
N#define PDMA_STOP(u32Ch) (*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) &= ~PDMA_CSR_PDMACEN_Msk)
N
Nvoid PDMA_Open(uint32_t u32Mask);
Nvoid PDMA_Close(void);
Nvoid PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
Nvoid PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
Nvoid PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Periphral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
Nvoid PDMA_Trigger(uint32_t u32Ch);
Nvoid PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
Nvoid PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);
N
N
N/**
N  * @} End of PDMA Device Function Interface
N  */
N
N/**
N  * @} End of Function Interface
N  */
N
N/**
N  * @} End of Device_Driver
N  */
N
N
N
N#endif  // __PDMA_H__ 
L 12820 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "SC.h"
L 1 "..\..\..\Library\StdDriver\inc\SC.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/12 2:30p $
N * @brief    Smartcard (SC) driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SC_H__
N#define __SC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SC_Driver SC Driver
N  @{
N*/
N
N/** @addtogroup SC_EXPORTED_CONSTANTS SC Exported Constants
N  @{
N*/
N#define SC_INTERFACE_NUM        3                /*!< Smartcard interface numbers */
N#define SC_PIN_STATE_HIGH       1                /*!< Smartcard pin status high   */
N#define SC_PIN_STATE_LOW        0                /*!< Smartcard pin status low    */
N#define SC_PIN_STATE_IGNORE     0xFFFFFFFF       /*!< Ignore pin status           */
N#define SC_CLK_ON               1                /*!< Smartcard clock on          */
N#define SC_CLK_OFF              0                /*!< Smartcard clock off         */
N
N#define SC_TMR_MODE_0                   (0ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 0, down count                                                      */
N#define SC_TMR_MODE_1                   (1ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 1, down count, start after detect start bit                        */
N#define SC_TMR_MODE_2                   (2ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 2, down count, start after receive start bit                       */
N#define SC_TMR_MODE_3                   (3ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 3, down count, use for activation, only timer 0 support this mode  */
N#define SC_TMR_MODE_4                   (4ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 4, down count with reload after timeout                            */
N#define SC_TMR_MODE_5                   (5ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 5, down count, start after detect start bit, reload after timeout  */
N#define SC_TMR_MODE_6                   (6ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 6, down count, start after receive start bit, reload after timeout */
N#define SC_TMR_MODE_7                   (7ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 7, down count, start and reload after detect start bit             */
N#define SC_TMR_MODE_8                   (8ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 8, up count                                                        */
N#define SC_TMR_MODE_F                   (0xF << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 15, down count, reload after detect start bit                      */
N
N
N/*@}*/ /* end of group SC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SC_EXPORTED_FUNCTIONS SC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Enable smartcard interrupt.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Interrupt mask to be enabled. A combination of
N  *             - \ref SC_IER_ACON_ERR_IE_Msk
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_INIT_IE_Msk
N  *             - \ref SC_IER_CD_IE_Msk
N  *             - \ref SC_IER_BGT_IE_Msk
N  *             - \ref SC_IER_TMR2_IE_Msk
N  *             - \ref SC_IER_TMR1_IE_Msk
N  *             - \ref SC_IER_TMR0_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * @details The macro is used to enable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *          Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *          Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_ENABLE_INT(sc, u32Mask) ((sc)->IER |= (u32Mask))
N
N/**
N  * @brief Disable smartcard interrupt.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Interrupt mask to be disabled. A combination of
N  *             - \ref SC_IER_ACON_ERR_IE_Msk
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_INIT_IE_Msk
N  *             - \ref SC_IER_CD_IE_Msk
N  *             - \ref SC_IER_BGT_IE_Msk
N  *             - \ref SC_IER_TMR2_IE_Msk
N  *             - \ref SC_IER_TMR1_IE_Msk
N  *             - \ref SC_IER_TMR0_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * @details The macro is used to disable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *          Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *          Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_DISABLE_INT(sc, u32Mask) ((sc)->IER &= ~(u32Mask))
N
N/**
N  * @brief This macro set VCC pin state of smartcard interface.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32State Pin state of VCC pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in high or low level.
N  * \hideinitializer
N  */
N#define SC_SET_VCC_PIN(sc, u32State) \
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32State))\
N                (sc)->PINCSR |= SC_PINCSR_POW_EN_Msk;\
N            else\
N                (sc)->PINCSR &= ~SC_PINCSR_POW_EN_Msk;\
N    }while(0)
X#define SC_SET_VCC_PIN(sc, u32State)     do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32State))                (sc)->PINCSR |= SC_PINCSR_POW_EN_Msk;            else                (sc)->PINCSR &= ~SC_PINCSR_POW_EN_Msk;    }while(0)
N
N
N/**
N  * @brief Set CLK output status.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32OnOff Clock on or off for selected smartcard module, valid values are:
N  *                 \ref SC_CLK_ON    :Smartcard clock on.
N  *                 \ref SC_CLK_OFF   :Smartcard clock off.
N  * @return None
N  * @details User can set CLK_KEEP (SC_PINCSR[6]) to decide SC_CLK pin always keeps free running or not.
N  * \hideinitializer
N  */
N#define SC_SET_CLK_PIN(sc, u32OnOff)\
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32OnOff))\
N                (sc)->PINCSR |= SC_PINCSR_CLK_KEEP_Msk;\
N            else\
N                (sc)->PINCSR &= ~(SC_PINCSR_CLK_KEEP_Msk);\
N    }while(0)
X#define SC_SET_CLK_PIN(sc, u32OnOff)    do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32OnOff))                (sc)->PINCSR |= SC_PINCSR_CLK_KEEP_Msk;            else                (sc)->PINCSR &= ~(SC_PINCSR_CLK_KEEP_Msk);    }while(0)
N
N/**
N  * @brief Set I/O pin state.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32State Pin state of I/O pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set SC_DATA_O(SC_PINCSR[9]) to decide SC_DATA_O pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_IO_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32State))\
N                (sc)->PINCSR |= SC_PINCSR_SC_DATA_O_Msk;\
N            else\
N                (sc)->PINCSR &= ~SC_PINCSR_SC_DATA_O_Msk;\
N    }while(0)
X#define SC_SET_IO_PIN(sc, u32State)    do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32State))                (sc)->PINCSR |= SC_PINCSR_SC_DATA_O_Msk;            else                (sc)->PINCSR &= ~SC_PINCSR_SC_DATA_O_Msk;    }while(0)
N
N/**
N  * @brief Set RST pin state.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32State Pin state of RST pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set SC_RST(SC_PINCSR[1]) to decide SC_RST pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_RST_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32State))\
N                (sc)->PINCSR |= SC_PINCSR_SC_RST_Msk;\
N            else\
N                (sc)->PINCSR &= ~SC_PINCSR_SC_RST_Msk;\
N    }while(0)
X#define SC_SET_RST_PIN(sc, u32State)    do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32State))                (sc)->PINCSR |= SC_PINCSR_SC_RST_Msk;            else                (sc)->PINCSR &= ~SC_PINCSR_SC_RST_Msk;    }while(0)
N
N/**
N  * @brief Read one byte from smartcard module receive FIFO.
N  * @param[in] sc The pointer of smartcard module.
N  * @return One byte read from receive FIFO.
N  * @details By reading RBR register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SC_READ(sc) ((char)((sc)->RBR))
N
N/**
N  * @brief Write one byte to smartcard module transmit FIFO.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u8Data Data to write to transmit FIFO.
N  * @return None
N  * @details By writing data to THR register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SC_WRITE(sc, u8Data) ((sc)->THR = (u8Data))
N
N/**
N  * @brief This macro set smartcard stop bit length.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Len Stop bit length, ether 1 or 2.
N  * @return None
N  * @details Stop bit length must be 1 for T = 1 protocol and 2 for T = 0 protocol.
N  * \hideinitializer
N  */
N#define SC_SET_STOP_BIT_LEN(sc, u32Len) ((sc)->CTL = ((sc)->CTL & ~SC_CTL_SLEN_Msk) | ((u32Len) == 1 ? SC_CTL_SLEN_Msk : 0))
N
N/**
N  * @brief Enable/Disable Tx error retry, and set Tx error retry count.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Count The number of times of Tx error retry count, between 0~8. 0 means disable Tx error retry.
N  * @return None
N  * @details This macro enable/disable transmitter retry function when parity error has occurred, and set error retry count.
N  */
N__STATIC_INLINE void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (1ul << 30));
N    if((u32Count) == 0)         // disable Tx error retry
N    {
N        (sc)->CTL &= ~(SC_CTL_TX_ERETRY_Msk | SC_CTL_TX_ERETRY_EN_Msk);
X        (sc)->CTL &= ~((7ul << 20) | (1ul << 23));
N    }
N    else
N    {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_TX_ERETRY_Msk) | (((u32Count) - 1) << SC_CTL_TX_ERETRY_Pos) | SC_CTL_TX_ERETRY_EN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(7ul << 20)) | (((u32Count) - 1) << 20) | (1ul << 23);
N    }
N}
N
N/**
N  * @brief Enable/Disable Rx error retry, and set Rx error retry count.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Count The number of times of Rx error retry count, between 0~8. 0 means disable Rx error retry.
N  * @return None
N  * @details This macro enable/disable receiver retry function when parity error has occurred, and set error retry count.
N  */
N__STATIC_INLINE void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (1ul << 30));
N    if((u32Count) == 0)         // disable Rx error retry
N    {
N        (sc)->CTL &= ~(SC_CTL_RX_ERETRY_Msk | SC_CTL_RX_ERETRY_EN_Msk);
X        (sc)->CTL &= ~((7ul << 16) | (1ul << 19));
N    }
N    else
N    {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_RX_ERETRY_Msk) | (((u32Count) - 1) << SC_CTL_RX_ERETRY_Pos) | SC_CTL_RX_ERETRY_EN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(7ul << 16)) | (((u32Count) - 1) << 16) | (1ul << 19);
N    }
N}
N
N
Nuint32_t SC_IsCardInserted(SC_T *sc);
Nvoid SC_ClearFIFO(SC_T *sc);
Nvoid SC_Close(SC_T *sc);
Nvoid SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
Nvoid SC_ResetReader(SC_T *sc);
Nvoid SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
Nvoid SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
Nvoid SC_StopAllTimer(SC_T *sc);
Nvoid SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
Nvoid SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);
N
N
N/*@}*/ /* end of group SC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SC_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12821 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "PS2.h"
L 1 "..\..\..\Library\StdDriver\inc\PS2.h" 1
N/**************************************************************************//**
N * @file     PS2.h
N * @version  V3.00
N * $Revision: 3 $
N * $Date: 15/05/07 7:51p $
N * @brief     PS/2 Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __PS2_H__
N#define __PS2_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PS2_Driver PS2 Driver
N  @{
N*/
N
N
N/** @addtogroup PS2_EXPORTED_FUNCTIONS PS2 Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N *  @brief     To Set PS/2 Tx FIFO length
N *
N *  @param[in] u32Count    Tx FIFO length
N *
N *  @return    None
N *
N *  @details   Before PS/2 data transmit, program needs to set the FIFO depth.
N * \hideinitializer
N */
N#define PS2_SET_TX_BYTE_CNT(u32Count) (PS2->PS2CON = (PS2->PS2CON & ~PS2_PS2CON_TXFIFO_DEPTH_Msk) \
N                                      | ((u32Count-1) << PS2_PS2CON_TXFIFO_DEPTH_Pos))
X#define PS2_SET_TX_BYTE_CNT(u32Count) (PS2->PS2CON = (PS2->PS2CON & ~PS2_PS2CON_TXFIFO_DEPTH_Msk)                                       | ((u32Count-1) << PS2_PS2CON_TXFIFO_DEPTH_Pos))
N
N/**
N *  @brief     This function use to Get PS/2 Status
N *
N *  @param     None
N *
N *  @return    PS/2 bus status
N *
N *  @details   To get PS/2 bus status which are about Byte index, Tx/Rx status, Error status and PS/2 line status.
N */
N#define PS2_GET_STATUS() (PS2->PS2STATUS)
N
N/**
N *  @brief     This function is used to Clear PS/2 Status
N *
N *  @param[in] u32Mask    Clear the specified status of PS/2 module:
N *                        1. PS2D_PS2STATUS_FRAMERR_Msk 2. PS2D_PS2STATUS_RXOVF_Msk
N *
N *  @return    None
N *
N *  @details   To clear PS/2 bus status which are about Byte index, TX/RX status, Error status, PS/2 line status.
N */
N#define PS2_CLR_STATUS(u32Mask) (PS2->PS2STATUS = (u32Mask))
N
N/**
N *  @brief     This function is used to Clear PS/2 Tx FIFO
N *
N *  @param     None
N *
N *  @return    None
N *
N *  @details   Write 1 to terminate PS/2 device to host transmission.
N *
N *  @note      Write 1 is always clear Tx FIFO, and need write 0 to STOP the clear action.
N */
N__STATIC_INLINE void PS2_CLEAR_TX_FIFO(void)
Xstatic __inline void PS2_CLEAR_TX_FIFO(void)
N{
N    PS2->PS2CON |= PS2_PS2CON_CLRFIFO_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON |= (1ul << 8);
N    PS2->PS2CON &= ~PS2_PS2CON_CLRFIFO_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= ~(1ul << 8);
N}
N
N/**
N *  @brief    This function is used to Clear PS2 Rx interrupt
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To disable PS/2 receive interrupt occurs.
N */
N#define PS2_CLR_RX_INT_FLAG() (PS2->PS2INTID = PS2_PS2INTID_RXINT_Msk)
N
N/**
N *  @brief    This function is used to Clear PS/2 Tx Interrupt
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To disable PS/2 transmit interrupt occurs.
N */
N#define PS2_CLR_TX_INT_FLAG() (PS2->PS2INTID = PS2_PS2INTID_TXINT_Msk)
N
N/**
N *  @brief     This function is used to Get PS/2 Interrupt
N *
N *  @param[in] u32IntFlag  Interrupt flag of PS2D_PS2INTID_TXINT_Msk, PS2D_PS2INTID_RXINT_Msk
N *
N *  @retval    1 Interrupt occurs
N *  @retval    0 Interrupt not occurs
N *
N *  @details   To check PS/2 bus interrupt occur from TX or RX
N */
N#define PS2_GET_INT_FLAG(u32IntFlag) ((PS2->PS2INTID & (u32IntFlag))?1:0)
N
N/**
N *  @brief    Disable PS2CLK and PS2DATA pins override.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To disable the override control of PS2CLK and PS2DATA pins.
N */
N#define PS2_DISABLE_OVERRIDE() (PS2->PS2CON &= ~PS2_PS2CON_OVERRIDE_Msk)
N
N/**
N *  @brief    Enable PS2CLK and PS2DATA pins Override.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  TO enable the override control of PS2CLK and PS2DATA pins.
N */
N#define PS2_ENABLE_OVERRIDE() (PS2->PS2CON |= PS2_PS2CON_OVERRIDE_Msk)
N
N/**
N *  @brief    This function is used to Get Indicates which data byte in transmit data shift register
N *
N *  @param    None
N *
N *  @return   The indicates which data byte in transmit data shift register.
N *
N *  @details  To get a indication which a data byte in the data shift register.
N */
N#define PS2_GET_TX_BYTE_INDEX() ((PS2->PS2STATUS & PS2_PS2STATUS_BYTEIDX_Msk) >> PS2_PS2STATUS_BYTEIDX_Pos)
N
N/**
N *  @brief    This function is used to set PS2DATA Pin low.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2DATA pin state to low.
N */
N#define PS2_SET_DATA_LOW() (PS2->PS2CON &= ~PS2_PS2CON_FPS2DAT_Msk)
N
N/**
N *  @brief    This function is used to set PS2DATA Pin high
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2DATA pin state to high.
N */
N#define PS2_SET_DATA_HIGH() (PS2->PS2CON |= PS2_PS2CON_FPS2DAT_Msk)
N
N/**
N *  @brief    This function is used to set PS2CLK Pin low.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2CLK pin state to low.
N */
N#define PS2_SET_CLK_LOW() (PS2->PS2CON &= ~PS2_PS2CON_FPS2CLK_Msk)
N
N/**
N *  @brief    This function is used to set PS2CLK Pin high.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2CLK pin state to high.
N */
N#define PS2_SET_CLK_HIGH() (PS2->PS2CON |= PS2_PS2CON_FPS2CLK_Msk)
N
N/**
N *  @brief    Disable always sends acknowledge
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  If parity error or Stop bit is not received correctly, acknowledge will not be sent to host at 12th clock.
N */
N#define PS2_DISABLE_ACK_ALWAYS() (PS2->PS2CON |= PS2_PS2CON_ACK_Msk)
N
N/**
N *  @brief    Always sends acknowledge
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  Always send acknowledge to host at 12th clock for host to device communication.
N */
N#define PS2_ENABLE_ACK_ALWAYS() (PS2->PS2CON &= ~PS2_PS2CON_ACK_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Function Prototypes                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
Nvoid PS2_Open(void);
Nvoid PS2_Close(void);
Nuint8_t PS2_Read(void);
Nint32_t PS2_Write(uint32_t *pu32Buf, uint32_t u32ByteCount);
Nvoid PS2_EnableInt(uint32_t u32Mask);
Nvoid PS2_DisableInt(uint32_t u32Mask);
N
N
N/*@}*/ /* end of group PS2_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PS2_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PS2_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 12822 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "CLK.h"
L 1 "..\..\..\Library\StdDriver\inc\CLK.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V3.0
N * $Revision: 6 $
N * $Date: 15/05/04 3:27p $
N * @brief    Clock Control Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_100MHZ       100000000
N#define FREQ_200MHZ       200000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLK_S_HXT          (0x0UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as external X'tal */
N#define CLK_CLKSEL0_HCLK_S_LXT          (0x1UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as external X'tal 32.768KHz*/
N#define CLK_CLKSEL0_HCLK_S_PLL          (0x2UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as PLL output */
N#define CLK_CLKSEL0_HCLK_S_LIRC         (0x3UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_HIRC         (0x7UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL0_STCLK_S_HXT         (0x0UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal */
N#define CLK_CLKSEL0_STCLK_S_LXT         (0x1UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal 32.768KHz*/
N#define CLK_CLKSEL0_STCLK_S_HXT_DIV2    (0x2UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK_DIV2   (0x3UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLK_S_HIRC_DIV2   (0x7UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as internal 22.1184MHz RC clock/2 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDT_S_LXT           (0x1UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as external X'tal 32.768KHz*/
N#define CLK_CLKSEL1_WDT_S_HCLK_DIV2048  (0x2UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDT_S_LIRC          (0x3UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as internal 10KHz RC clock */
N
N#define CLK_CLKSEL1_ADC_S_HXT           (0x0UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as external X'tal */
N#define CLK_CLKSEL1_ADC_S_PLL           (0x1UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as PLL */
N#define CLK_CLKSEL1_ADC_S_HCLK          (0x2UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADC_S_HIRC          (0x3UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_SPI0_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI0_S_Pos)   /*!< Setting SPI0 clock source as PLL */
N#define CLK_CLKSEL1_SPI0_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI0_S_Pos)   /*!< Setting SPI0 clock source as HCLK */
N#define CLK_CLKSEL1_SPI1_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI1_S_Pos)   /*!< Setting SPI1 clock source as PLL */
N#define CLK_CLKSEL1_SPI1_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI1_S_Pos)   /*!< Setting SPI1 clock source as HCLK */
N#define CLK_CLKSEL1_SPI2_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI2_S_Pos)   /*!< Setting SPI2 clock source as PLL */
N#define CLK_CLKSEL1_SPI2_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI2_S_Pos)   /*!< Setting SPI2 clock source as HCLK */
N#define CLK_CLKSEL1_SPI3_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI3_S_Pos)   /*!< Setting SPI3 clock source as PLL */
N#define CLK_CLKSEL1_SPI3_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI3_S_Pos)   /*!< Setting SPI3 clock source as HCLK */
N
N#define CLK_CLKSEL1_TMR0_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR0_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR0_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external trigger */
N#define CLK_CLKSEL1_TMR0_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR1_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR1_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external trigger */
N#define CLK_CLKSEL1_TMR1_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR2_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR2_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR2_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as HCLK */
N#define CLK_CLKSEL1_TMR2_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external trigger */
N#define CLK_CLKSEL1_TMR2_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR2_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR3_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR3_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR3_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as HCLK */
N#define CLK_CLKSEL1_TMR3_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external trigger */
N#define CLK_CLKSEL1_TMR3_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR3_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_UART_S_HXT          (0x0UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external X'tal */
N#define CLK_CLKSEL1_UART_S_PLL          (0x1UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external PLL */
N#define CLK_CLKSEL1_UART_S_HIRC         (0x3UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_PWM01_S_HXT         (0x0UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as external X'tal, 
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL1_PWM01_S_LXT         (0x1UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL1_PWM01_S_HCLK        (0x2UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as HCLK 
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL1_PWM01_S_HIRC        (0x3UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL1_PWM01_S_LIRC        (0x3UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL1_PWM23_S_HXT         (0x0UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL1_PWM23_S_LXT         (0x1UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL1_PWM23_S_HCLK        (0x2UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL1_PWM23_S_HIRC        (0x3UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL1_PWM23_S_LIRC        (0x3UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_I2S_S_HXT           (0x0UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as external X'tal */
N#define CLK_CLKSEL2_I2S_S_PLL           (0x1UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as PLL */
N#define CLK_CLKSEL2_I2S_S_HCLK          (0x2UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as HCLK */
N#define CLK_CLKSEL2_I2S_S_HIRC          (0x3UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL2_FRQDIV_S_HXT        (0x0UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as external X'tal */
N#define CLK_CLKSEL2_FRQDIV_S_LXT        (0x1UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL2_FRQDIV_S_HCLK       (0x2UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as HCLK */
N#define CLK_CLKSEL2_FRQDIV_S_HIRC       (0x3UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL2_PWM45_S_HXT         (0x0UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM45_S_LXT         (0x1UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM45_S_HCLK        (0x2UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM45_S_HIRC        (0x3UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM45_S_LIRC        (0x3UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N#define CLK_CLKSEL2_PWM67_S_HXT         (0x0UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM67_S_LXT         (0x1UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM67_S_HCLK        (0x2UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM67_S_HIRC        (0x3UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM67_S_LIRC        (0x3UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM01_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM01_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM01_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM01_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM01_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM01_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM01_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM01_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM01_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM01_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM23_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM23_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM23_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM23_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM23_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM23_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM23_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM23_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM23_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM23_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM45_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM45_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM45_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM45_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM45_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM45_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM45_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM45_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM45_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM45_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM67_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM67_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM67_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM67_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM67_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM67_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM67_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM67_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM67_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM67_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_WWDT_S_HCLK_DIV2048 (0x2UL<<CLK_CLKSEL2_WWDT_S_Pos)   /*!< Setting WWDT clock source as HCLK/2048 */
N#define CLK_CLKSEL2_WWDT_S_LIRC         (0x3UL<<CLK_CLKSEL2_WWDT_S_Pos)   /*!< Setting WWDT clock source as internal 10KHz RC clock */
N
N#define CLK_CLKSEL2_RTC_SEL_10K_LXT     (0x0UL<<CLK_CLKSEL2_RTC_SEL_10K_Pos)   /*!< Setting WWDT clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL2_RTC_SEL_10K_LIRC    (0x1UL<<CLK_CLKSEL2_RTC_SEL_10K_Pos)   /*!< Setting WWDT clock source as internal 10KHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL3 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL3_SC0_S_HXT           (0x0UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as external X'tal */
N#define CLK_CLKSEL3_SC0_S_PLL           (0x1UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as PLL */
N#define CLK_CLKSEL3_SC0_S_HCLK          (0x2UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as HCLK */
N#define CLK_CLKSEL3_SC0_S_HIRC          (0x3UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL3_SC1_S_HXT           (0x0UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as external X'tal */
N#define CLK_CLKSEL3_SC1_S_PLL           (0x1UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as PLL */
N#define CLK_CLKSEL3_SC1_S_HCLK          (0x2UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as HCLK */
N#define CLK_CLKSEL3_SC1_S_HIRC          (0x3UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL3_SC2_S_HXT           (0x0UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as external X'tal */
N#define CLK_CLKSEL3_SC2_S_PLL           (0x1UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as PLL */
N#define CLK_CLKSEL3_SC2_S_HCLK          (0x2UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as HCLK */
N#define CLK_CLKSEL3_SC2_S_HIRC          (0x3UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as internal 22.1184MHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)                             /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_CLKDIV_USB(x)  (((x)-1) << CLK_CLKDIV_USB_N_Pos)    /*!< CLKDIV Setting for USB clock divider. It could be 1~16  */
N#define CLK_CLKDIV_UART(x) (((x)-1) << CLK_CLKDIV_UART_N_Pos)   /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << CLK_CLKDIV_ADC_N_Pos)    /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV1_SC0(x)  (((x)-1) << CLK_CLKDIV1_SC0_N_Pos)  /*!< CLKDIV1 Setting for SC0 clock divider. It could be 1~256*/
N#define CLK_CLKDIV1_SC1(x)  (((x)-1) << CLK_CLKDIV1_SC1_N_Pos)  /*!< CLKDIV1 Setting for SC1 clock divider. It could be 1~256*/
N#define CLK_CLKDIV1_SC2(x)  (((x)-1) << CLK_CLKDIV1_SC2_N_Pos)  /*!< CLKDIV1 Setting for SC2 clock divider. It could be 1~256*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCON constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCON_PLL_SRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT. 4MHz < FIN < 24MHz */
N#define CLK_PLLCON_PLL_SRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC.4MHz < FIN < 24MHz */
N
N#define CLK_PLLCON_NR(x)         (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 15MHz */
N#define CLK_PLLCON_NF(x)          ((x)-2)        /*!< x must be constant and 2 <= x <= 513. 100MHz < FIN*NF/NR < 200MHz. (120MHz < FIN*NF/NR < 200MHz is preferred.) */
N
N#define CLK_PLLCON_NO_1          0x0000UL        /*!< For output divider is 1 */
N#define CLK_PLLCON_NO_2          0x4000UL        /*!< For output divider is 2 */
N#define CLK_PLLCON_NO_4          0xC000UL        /*!< For output divider is 4 */
N
N#if (__HXT == 12000000)
X#if ((12000000UL) == 12000000)
N#define CLK_PLLCON_FOR_I2S     (0xA54)                                                                            /*!< Predefined PLLCON setting for 147428571.428571Hz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_50MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(3) | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_48MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(7) | CLK_PLLCON_NF(112) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_36MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(7) | CLK_PLLCON_NF( 84) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 36MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_32MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(6) | CLK_PLLCON_NF( 64) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 32MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_25MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(3) | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 25MHz PLL output with 12MHz X'tal */
N#else
S# error "The PLL pre-definitions are only valid when external crystal is 12MHz"
N#endif
N
N#define CLK_PLLCON_50MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50.1918MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_48MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF(113) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48.064985MHz PLL output with 22.1184MHz IRC*/
N#define CLK_PLLCON_36MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(12) | CLK_PLLCON_NF( 78) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 35.9424MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_32MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR( 9) | CLK_PLLCON_NF( 52) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 31.9488MHz PLL output with 22.1184MHz IRC*/
N#define CLK_PLLCON_25MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 25.0959MHz PLL output with 22.1184MHz IRC*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* APBCLK(31:30)|CLKSEL(29:28)|CLKSEL_Msk(27:25) |CLKSEL_Pos(24:20)|CLKDIV(19:18)|CLKDIV_Msk(17:10)|CLKDIV_Pos(9:5)|IP_EN_Pos(4:0) */
N
N#define MODULE_APBCLK(x)        (((x) >>30) & 0x3)    /*!< Calculate APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK, 0x2:APBCLK1 */
N#define MODULE_CLKSEL(x)        (((x) >>28) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk(x)    (((x) >>25) & 0x7)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)    (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)        (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk(x)    (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)    (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)     (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk            0x0                   /*!< Not mask on MODULE index */
N#define NA                      MODULE_NoMsk          /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x03) << 30)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK, 0x2:APBCLK1 */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 28)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x07) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< APBCLK offset on MODULE index */
N
N
N#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBI_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< EBI Module */
X#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBI_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMA_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PDMA Module */
X#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMA_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISP_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ISP Module */
X#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISP_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WDT Module */
X#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR0 Module */
X#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR0_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR1 Module */
X#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR1_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR2_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR2 Module */
X#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR2_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR3_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR3 Module */
X#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR3_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define FDIV_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_FDIV_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< FDIV Module */
X#define FDIV_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_FDIV_EN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C0 Module */
X#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C0_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C1 Module */
X#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C1_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI0 Module */
X#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI0_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 5)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI1 Module */
X#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI1_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 5)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI2_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 6)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI2 Module */
X#define SPI2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI2_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 6)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI3_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 7)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI3 Module */
X#define SPI3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI3_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 7)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART0_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART0 Module */
X#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART0_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART1_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART1 Module */
X#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART1_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART2_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART2 Module */
X#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART2_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define PWM01_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM01_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(28)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM01 Module */
X#define PWM01_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM01_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(28)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PWM23_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM23_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(30)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM23 Module */
X#define PWM23_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM23_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(30)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PWM45_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM45_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM45 Module */
X#define PWM45_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM45_EN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PWM67_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM67_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 6)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM67 Module */
X#define PWM67_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM67_EN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 6)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_USBD_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))    /*!< USBD Module */
X#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_USBD_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))     
N#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ADC_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< ADC Module */
X#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ADC_EN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N#define I2S_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2S_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2S Module */
X#define I2S_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2S_EN_Pos)  |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define ACMP_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ACMP_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ACMP Module */
X#define ACMP_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ACMP_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PS2_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PS2_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PS2 Module */
X#define PS2_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PS2_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))    /*!< SC0 Module */
X#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0_EN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))     
N#define SC1_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC1_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< SC1 Module */
X#define SC1_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC1_EN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define SC2_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC2_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< SC2 Module */
X#define SC2_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC2_EN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_RTC_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< RTC Module */
X#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_RTC_EN_Pos)  |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WWDT Module */
X#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N
N#define CLK_CLKSEL_PWM01_HXT  (CLK_CLKSEL1_PWM01_S_HXT |CLK_CLKSEL2_PWM01_EXT_HXT)  /*!< HXT Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_LXT  (CLK_CLKSEL1_PWM01_S_LXT |CLK_CLKSEL2_PWM01_EXT_LXT)  /*!< LXT Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_HCLK (CLK_CLKSEL1_PWM01_S_HCLK|CLK_CLKSEL2_PWM01_EXT_HCLK) /*!< HCLK Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_HIRC (CLK_CLKSEL1_PWM01_S_HIRC|CLK_CLKSEL2_PWM01_EXT_HIRC) /*!< HIRC Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_LIRC (CLK_CLKSEL1_PWM01_S_LIRC|CLK_CLKSEL2_PWM01_EXT_LIRC) /*!< LIRC Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM23_HXT  (CLK_CLKSEL1_PWM23_S_HXT |CLK_CLKSEL2_PWM23_EXT_HXT)  /*!< HXT Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_LXT  (CLK_CLKSEL1_PWM23_S_LXT |CLK_CLKSEL2_PWM23_EXT_LXT)  /*!< LXT Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_HCLK (CLK_CLKSEL1_PWM23_S_HCLK|CLK_CLKSEL2_PWM23_EXT_HCLK) /*!< HCLK Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_HIRC (CLK_CLKSEL1_PWM23_S_HIRC|CLK_CLKSEL2_PWM23_EXT_HIRC) /*!< HIRC Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_LIRC (CLK_CLKSEL1_PWM23_S_LIRC|CLK_CLKSEL2_PWM23_EXT_LIRC) /*!< LIRC Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM45_HXT  (CLK_CLKSEL2_PWM45_S_HXT |CLK_CLKSEL2_PWM45_EXT_HXT)  /*!< HXT Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_LXT  (CLK_CLKSEL2_PWM45_S_LXT |CLK_CLKSEL2_PWM45_EXT_LXT)  /*!< LXT Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_HCLK (CLK_CLKSEL2_PWM45_S_HCLK|CLK_CLKSEL2_PWM45_EXT_HCLK) /*!< HCLK Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_HIRC (CLK_CLKSEL2_PWM45_S_HIRC|CLK_CLKSEL2_PWM45_EXT_HIRC) /*!< HIRC Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_LIRC (CLK_CLKSEL2_PWM45_S_LIRC|CLK_CLKSEL2_PWM45_EXT_LIRC) /*!< LIRC Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM67_HXT  (CLK_CLKSEL2_PWM67_S_HXT |CLK_CLKSEL2_PWM67_EXT_HXT)  /*!< HXT Clock selection setting for PWM67 */
N#define CLK_CLKSEL_PWM67_LXT  (CLK_CLKSEL2_PWM67_S_LXT |CLK_CLKSEL2_PWM67_EXT_LXT)  /*!< LXT Clock selection setting for PWM67 */
N#define CLK_CLKSEL_PWM67_HCLK (CLK_CLKSEL2_PWM67_S_HCLK|CLK_CLKSEL2_PWM67_EXT_HCLK) /*!< HCLK Clock selection setting for PWM6 */
N#define CLK_CLKSEL_PWM67_HIRC (CLK_CLKSEL2_PWM67_S_HIRC|CLK_CLKSEL2_PWM67_EXT_HIRC) /*!< HIRC Clock selection setting for PWM6 */
N#define CLK_CLKSEL_PWM67_LIRC (CLK_CLKSEL2_PWM67_S_LIRC|CLK_CLKSEL2_PWM67_EXT_LIRC) /*!< LIRC Clock selection setting for PWM6 */
N
N/*@}*/ /* end of group CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCON;
X    u32PllReg = ((CLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON;
N
N    if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
X    if(u32PllReg & ((1ul << 16) | (1ul << 18)))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __HXT;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCON_BP_Msk)
X    if(u32PllReg & (1ul << 17))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (3ul << 14)) >> 14)];
N    u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1FFul << 0)) >> 0) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1Ful << 9)) >> 9) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
N/**
N  * @brief      This function execute delay function.
N  * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N  *                             50MHz => 335544us, 48MHz => 349525us, 28MHz => 699050us ...
N  * @return     None
N  * @details    Use the SysTick to generate the delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  */
N__STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
Xstatic __inline void CLK_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
N    SysTick->VAL  = (0x00);
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0);
N    
N    /* Disable SysTick counter */
N    SysTick->CTRL = 0;    
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;    
N}
N
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
N
N
N/*@}*/ /* end of group CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CLK_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N
N
N#endif //__CLK_H__
N
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12823 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#include "ACMP.h"
L 1 "..\..\..\Library\StdDriver\inc\ACMP.h" 1
N/**************************************************************************//**
N * @file     acmp.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/04 3:27p $
N * @brief    Analog Comparator (ACMP) driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ACMP_Driver ACMP Driver
N  @{
N*/
N
N/** @addtogroup ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* CMPCR constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_CR_OUTPUT_INV           (1UL << ACMP_CMPCR_CMPINV_Pos)     /*!< CMPCR setting for ACMP output inverse function. */
N#define ACMP_CR_VNEG_BANDGAP         (1UL << ACMP_CMPCR_CMPCN_Pos)      /*!< CMPCR setting for selecting band-gap voltage as the source of ACMP V-. */
N#define ACMP_CR_VNEG_PIN             (0UL << ACMP_CMPCR_CMPCN_Pos)      /*!< CMPCR setting for selecting the voltage of ACMP negative input pin as the source of ACMP V-. */
N#define ACMP_CR_HYSTERESIS_ENABLE    (1UL << ACMP_CMPCR_CMP_HYSEN_Pos)  /*!< CMPCR setting for enabling the hysteresis function. */
N#define ACMP_CR_HYSTERESIS_DISABLE   (0UL << ACMP_CMPCR_CMP_HYSEN_Pos)  /*!< CMPCR setting for disabling the hysteresis function. */
N#define ACMP_CR_INT_ENABLE           (1UL << ACMP_CMPCR_CMPIE_Pos)      /*!< CMPCR setting for enabling the interrupt function. */
N#define ACMP_CR_INT_DISABLE          (0UL << ACMP_CMPCR_CMPIE_Pos)      /*!< CMPCR setting for disabling the interrupt function. */
N#define ACMP_CR_ACMP_ENABLE          (1UL << ACMP_CMPCR_CMPEN_Pos)      /*!< CMPCR setting for enabling the ACMP analog circuit. */
N#define ACMP_CR_ACMP_DISABLE         (0UL << ACMP_CMPCR_CMPEN_Pos)      /*!< CMPCR setting for disabling the ACMP analog circuit. */
N
N/*@}*/ /* end of group ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to enable output inverse
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set CMPINV bit of CMPCR register to enable output inverse function.
N  */
N#define ACMP_ENABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMPINV_Msk)
N
N/**
N  * @brief This macro is used to disable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear CMPINV bit of CMPCR register to disable output inverse function.
N  */
N#define ACMP_DISABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMPINV_Msk)
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Src Comparator negative input selection.  Including:
N  *                  - \ref ACMP_CR_VNEG_PIN
N  *                  - \ref ACMP_CR_VNEG_BANDGAP
N  * @return None
N  * @details This macro will set CMPCN bit of CMPCR register to determine the source of negative input.
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) ((acmp)->CMPCR[(u32ChNum)%2] = ((acmp)->CMPCR[(u32ChNum)%2] & ~ACMP_CMPCR_CMPCN_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set HYSEN bit of CMPCR register to enable hysteresis function.
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMP_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear HYSEN bit of CMPCR register to disable hysteresis function.
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMP_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set CMPIE bit of CMPCR register to enable interrupt function.
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear CMPIE bit of CMPCR register to disable interrupt function.
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMPIE_Msk)
N
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set CMPEN bit of CMPCR register to enable analog comparator.
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear CMPEN bit of CMPCR register to disable analog comparator.
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return  ACMP output value
N  * @details This macro will return the ACMP output value.
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (((acmp)->CMPSR & (ACMP_CMPSR_CO0_Msk<<(u32ChNum)))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   ACMP interrupt occurred or not
N  * @details This macro will return the ACMP interrupt flag.
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (((acmp)->CMPSR & (ACMP_CMPSR_CMPF0_Msk<<(u32ChNum)))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to CMPFn bit of CMPSR register to clear interrupt flag.
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) ((acmp)->CMPSR = (ACMP_CMPSR_CMPF0_Msk<<(u32ChNum)))
N
N
N/* Function prototype declaration */
Nvoid ACMP_Open(ACMP_T *, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *, uint32_t u32ChNum);
N
N/*@}*/ /* end of group ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ACMP_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12824 "..\..\..\Library\Device\Nuvoton\NUC100Series\Include\NUC100Series.h" 2
N#endif
N
N
N
N
N
L 16 "..\main.c" 2
N
N#include "FreeRTOS.h"
L 1 "..\Source\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 "..\Source\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\freeRTOS\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N/* Ensure stdint is only used by the compiler, and not the assembler. */
N#ifdef __ICCARM__
S	#include <stdint.h>
S	extern uint32_t SystemCoreClock;
N#endif
N
N#define configUSE_PREEMPTION			1
N#define configUSE_IDLE_HOOK				0
N#define configUSE_TICK_HOOK				0
N#define configCPU_CLOCK_HZ				( ( unsigned long ) 48000000 )
N#define configTICK_RATE_HZ				( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES			( ( unsigned portBASE_TYPE ) 6 )
N#define configMINIMAL_STACK_SIZE		( ( unsigned short ) 1280 )
N#define configTOTAL_HEAP_SIZE			( ( size_t ) ( 13 * 1024 ) )
N#define configMAX_TASK_NAME_LEN			( 5 )
N#define configUSE_TRACE_FACILITY		1
N#define configUSE_16_BIT_TICKS			0
N#define configIDLE_SHOULD_YIELD			1
N#define configUSE_MUTEXES				1
N#define configQUEUE_REGISTRY_SIZE		8
N#define configCHECK_FOR_STACK_OVERFLOW	0
N#define configUSE_RECURSIVE_MUTEXES		1
N#define configUSE_MALLOC_FAILED_HOOK	0
N#define configUSE_APPLICATION_TASK_TAG	0
N#define configUSE_COUNTING_SEMAPHORES	1
N#define configGENERATE_RUN_TIME_STATS	0
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 			0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N/* Software timer definitions. */
N#define configUSE_TIMERS				1
N#define configTIMER_TASK_PRIORITY		( 2 )
N#define configTIMER_QUEUE_LENGTH		5
N#define configTIMER_TASK_STACK_DEPTH	( 80 )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	1
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N
N/* Normal assert() semantics without relying on the provision of an assert.h
Nheader file. */
N#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }
N
N/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
Nstandard names - or at least those used in the unmodified vector table. */
N#define vPortSVCHandler SVC_Handler
N#define xPortPendSVHandler PendSV_Handler
N#define xPortSysTickHandler SysTick_Handler
N
N#endif /* FREERTOS_CONFIG_H */
N
L 99 "..\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\Source\include\projdefs.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\Source\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\Source\include\portable.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\Source\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\Source\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\Source\portable\RVDS\ARM_CM0\portmacro.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N/*-----------------------------------------------------------*/
N
N
N/* Scheduler utilities. */
Nextern void vPortYield( void );
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portYIELD()					vPortYield()
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
Nextern uint32_t ulSetInterruptMaskFromISR( void );
Nextern void vClearInterruptMaskFromISR( uint32_t ulMask );
N
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulSetInterruptMaskFromISR()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vClearInterruptMaskFromISR( x )
N#define portDISABLE_INTERRUPTS()				__disable_irq()
N#define portENABLE_INTERRUPTS()					__enable_irq()
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N
N#define portNOP()
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 "..\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\Source\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueGenericReceive					MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\Source\include\FreeRTOS.h" 2
N
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
N	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
N	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
N	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
N	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
S	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
S	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
S	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 5 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
S	#define configASSERT( x )
S	#define configASSERT_DEFINED 0
N#else
N	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 1 == 1
N
N	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
N	#endif /* configTIMER_TASK_PRIORITY */
N
N	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
N	#endif /* configTIMER_QUEUE_LENGTH */
N
N	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
N	#endif /* configTIMER_TASK_STACK_DEPTH */
N
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
S	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 8 < 1 )
S	#define vQueueAddToRegistry( xQueue, pcName )
S	#define vQueueUnregisterQueue( xQueue )
S	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
N	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
N	/* Defaults to 0 for backward compatibility. */
N	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
N	/* Defaults to 1 for backward compatibility. */
N	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 0 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 1 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N	#define pcTaskGetTaskName pcTaskGetName
N	#define pcTimerGetTimerName pcTimerGetName
N	#define pcQueueGetQueueName pcQueueGetName
N	#define vTaskGetTaskInfo vTaskGetInfo
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ ( 5 ) ];
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t			uxDummy20;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t uxDummy8;
N		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 18 "..\main.c" 2
N#include "task.h"
L 1 "..\Source\include\task.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\Source\include\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V9.0.0"
N#define tskKERNEL_VERSION_MAJOR 9
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 0
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,
N							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X							TaskHandle_t * const pxCreatedTask ) ;  
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
S									const char * const pcName,
S									const uint32_t ulStackDepth,
S									void * const pvParameters,
S									UBaseType_t uxPriority,
S									StackType_t * const puxStackBuffer,
S									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 19 "..\main.c" 2
N#include "queue.h"
L 1 "..\Source\include\queue.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
N#endif
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreateStatic(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize,
N							  uint8_t *pucQueueStorageBuffer,
N							  StaticQueue_t *pxQueueBuffer
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @param pucQueueStorageBuffer If uxItemSize is not zero then
N * pucQueueStorageBuffer must point to a uint8_t array that is at least large
N * enough to hold the maximum number of items that can be in the queue at any
N * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
N * zero then pucQueueStorageBuffer can be NULL.
N *
N * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
N * will be used to hold the queue's data structure.
N *
N * @return If the queue is created then a handle to the created queue is
N * returned.  If pxQueueBuffer is NULL then NULL is returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N #define QUEUE_LENGTH 10
N #define ITEM_SIZE sizeof( uint32_t )
N
N // xQueueBuffer will hold the queue structure.
N StaticQueue_t xQueueBuffer;
N
N // ucQueueStorage will hold the items posted to the queue.  Must be at least
N // [(queue length) * ( queue item size)] bytes long.
N uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
N							ITEM_SIZE	  // The size of each item in the queue
N							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
N							&xQueueBuffer ); // The buffer that will hold the queue structure.
N
N	// The queue is guaranteed to be created successfully as no dynamic memory
N	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreateStatic xQueueCreateStatic
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
NQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 8 > 0 )
N	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) ;  
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 8 > 0 )
N	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
X	void vQueueUnregisterQueue( QueueHandle_t xQueue ) ;
N#endif
N
N/*
N * The queue registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
N * up and return the name of a queue in the queue registry from the queue's
N * handle.
N *
N * @param xQueue The handle of the queue the name of which will be returned.
N * @return If the queue is in the registry then a pointer to the name of the
N * queue is returned.  If the queue is not in the registry then NULL is
N * returned.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 8 > 0 )
N	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	const char *pcQueueGetName( QueueHandle_t xQueue ) ;  
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 20 "..\main.c" 2
N#include "croutine.h"
L 1 "..\Source\include\croutine.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef CO_ROUTINE_H
N#define CO_ROUTINE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include croutine.h"
N#endif
N
N#include "list.h"
L 1 "..\Source\include\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
S#define LIST_H
S
S/*
S * The list structure members are modified from within interrupts, and therefore
S * by rights should be declared volatile.  However, they are only modified in a
S * functionally atomic way (within critical sections of with the scheduler
S * suspended) and are either passed by reference into a function or indexed via
S * a volatile variable.  Therefore, in all use cases tested so far, the volatile
S * qualifier can be omitted in order to provide a moderate performance
S * improvement without adversely affecting functional behaviour.  The assembly
S * instructions generated by the IAR, ARM and GCC compilers when the respective
S * compiler's options were set for maximum optimisation has been inspected and
S * deemed to be as intended.  That said, as compiler technology advances, and
S * especially if aggressive cross module optimisation is used (a use case that
S * has not been exercised to any great extend) then it is feasible that the
S * volatile qualifier will be needed for correct optimisation.  It is expected
S * that a compiler removing essential code because, without the volatile
S * qualifier on the list structure members and with aggressive cross module
S * optimisation, the compiler deemed the code unnecessary will result in
S * complete and obvious failure of the scheduler.  If this is ever experienced
S * then the volatile qualifier can be inserted in the relevant places within the
S * list structures by simply defining configLIST_VOLATILE to volatile in
S * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
S * If configLIST_VOLATILE is not defined then the preprocessor directives below
S * will simply #define configLIST_VOLATILE away completely.
S *
S * To use volatile list structure members then add the following line to
S * FreeRTOSConfig.h (without the quotes):
S * "#define configLIST_VOLATILE volatile"
S */
S#ifndef configLIST_VOLATILE
S	#define configLIST_VOLATILE
S#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/* Macros that can be used to place known values within the list structures,
Sthen check that the known values do not get corrupted during the execution of
Sthe application.   These may catch the list data structures being overwritten in
Smemory.  They will not catch data errors caused by incorrect configuration or
Suse of FreeRTOS.*/
S#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
S	/* Define the macros to do nothing. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
S	#define listTEST_LIST_INTEGRITY( pxList )
S#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
S
S
S/*
S * Definition of the only type of object that a list can contain.
S */
Sstruct xLIST_ITEM
S{
S	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
S	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
S	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
S	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
S	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
S	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S};
Stypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
S
Sstruct xMINI_LIST_ITEM
S{
S	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S	configLIST_VOLATILE TickType_t xItemValue;
S	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
S	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
S};
Stypedef struct xMINI_LIST_ITEM MiniListItem_t;
S
S/*
S * Definition of the type of queue used by the scheduler.
S */
Stypedef struct xLIST
S{
S	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
S	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
S	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
S	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
S} List_t;
S
S/*
S * Access macro to set the owner of a list item.  The owner of a list item
S * is the object (usually a TCB) that contains the list item.
S *
S * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
S * \ingroup LinkedList
S */
S#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
S
S/*
S * Access macro to get the owner of a list item.  The owner of a list item
S * is the object (usually a TCB) that contains the list item.
S *
S * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
S * \ingroup LinkedList
S */
S#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
S
S/*
S * Access macro to set the value of the list item.  In most cases the value is
S * used to sort the list in descending order.
S *
S * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
S * \ingroup LinkedList
S */
S#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
S
S/*
S * Access macro to retrieve the value of the list item.  The value can
S * represent anything - for example the priority of a task, or the time at
S * which a task should be unblocked.
S *
S * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
S * \ingroup LinkedList
S */
S#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
S
S/*
S * Access macro to retrieve the value of the list item at the head of a given
S * list.
S *
S * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
S * \ingroup LinkedList
S */
S#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
S
S/*
S * Return the list item at the head of the list.
S *
S * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
S * \ingroup LinkedList
S */
S#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
S
S/*
S * Return the list item at the head of the list.
S *
S * \page listGET_NEXT listGET_NEXT
S * \ingroup LinkedList
S */
S#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
S
S/*
S * Return the list item that marks the end of the list
S *
S * \page listGET_END_MARKER listGET_END_MARKER
S * \ingroup LinkedList
S */
S#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
S
S/*
S * Access macro to determine if a list contains any items.  The macro will
S * only have the value true if the list is empty.
S *
S * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
S * \ingroup LinkedList
S */
S#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
S
S/*
S * Access macro to return the number of items in the list.
S */
S#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
S
S/*
S * Access function to obtain the owner of the next entry in a list.
S *
S * The list member pxIndex is used to walk through a list.  Calling
S * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
S * and returns that entry's pxOwner parameter.  Using multiple calls to this
S * function it is therefore possible to move through every item contained in
S * a list.
S *
S * The pxOwner parameter of a list item is a pointer to the object that owns
S * the list item.  In the scheduler this is normally a task control block.
S * The pxOwner parameter effectively creates a two way link between the list
S * item and its owner.
S *
S * @param pxTCB pxTCB is set to the address of the owner of the next list item.
S * @param pxList The list from which the next item owner is to be returned.
S *
S * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
S * \ingroup LinkedList
S */
S#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
S{																							\
SList_t * const pxConstList = ( pxList );													\
S	/* Increment the index to the next item and return the item, ensuring */				\
S	/* we don't return the marker used at the end of the list.  */							\
S	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
S	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
S	{																						\
S		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
S	}																						\
S	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
S}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
S
S
S/*
S * Access function to obtain the owner of the first entry in a list.  Lists
S * are normally sorted in ascending item value order.
S *
S * This function returns the pxOwner member of the first item in the list.
S * The pxOwner parameter of a list item is a pointer to the object that owns
S * the list item.  In the scheduler this is normally a task control block.
S * The pxOwner parameter effectively creates a two way link between the list
S * item and its owner.
S *
S * @param pxList The list from which the owner of the head item is to be
S * returned.
S *
S * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
S * \ingroup LinkedList
S */
S#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
S
S/*
S * Check to see if a list item is within a list.  The list item maintains a
S * "container" pointer that points to the list it is in.  All this macro does
S * is check to see if the container and the list match.
S *
S * @param pxList The list we want to know if the list item is within.
S * @param pxListItem The list item we want to know if is in the list.
S * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
S */
S#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
S
S/*
S * Return the list a list item is contained within (referenced from).
S *
S * @param pxListItem The list item being queried.
S * @return A pointer to the List_t object that references the pxListItem
S */
S#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
S
S/*
S * This provides a crude means of knowing if a list has been initialised, as
S * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
S * function.
S */
S#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
S
S/*
S * Must be called before a list is used!  This initialises all the members
S * of the list structure and inserts the xListEnd item into the list as a
S * marker to the back of the list.
S *
S * @param pxList Pointer to the list being initialised.
S *
S * \page vListInitialise vListInitialise
S * \ingroup LinkedList
S */
Svoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
S
S/*
S * Must be called before a list item is used.  This sets the list container to
S * null so the item does not think that it is already contained in a list.
S *
S * @param pxItem Pointer to the list item being initialised.
S *
S * \page vListInitialiseItem vListInitialiseItem
S * \ingroup LinkedList
S */
Svoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
S
S/*
S * Insert a list item into a list.  The item will be inserted into the list in
S * a position determined by its item value (descending item value order).
S *
S * @param pxList The list into which the item is to be inserted.
S *
S * @param pxNewListItem The item that is to be placed in the list.
S *
S * \page vListInsert vListInsert
S * \ingroup LinkedList
S */
Svoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
S
S/*
S * Insert a list item into a list.  The item will be inserted in a position
S * such that it will be the last item within the list returned by multiple
S * calls to listGET_OWNER_OF_NEXT_ENTRY.
S *
S * The list member pxIndex is used to walk through a list.  Calling
S * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
S * Placing an item in a list using vListInsertEnd effectively places the item
S * in the list position pointed to by pxIndex.  This means that every other
S * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
S * the pxIndex parameter again points to the item being inserted.
S *
S * @param pxList The list into which the item is to be inserted.
S *
S * @param pxNewListItem The list item to be inserted into the list.
S *
S * \page vListInsertEnd vListInsertEnd
S * \ingroup LinkedList
S */
Svoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
S
S/*
S * Remove an item from a list.  The list item has a pointer to the list that
S * it is in, so only the list item need be passed into the function.
S *
S * @param uxListRemove The item to be removed.  The item will remove itself from
S * the list pointed to by it's pxContainer parameter.
S *
S * @return The number of items that remain in the list after the list item has
S * been removed.
S *
S * \page uxListRemove uxListRemove
S * \ingroup LinkedList
S */
SUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif
N
L 78 "..\Source\include\croutine.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Used to hide the implementation of the co-routine control block.  The
Ncontrol block structure however has to be included in the header due to
Nthe macro implementation of the co-routine functionality. */
Ntypedef void * CoRoutineHandle_t;
N
N/* Defines the prototype to which co-routine functions must conform. */
Ntypedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );
N
Ntypedef struct corCoRoutineControlBlock
N{
N	crCOROUTINE_CODE 	pxCoRoutineFunction;
N	ListItem_t			xGenericListItem;	/*< List item used to place the CRCB in ready and blocked queues. */
N	ListItem_t			xEventListItem;		/*< List item used to place the CRCB in event lists. */
N	UBaseType_t 		uxPriority;			/*< The priority of the co-routine in relation to other co-routines. */
N	UBaseType_t 		uxIndex;			/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. */
N	uint16_t 			uxState;			/*< Used internally by the co-routine implementation. */
N} CRCB_t; /* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. */
N
N/**
N * croutine. h
N *<pre>
N BaseType_t xCoRoutineCreate(
N                                 crCOROUTINE_CODE pxCoRoutineCode,
N                                 UBaseType_t uxPriority,
N                                 UBaseType_t uxIndex
N                               );</pre>
N *
N * Create a new co-routine and add it to the list of co-routines that are
N * ready to run.
N *
N * @param pxCoRoutineCode Pointer to the co-routine function.  Co-routine
N * functions require special syntax - see the co-routine section of the WEB
N * documentation for more information.
N *
N * @param uxPriority The priority with respect to other co-routines at which
N *  the co-routine will run.
N *
N * @param uxIndex Used to distinguish between different co-routines that
N * execute the same function.  See the example below and the co-routine section
N * of the WEB documentation for further information.
N *
N * @return pdPASS if the co-routine was successfully created and added to a ready
N * list, otherwise an error code defined with ProjDefs.h.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N // This may not be necessary for const variables.
N static const char cLedToFlash[ 2 ] = { 5, 6 };
N static const TickType_t uxFlashRates[ 2 ] = { 200, 400 };
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N         // This co-routine just delays for a fixed period, then toggles
N         // an LED.  Two co-routines are created using this function, so
N         // the uxIndex parameter is used to tell the co-routine which
N         // LED to flash and how int32_t to delay.  This assumes xQueue has
N         // already been created.
N         vParTestToggleLED( cLedToFlash[ uxIndex ] );
N         crDELAY( xHandle, uxFlashRates[ uxIndex ] );
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }
N
N // Function that creates two co-routines.
N void vOtherFunction( void )
N {
N uint8_t ucParameterToPass;
N TaskHandle_t xHandle;
N
N     // Create two co-routines at priority 0.  The first is given index 0
N     // so (from the code above) toggles LED 5 every 200 ticks.  The second
N     // is given index 1 so toggles LED 6 every 400 ticks.
N     for( uxIndex = 0; uxIndex < 2; uxIndex++ )
N     {
N         xCoRoutineCreate( vFlashCoRoutine, 0, uxIndex );
N     }
N }
N   </pre>
N * \defgroup xCoRoutineCreate xCoRoutineCreate
N * \ingroup Tasks
N */
NBaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex );
N
N
N/**
N * croutine. h
N *<pre>
N void vCoRoutineSchedule( void );</pre>
N *
N * Run a co-routine.
N *
N * vCoRoutineSchedule() executes the highest priority co-routine that is able
N * to run.  The co-routine will execute until it either blocks, yields or is
N * preempted by a task.  Co-routines execute cooperatively so one
N * co-routine cannot be preempted by another, but can be preempted by a task.
N *
N * If an application comprises of both tasks and co-routines then
N * vCoRoutineSchedule should be called from the idle task (in an idle task
N * hook).
N *
N * Example usage:
N   <pre>
N // This idle task hook will schedule a co-routine each time it is called.
N // The rest of the idle task will execute between co-routine calls.
N void vApplicationIdleHook( void )
N {
N	vCoRoutineSchedule();
N }
N
N // Alternatively, if you do not require any other part of the idle task to
N // execute, the idle task hook can call vCoRoutineScheduler() within an
N // infinite loop.
N void vApplicationIdleHook( void )
N {
N    for( ;; )
N    {
N        vCoRoutineSchedule();
N    }
N }
N </pre>
N * \defgroup vCoRoutineSchedule vCoRoutineSchedule
N * \ingroup Tasks
N */
Nvoid vCoRoutineSchedule( void );
N
N/**
N * croutine. h
N * <pre>
N crSTART( CoRoutineHandle_t xHandle );</pre>
N *
N * This macro MUST always be called at the start of a co-routine function.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static int32_t ulAVariable;
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N          // Co-routine functionality goes here.
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }</pre>
N * \defgroup crSTART crSTART
N * \ingroup Tasks
N */
N#define crSTART( pxCRCB ) switch( ( ( CRCB_t * )( pxCRCB ) )->uxState ) { case 0:
N
N/**
N * croutine. h
N * <pre>
N crEND();</pre>
N *
N * This macro MUST always be called at the end of a co-routine function.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static int32_t ulAVariable;
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N          // Co-routine functionality goes here.
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }</pre>
N * \defgroup crSTART crSTART
N * \ingroup Tasks
N */
N#define crEND() }
N
N/*
N * These macros are intended for internal use by the co-routine implementation
N * only.  The macros should not be used directly by application writers.
N */
N#define crSET_STATE0( xHandle ) ( ( CRCB_t * )( xHandle ) )->uxState = (__LINE__ * 2); return; case (__LINE__ * 2):
N#define crSET_STATE1( xHandle ) ( ( CRCB_t * )( xHandle ) )->uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1):
N
N/**
N * croutine. h
N *<pre>
N crDELAY( CoRoutineHandle_t xHandle, TickType_t xTicksToDelay );</pre>
N *
N * Delay a co-routine for a fixed period of time.
N *
N * crDELAY can only be called from the co-routine function itself - not
N * from within a function called by the co-routine function.  This is because
N * co-routines do not maintain their own stack.
N *
N * @param xHandle The handle of the co-routine to delay.  This is the xHandle
N * parameter of the co-routine function.
N *
N * @param xTickToDelay The number of ticks that the co-routine should delay
N * for.  The actual amount of time this equates to is defined by
N * configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant portTICK_PERIOD_MS
N * can be used to convert ticks to milliseconds.
N *
N * Example usage:
N   <pre>
N // Co-routine to be created.
N void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N // This may not be necessary for const variables.
N // We are to delay for 200ms.
N static const xTickType xDelayTime = 200 / portTICK_PERIOD_MS;
N
N     // Must start every co-routine with a call to crSTART();
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N        // Delay for 200ms.
N        crDELAY( xHandle, xDelayTime );
N
N        // Do something here.
N     }
N
N     // Must end every co-routine with a call to crEND();
N     crEND();
N }</pre>
N * \defgroup crDELAY crDELAY
N * \ingroup Tasks
N */
N#define crDELAY( xHandle, xTicksToDelay )												\
N	if( ( xTicksToDelay ) > 0 )															\
N	{																					\
N		vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );							\
N	}																					\
N	crSET_STATE0( ( xHandle ) );
X#define crDELAY( xHandle, xTicksToDelay )													if( ( xTicksToDelay ) > 0 )																{																							vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL );								}																						crSET_STATE0( ( xHandle ) );
N
N/**
N * <pre>
N crQUEUE_SEND(
N                  CoRoutineHandle_t xHandle,
N                  QueueHandle_t pxQueue,
N                  void *pvItemToQueue,
N                  TickType_t xTicksToWait,
N                  BaseType_t *pxResult
N             )</pre>
N *
N * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
N * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
N *
N * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
N * xQueueSend() and xQueueReceive() can only be used from tasks.
N *
N * crQUEUE_SEND can only be called from the co-routine function itself - not
N * from within a function called by the co-routine function.  This is because
N * co-routines do not maintain their own stack.
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xHandle The handle of the calling co-routine.  This is the xHandle
N * parameter of the co-routine function.
N *
N * @param pxQueue The handle of the queue on which the data will be posted.
N * The handle is obtained as the return value when the queue is created using
N * the xQueueCreate() API function.
N *
N * @param pvItemToQueue A pointer to the data being posted onto the queue.
N * The number of bytes of each queued item is specified when the queue is
N * created.  This number of bytes is copied from pvItemToQueue into the queue
N * itself.
N *
N * @param xTickToDelay The number of ticks that the co-routine should block
N * to wait for space to become available on the queue, should space not be
N * available immediately. The actual amount of time this equates to is defined
N * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
N * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see example
N * below).
N *
N * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
N * data was successfully posted onto the queue, otherwise it will be set to an
N * error defined within ProjDefs.h.
N *
N * Example usage:
N   <pre>
N // Co-routine function that blocks for a fixed period then posts a number onto
N // a queue.
N static void prvCoRoutineFlashTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static BaseType_t xNumberToPost = 0;
N static BaseType_t xResult;
N
N    // Co-routines must begin with a call to crSTART().
N    crSTART( xHandle );
N
N    for( ;; )
N    {
N        // This assumes the queue has already been created.
N        crQUEUE_SEND( xHandle, xCoRoutineQueue, &xNumberToPost, NO_DELAY, &xResult );
N
N        if( xResult != pdPASS )
N        {
N            // The message was not posted!
N        }
N
N        // Increment the number to be posted onto the queue.
N        xNumberToPost++;
N
N        // Delay for 100 ticks.
N        crDELAY( xHandle, 100 );
N    }
N
N    // Co-routines must end with a call to crEND().
N    crEND();
N }</pre>
N * \defgroup crQUEUE_SEND crQUEUE_SEND
N * \ingroup Tasks
N */
N#define crQUEUE_SEND( xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult )			\
N{																						\
N	*( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );	\
N	if( *( pxResult ) == errQUEUE_BLOCKED )												\
N	{																					\
N		crSET_STATE0( ( xHandle ) );													\
N		*pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );					\
N	}																					\
N	if( *pxResult == errQUEUE_YIELD )													\
N	{																					\
N		crSET_STATE1( ( xHandle ) );													\
N		*pxResult = pdPASS;																\
N	}																					\
N}
X#define crQUEUE_SEND( xHandle, pxQueue, pvItemToQueue, xTicksToWait, pxResult )			{																							*( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) );		if( *( pxResult ) == errQUEUE_BLOCKED )													{																							crSET_STATE0( ( xHandle ) );															*pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 );						}																						if( *pxResult == errQUEUE_YIELD )														{																							crSET_STATE1( ( xHandle ) );															*pxResult = pdPASS;																	}																					}
N
N/**
N * croutine. h
N * <pre>
N  crQUEUE_RECEIVE(
N                     CoRoutineHandle_t xHandle,
N                     QueueHandle_t pxQueue,
N                     void *pvBuffer,
N                     TickType_t xTicksToWait,
N                     BaseType_t *pxResult
N                 )</pre>
N *
N * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
N * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
N *
N * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
N * xQueueSend() and xQueueReceive() can only be used from tasks.
N *
N * crQUEUE_RECEIVE can only be called from the co-routine function itself - not
N * from within a function called by the co-routine function.  This is because
N * co-routines do not maintain their own stack.
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xHandle The handle of the calling co-routine.  This is the xHandle
N * parameter of the co-routine function.
N *
N * @param pxQueue The handle of the queue from which the data will be received.
N * The handle is obtained as the return value when the queue is created using
N * the xQueueCreate() API function.
N *
N * @param pvBuffer The buffer into which the received item is to be copied.
N * The number of bytes of each queued item is specified when the queue is
N * created.  This number of bytes is copied into pvBuffer.
N *
N * @param xTickToDelay The number of ticks that the co-routine should block
N * to wait for data to become available from the queue, should data not be
N * available immediately. The actual amount of time this equates to is defined
N * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
N * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see the
N * crQUEUE_SEND example).
N *
N * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
N * data was successfully retrieved from the queue, otherwise it will be set to
N * an error code as defined within ProjDefs.h.
N *
N * Example usage:
N <pre>
N // A co-routine receives the number of an LED to flash from a queue.  It
N // blocks on the queue until the number is received.
N static void prvCoRoutineFlashWorkTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // Variables in co-routines must be declared static if they must maintain value across a blocking call.
N static BaseType_t xResult;
N static UBaseType_t uxLEDToFlash;
N
N    // All co-routines must start with a call to crSTART().
N    crSTART( xHandle );
N
N    for( ;; )
N    {
N        // Wait for data to become available on the queue.
N        crQUEUE_RECEIVE( xHandle, xCoRoutineQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
N
N        if( xResult == pdPASS )
N        {
N            // We received the LED to flash - flash it!
N            vParTestToggleLED( uxLEDToFlash );
N        }
N    }
N
N    crEND();
N }</pre>
N * \defgroup crQUEUE_RECEIVE crQUEUE_RECEIVE
N * \ingroup Tasks
N */
N#define crQUEUE_RECEIVE( xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult )			\
N{																						\
N	*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );		\
N	if( *( pxResult ) == errQUEUE_BLOCKED ) 											\
N	{																					\
N		crSET_STATE0( ( xHandle ) );													\
N		*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );				\
N	}																					\
N	if( *( pxResult ) == errQUEUE_YIELD )												\
N	{																					\
N		crSET_STATE1( ( xHandle ) );													\
N		*( pxResult ) = pdPASS;															\
N	}																					\
N}
X#define crQUEUE_RECEIVE( xHandle, pxQueue, pvBuffer, xTicksToWait, pxResult )			{																							*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) );			if( *( pxResult ) == errQUEUE_BLOCKED ) 												{																							crSET_STATE0( ( xHandle ) );															*( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 );					}																						if( *( pxResult ) == errQUEUE_YIELD )													{																							crSET_STATE1( ( xHandle ) );															*( pxResult ) = pdPASS;																}																					}
N
N/**
N * croutine. h
N * <pre>
N  crQUEUE_SEND_FROM_ISR(
N                            QueueHandle_t pxQueue,
N                            void *pvItemToQueue,
N                            BaseType_t xCoRoutinePreviouslyWoken
N                       )</pre>
N *
N * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
N * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
N * functions used by tasks.
N *
N * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
N * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
N * xQueueReceiveFromISR() can only be used to pass data between a task and and
N * ISR.
N *
N * crQUEUE_SEND_FROM_ISR can only be called from an ISR to send data to a queue
N * that is being used from within a co-routine.
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xCoRoutinePreviouslyWoken This is included so an ISR can post onto
N * the same queue multiple times from a single interrupt.  The first call
N * should always pass in pdFALSE.  Subsequent calls should pass in
N * the value returned from the previous call.
N *
N * @return pdTRUE if a co-routine was woken by posting onto the queue.  This is
N * used by the ISR to determine if a context switch may be required following
N * the ISR.
N *
N * Example usage:
N <pre>
N // A co-routine that blocks on a queue waiting for characters to be received.
N static void vReceivingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N char cRxedChar;
N BaseType_t xResult;
N
N     // All co-routines must start with a call to crSTART().
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N         // Wait for data to become available on the queue.  This assumes the
N         // queue xCommsRxQueue has already been created!
N         crQUEUE_RECEIVE( xHandle, xCommsRxQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
N
N         // Was a character received?
N         if( xResult == pdPASS )
N         {
N             // Process the character here.
N         }
N     }
N
N     // All co-routines must end with a call to crEND().
N     crEND();
N }
N
N // An ISR that uses a queue to send characters received on a serial port to
N // a co-routine.
N void vUART_ISR( void )
N {
N char cRxedChar;
N BaseType_t xCRWokenByPost = pdFALSE;
N
N     // We loop around reading characters until there are none left in the UART.
N     while( UART_RX_REG_NOT_EMPTY() )
N     {
N         // Obtain the character from the UART.
N         cRxedChar = UART_RX_REG;
N
N         // Post the character onto a queue.  xCRWokenByPost will be pdFALSE
N         // the first time around the loop.  If the post causes a co-routine
N         // to be woken (unblocked) then xCRWokenByPost will be set to pdTRUE.
N         // In this manner we can ensure that if more than one co-routine is
N         // blocked on the queue only one is woken by this ISR no matter how
N         // many characters are posted to the queue.
N         xCRWokenByPost = crQUEUE_SEND_FROM_ISR( xCommsRxQueue, &cRxedChar, xCRWokenByPost );
N     }
N }</pre>
N * \defgroup crQUEUE_SEND_FROM_ISR crQUEUE_SEND_FROM_ISR
N * \ingroup Tasks
N */
N#define crQUEUE_SEND_FROM_ISR( pxQueue, pvItemToQueue, xCoRoutinePreviouslyWoken ) xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )
N
N
N/**
N * croutine. h
N * <pre>
N  crQUEUE_SEND_FROM_ISR(
N                            QueueHandle_t pxQueue,
N                            void *pvBuffer,
N                            BaseType_t * pxCoRoutineWoken
N                       )</pre>
N *
N * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
N * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
N * functions used by tasks.
N *
N * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
N * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
N * xQueueReceiveFromISR() can only be used to pass data between a task and and
N * ISR.
N *
N * crQUEUE_RECEIVE_FROM_ISR can only be called from an ISR to receive data
N * from a queue that is being used from within a co-routine (a co-routine
N * posted to the queue).
N *
N * See the co-routine section of the WEB documentation for information on
N * passing data between tasks and co-routines and between ISR's and
N * co-routines.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvBuffer A pointer to a buffer into which the received item will be
N * placed.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from the queue into
N * pvBuffer.
N *
N * @param pxCoRoutineWoken A co-routine may be blocked waiting for space to become
N * available on the queue.  If crQUEUE_RECEIVE_FROM_ISR causes such a
N * co-routine to unblock *pxCoRoutineWoken will get set to pdTRUE, otherwise
N * *pxCoRoutineWoken will remain unchanged.
N *
N * @return pdTRUE an item was successfully received from the queue, otherwise
N * pdFALSE.
N *
N * Example usage:
N <pre>
N // A co-routine that posts a character to a queue then blocks for a fixed
N // period.  The character is incremented each time.
N static void vSendingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
N {
N // cChar holds its value while this co-routine is blocked and must therefore
N // be declared static.
N static char cCharToTx = 'a';
N BaseType_t xResult;
N
N     // All co-routines must start with a call to crSTART().
N     crSTART( xHandle );
N
N     for( ;; )
N     {
N         // Send the next character to the queue.
N         crQUEUE_SEND( xHandle, xCoRoutineQueue, &cCharToTx, NO_DELAY, &xResult );
N
N         if( xResult == pdPASS )
N         {
N             // The character was successfully posted to the queue.
N         }
N		 else
N		 {
N			// Could not post the character to the queue.
N		 }
N
N         // Enable the UART Tx interrupt to cause an interrupt in this
N		 // hypothetical UART.  The interrupt will obtain the character
N		 // from the queue and send it.
N		 ENABLE_RX_INTERRUPT();
N
N		 // Increment to the next character then block for a fixed period.
N		 // cCharToTx will maintain its value across the delay as it is
N		 // declared static.
N		 cCharToTx++;
N		 if( cCharToTx > 'x' )
N		 {
N			cCharToTx = 'a';
N		 }
N		 crDELAY( 100 );
N     }
N
N     // All co-routines must end with a call to crEND().
N     crEND();
N }
N
N // An ISR that uses a queue to receive characters to send on a UART.
N void vUART_ISR( void )
N {
N char cCharToTx;
N BaseType_t xCRWokenByPost = pdFALSE;
N
N     while( UART_TX_REG_EMPTY() )
N     {
N         // Are there any characters in the queue waiting to be sent?
N		 // xCRWokenByPost will automatically be set to pdTRUE if a co-routine
N		 // is woken by the post - ensuring that only a single co-routine is
N		 // woken no matter how many times we go around this loop.
N         if( crQUEUE_RECEIVE_FROM_ISR( pxQueue, &cCharToTx, &xCRWokenByPost ) )
N		 {
N			 SEND_CHARACTER( cCharToTx );
N		 }
N     }
N }</pre>
N * \defgroup crQUEUE_RECEIVE_FROM_ISR crQUEUE_RECEIVE_FROM_ISR
N * \ingroup Tasks
N */
N#define crQUEUE_RECEIVE_FROM_ISR( pxQueue, pvBuffer, pxCoRoutineWoken ) xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )
N
N/*
N * This function is intended for internal use by the co-routine macros only.
N * The macro nature of the co-routine implementation requires that the
N * prototype appears here.  The function should not be used by application
N * writers.
N *
N * Removes the current co-routine from its ready list and places it in the
N * appropriate delayed list.
N */
Nvoid vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList );
N
N/*
N * This function is intended for internal use by the queue implementation only.
N * The function should not be used by application writers.
N *
N * Removes the highest priority co-routine from the event list and places it in
N * the pending ready list.
N */
NBaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList );
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* CO_ROUTINE_H */
L 21 "..\main.c" 2
N
N#define PLL_CLOCK           50000000
N
N
Nstatic void vTaskMsgPro1(void* pvParameters);
N
Nstatic TaskHandle_t xHandleTaskMsgPro1 = NULL;
Xstatic TaskHandle_t xHandleTaskMsgPro1 = 0;
N
Nvoid vStartThreadTasks( void );
N
N
N/* Function prototype declaration */
Nvoid SYS_Init(void);
Nvoid UART0_Init(void);
N
N
N
N/*****************************************
N*
N*        DIO Mapping interrupt
N*
N*****************************************/
N
Nvoid GPAB_IRQHandler()
N{	
N}
N
N
Nvoid SYS_Init(void)
N{
N    /*---------------------------------------------------------------------------------------------------------*/
N    /* Init System Clock                                                                                       */
N    /*---------------------------------------------------------------------------------------------------------*/
N
N    /* Enable Internal RC 22.1184 MHz clock */
N    CLK_EnableXtalRC(CLK_PWRCON_OSC22M_EN_Msk);
X    CLK_EnableXtalRC((1ul << 2));
N
N    /* Waiting for Internal RC clock ready */
N    CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);
X    CLK_WaitClockReady((1ul << 4));
N	
N		/* Switch HCLK clock source to Internal RC and HCLK source divide 1 */
N    CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_HIRC, CLK_CLKDIV_HCLK(1));
X    CLK_SetHCLK((0x7UL<<0), ((1)-1));
N    
N    /* Enable external 12 MHz XTAL */
N    CLK_EnableXtalRC(CLK_PWRCON_XTL12M_EN_Msk);
X    CLK_EnableXtalRC((1ul << 0));
N
N    /* Waiting for clock ready */
N    CLK_WaitClockReady(CLK_CLKSTATUS_XTL12M_STB_Msk);
X    CLK_WaitClockReady((1ul << 0));
N
N    /* Set core clock rate as PLL_CLOCK from PLL */
N    CLK_SetCoreClock(PLL_CLOCK);
X    CLK_SetCoreClock(50000000);
N		
N    /* Enable UART module clock */
N    CLK_EnableModuleClock(UART0_MODULE);		
X    CLK_EnableModuleClock(((((1) & 0x03) << 30)|(((16) & 0x1f) << 0)| (((1) & 0x03) << 28)|(((3) & 0x07) << 25)|(((24) & 0x1f) << 20)| (((0) & 0x03) << 18)|(((0x0F) & 0xff) << 10)|(((8) & 0x1f) << 5)));		
N
N    /* Select HXT as the clock source of UART0 */
N    CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART_S_HXT, CLK_CLKDIV_UART(1));
X    CLK_SetModuleClock(((((1) & 0x03) << 30)|(((16) & 0x1f) << 0)| (((1) & 0x03) << 28)|(((3) & 0x07) << 25)|(((24) & 0x1f) << 20)| (((0) & 0x03) << 18)|(((0x0F) & 0xff) << 10)|(((8) & 0x1f) << 5)), (0x0UL<<24), (((1)-1) << 8));
N
N    /* Enable SPI1 peripheral clock */
N    CLK_EnableModuleClock(SPI0_MODULE);          //change SPI0_MODULE
X    CLK_EnableModuleClock(((((1) & 0x03) << 30)|(((12) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((1) & 0x07) << 25)|(((4) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)));          
N
N    /* Select HCLK as the clock source of SPI1 */
N    CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL1_SPI0_S_HCLK, MODULE_NoMsk);
X    CLK_SetModuleClock(((((1) & 0x03) << 30)|(((12) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((1) & 0x07) << 25)|(((4) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)), (0x1UL<<4), 0x0);
N
N		/* Enable Timer 0 module clock */
N		CLK_EnableModuleClock(TMR0_MODULE);
X		CLK_EnableModuleClock(((((1) & 0x03) << 30)|(((2) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((7) & 0x07) << 25)|(((8) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)));
N		
N		/* Select Timer 0 module clock source */
N		CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0_S_HXT, NULL);
X		CLK_SetModuleClock(((((1) & 0x03) << 30)|(((2) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((7) & 0x07) << 25)|(((8) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)), (0x0UL<<8), 0);
N
N    /* Update System Core Clock */
N    /* User can use SystemCoreClockUpdate() to calculate PllClock, SystemCoreClock and CyclesPerUs automatically. */
N    //SystemCoreClockUpdate();
N
N    /*---------------------------------------------------------------------------------------------------------*/
N    /* Init I/O Multi-function                                                                                 */
N    /*---------------------------------------------------------------------------------------------------------*/
N    /* Set PB multi-function pins for UART0 RXD and TXD */
N    SYS->GPB_MFP = SYS_GPB_MFP_PB0_UART0_RXD | SYS_GPB_MFP_PB1_UART0_TXD;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->GPB_MFP = (1UL<<0) | (1UL<<1);
N
N//		SYS->GPC_MFP = SYS_GPC_MFP_PC8_SPI1_SS0 | SYS_GPC_MFP_PC9_SPI1_CLK | SYS_GPC_MFP_PC10_SPI1_MISO0 | SYS_GPC_MFP_PC11_SPI1_MOSI0;
N//		SYS->ALT_MFP = SYS_ALT_MFP_PC8_SPI1_SS0;
N
N		
N//		SYS->GPA_MFP = SYS_GPA_MFP_PA1_GPIO | SYS_GPA_MFP_PA2_GPIO | SYS_GPA_MFP_PA3_GPIO;
N		
N    /* Setup SPI0 multi-function pins */
N    SYS->GPC_MFP = SYS_GPC_MFP_PC0_SPI0_SS0 | SYS_GPC_MFP_PC1_SPI0_CLK | SYS_GPC_MFP_PC2_SPI0_MISO0 | SYS_GPC_MFP_PC3_SPI0_MOSI0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->GPC_MFP = (1UL<<0) | (1UL<<1) | (1UL<<2) | (1UL<<3);
N    SYS->ALT_MFP = SYS_ALT_MFP_PC0_SPI0_SS0 | SYS_ALT_MFP_PC1_SPI0_CLK | SYS_ALT_MFP_PC2_SPI0_MISO0 | SYS_ALT_MFP_PC3_SPI0_MOSI0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->ALT_MFP = 0x00000000UL | 0x00000000UL | 0x00000000UL | 0x00000000UL;
N}
N
Nvoid UART0_Init(void)
N{
N		SYS_ResetModule(UART0_RST);
X		SYS_ResetModule(((0x4<<24) | 16 ));
N	
N    /* Configure UART0: 115200, 8-bit word, no parity bit, 1 stop bit. */
N    UART_Open(UART0, 115200);
X    UART_Open(((UART_T *) ((( uint32_t)0x40000000) + 0x50000)), 115200);
N}
N
N/**********************************************/
N/*                Main function               */
N/*                LoRa SPI sample             */
N/*        Bit length of a transaction: 8      */
N/* SPI1, SS0(PC.8), CLK(PC.9), MISO0(PC.10)   */
N/*                MOSI0(PC.11)                */
N/**********************************************/
Nint main(void)
N{
N    /* Unlock protected registers */
N    SYS_UnlockReg();
N    /* Init system, IP clock and multi-function I/O. */
N    SYS_Init();
N    /* Lock protected registers */
N    SYS_LockReg();
N	
N		UART0_Init();
N
N		printf("test\r\n");
N		//vStartThreadTasks();
N		vTaskStartScheduler();
N
N		while(1);
N
N}
N
N/*
Nvoid vStartThreadTasks( void )
N{
N		xTaskCreate(vTaskMsgPro1,(signed char *) "vTaskMsgPro1",512,NULL,2,( xTaskHandle * ) NULL );
N}
Noq{XDn
N*/
Nstatic void vTaskMsgPro1(void* pvParameters)
N{
N		while(1)
N		{
N				printf("Task1\r\n");
N				vTaskDelay(1000);
N		}
N}
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
W "..\main.c" 153 13 function "vTaskMsgPro1"  was declared but never referenced
W "..\main.c" 27 21 variable "xHandleTaskMsgPro1"  was declared but never referenced
